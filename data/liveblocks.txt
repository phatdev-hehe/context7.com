TITLE: Setting up Liveblocks with Zustand Store
DESCRIPTION: TypeScript implementation of a Zustand store with Liveblocks integration. Creates a client with public API key and sets up the store with Liveblocks middleware.

LANGUAGE: typescript
CODE:
import create from "zustand";
import { createClient } from "@liveblocks/client";
import { liveblocks } from "@liveblocks/zustand";
import type { WithLiveblocks } from "@liveblocks/zustand";

type State = {
  // Your Zustand state type will be defined here
};

const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

const useStore = create<WithLiveblocks<State>>()(
  liveblocks(
    (set) => ({
      // Your state and actions will go here
    }),
    { client }
  )
);

export default useStore;

----------------------------------------

TITLE: Setting Up Collaborative Lexical Text Editor
DESCRIPTION: Implementation of a collaborative text editor using Lexical and Liveblocks. The LiveblocksPlugin makes the editor collaborative, while the FloatingToolbar adds a text selection toolbar.

LANGUAGE: tsx
CODE:
"use client";

import { LexicalComposer } from "@lexical/react/LexicalComposer";
import { RichTextPlugin } from "@lexical/react/LexicalRichTextPlugin";
import { ContentEditable } from "@lexical/react/LexicalContentEditable";
import { LexicalErrorBoundary } from "@lexical/react/LexicalErrorBoundary";
import {
  liveblocksConfig,
  LiveblocksPlugin,
  FloatingToolbar,
} from "@liveblocks/react-lexical";
import { Threads } from "./Threads";

export function Editor() {
  // Wrap your Lexical config with `liveblocksConfig`
  const initialConfig = liveblocksConfig({
    namespace: "Demo",
    onError: (error: unknown) => {
      console.error(error);
      throw error;
    },
  });

  return (
    <LexicalComposer initialConfig={initialConfig}>
      <div className="editor">
        <RichTextPlugin
          contentEditable={<ContentEditable />}
          placeholder={<div className="placeholder">Start typing here…</div>}
          ErrorBoundary={LexicalErrorBoundary}
        />
        <LiveblocksPlugin>
          <Threads />
          <FloatingToolbar />
        </LiveblocksPlugin>
      </div>
    </LexicalComposer>
  );
}

----------------------------------------

TITLE: Connecting Zustand Store to Liveblocks Client
DESCRIPTION: Code to set up a Zustand store with Liveblocks middleware, creating a connection to the Liveblocks collaborative infrastructure.

LANGUAGE: typescript
CODE:
"use client";

import create from "zustand";
import { createClient } from "@liveblocks/client";
import { liveblocks } from "@liveblocks/zustand";
import type { WithLiveblocks } from "@liveblocks/zustand";

type State = {
  // Your Zustand state type will be defined here
};

const client = createClient({
  publicApiKey: "pk_prod_xxxxxxxxxxxxxxxxxxxxxxxx",
});

const useStore = create<WithLiveblocks<State>>()(
  liveblocks(
    (set) => ({
      // Your state and actions will go here
    }),
    { client }
  )
);

export default useStore;

----------------------------------------

TITLE: Configuring LiveblocksProvider with All Available Options in React
DESCRIPTION: Comprehensive example showing all available configuration options for LiveblocksProvider, including authentication methods, throttling, connection settings, and resolver functions for user info, room info, and mention suggestions.

LANGUAGE: tsx
CODE:
import { LiveblocksProvider } from "@liveblocks/react/suspense";

function App() {
  return (
    <LiveblocksProvider
      // Connect with authEndpoint
      authEndpoint="/api/liveblocks-auth"
      // ---
      // Alternatively, use an authEndpoint callback
      // authEndpoint={async (room) => {
      //   const response = await fetch("/api/liveblocks-auth", {
      //     method: "POST",
      //     headers: {
      //       Authentication: "<your own headers here>",
      //       "Content-Type": "application/json",
      //     },
      //     body: JSON.stringify({ room }),
      //   });
      //   return await response.json();
      // }}
      //
      // Alternatively, use a public key
      // publicApiKey="pk_..."
      //
      // Throttle time (ms) between WebSocket updates
      throttle={100}
      // ---
      // Prevent browser tab from closing while local changes aren't synchronized yet
      preventUnsavedChanges={false}
      // ---
      // Throw lost-connection event after 5 seconds offline
      lostConnectionTimeout={5000}
      // ---
      // Disconnect users after X (ms) of inactivity, disabled by default
      backgroundKeepAliveTimeout={undefined}
      // ---
      // Resolve user info for Comments and Notifications
      resolveUsers={async ({ userIds }) => {
        const usersData = await __getUsersFromDB__(userIds);

        return usersData.map((userData) => ({
          name: userData.name,
          avatar: userData.avatar.src,
        }));
      }}
      // ---
      // Resolve room info for Notifications
      resolveRoomsInfo={async ({ roomIds }) => {
        const documentsData = await __getDocumentsFromDB__(roomIds);

        return documentsData.map((documentData) => ({
          name: documentData.name,
          // url: documentData.url,
        }));
      }}
      // ---
      // Resolve mention suggestions for Comments
      resolveMentionSuggestions={async ({ text, roomId }) => {
        const workspaceUsers = await __getWorkspaceUsersFromDB__(roomId);

        if (!text) {
          // Show all workspace users by default
          return __getUserIds__(workspaceUsers);
        } else {
          const matchingUsers = __findUsers__(workspaceUsers, text);
          return __getUserIds__(matchingUsers);
        }
      }}
      // ---
      // Polyfill options for non-browser environments
      polyfills={
        {
          // atob,
          // fetch,
          // WebSocket,
        }
      }
    >
      {/* children */}
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Comprehensive createClient Configuration with All Available Options in TypeScript
DESCRIPTION: Complete example showing all possible configuration options for createClient including authentication methods, throttling, connection management, user resolution, and polyfills. This demonstrates the full range of client customization.

LANGUAGE: tsx
CODE:
import { createClient } from "@liveblocks/client";

const client = createClient({
  // Connect with authEndpoint
  authEndpoint: "/api/liveblocks-auth",

  // Alternatively, use an authEndpoint callback
  // authEndpoint: async (room) => {
  //   const response = await fetch("/api/liveblocks-auth", {
  //   method: "POST",
  //   headers: {
  //     Authentication: "<your own headers here>",
  //     "Content-Type": "application/json",
  //   },
  //   body: JSON.stringify({ room }),
  // });
  // return await response.json();
  // },

  // Alternatively, use a public key
  // publicApiKey: "pk_...",

  // Throttle time (ms) between WebSocket updates
  throttle: 100,

  // Prevent browser tab from closing while local changes aren't synchronized yet
  preventUnsavedChanges: false,

  // Throw lost-connection event after 5 seconds offline
  lostConnectionTimeout: 5000,

  // Disconnect users after X (ms) of inactivity, disabled by default
  backgroundKeepAliveTimeout: undefined,

  // Resolve user info for Comments and Notifications
  resolveUsers: async ({ userIds }) => {
    const usersData = await __getUsersFromDB__(userIds);

    return usersData.map((userData) => ({
      name: userData.name,
      avatar: userData.avatar.src,
    }));
  },

  // Resolve room info for Notifications
  resolveRoomsInfo: async ({ roomIds }) => {
    const documentsData = await __getDocumentsFromDB__(roomIds);

    return documentsData.map((documentData) => ({
      name: documentData.name,
      // url: documentData.url,
    }));
  },

  // Resolve mention suggestions for Comments
  resolveMentionSuggestions: async ({ text, roomId }) => {
    const workspaceUsers = await __getWorkspaceUsersFromDB__(roomId);

    if (!text) {
      // Show all workspace users by default
      return __getUserIds__(workspaceUsers);
    } else {
      const matchingUsers = __findUsers__(workspaceUsers, text);
      return __getUserIds__(matchingUsers);
    }
  },

  // Polyfill options for non-browser environments
  polyfills: {
    // atob,
    // fetch,
    // WebSocket,
  },
});

----------------------------------------

TITLE: Creating a Liveblocks Client with Basic Configuration in TypeScript
DESCRIPTION: Basic example of creating a Liveblocks client using createClient function with an authentication endpoint. This is the foundation for connecting to Liveblocks servers.

LANGUAGE: tsx
CODE:
import { createClient } from "@liveblocks/client";

const client = createClient({
  authEndpoint: "/api/liveblocks-auth",

  // Other options
  // ...
});

----------------------------------------

TITLE: Detailed Typing for createRoomContext in Liveblocks
DESCRIPTION: Comprehensive example of typing createRoomContext with detailed explanations of each type parameter. Shows how to properly type Presence, Storage, UserMeta, RoomEvent, and ThreadMetadata for complete type safety.

LANGUAGE: tsx
CODE:
import { createClient } from "@liveblocks/client";
import { createRoomContext } from "@liveblocks/react";

const client = createClient({
  // publicApiKey: "",
  // authEndpoint: "/api/liveblocks-auth",
});

// Presence represents the properties that exist on every user in the Room
// and that will automatically be kept in sync. Accessible through the
// `user.presence` property. Must be JSON-serializable.
type Presence = {
  // cursor: { x: number, y: number } | null,
  // ...
};

// Optionally, Storage represents the shared document that persists in the
// Room, even after all users leave. Fields under Storage typically are
// LiveList, LiveMap, LiveObject instances, for which updates are
// automatically persisted and synced to all connected clients.
type Storage = {
  // animals: LiveList<string>,
  // ...
};

// Optionally, UserMeta represents static/readonly metadata on each user, as
// provided by your own custom auth back end (if used). Useful for data that
// will not change during a session, like a user's name or avatar.
// type UserMeta = {
//   id?: string,  // Accessible through `user.id`
//   info?: Json,  // Accessible through `user.info`
// };

// Optionally, the type of custom events broadcast and listened to in this
// room. Use a union for multiple events. Must be JSON-serializable.
// type RoomEvent = {};

// Optionally, when using Comments, ThreadMetadata represents metadata on
// each thread. Can only contain booleans, strings, and numbers.
// export type ThreadMetadata = {
//   pinned: boolean;
//   quote: string;
//   time: number;
// };

export const {
  RoomProvider,
  useMyPresence,
  useStorage,

  // Other hooks
  // ...
} = createRoomContext<
  Presence,
  Storage
  /* UserMeta, RoomEvent, ThreadMetadata */
>(client);

----------------------------------------

TITLE: Creating Typed Room Context with createRoomContext in Liveblocks
DESCRIPTION: Configuration for createRoomContext to generate typed hooks for use in an application. This approach creates a RoomProvider and related hooks with proper TypeScript typing for Presence and Storage.

LANGUAGE: tsx
CODE:
import { createClient } from "@liveblocks/client";
import { createRoomContext } from "@liveblocks/react";

const client = createClient({
  // publicApiKey: "",
  // authEndpoint: "/api/liveblocks-auth",
});

type Presence = {};
type Storage = {};
type UserMeta = {};
type RoomEvent = {};
type ThreadMetadata = {};

// +++
export const {
  RoomProvider,
  useMyPresence,

  // Other hooks
  // ...
} = createRoomContext<Presence, Storage, UserMeta, RoomEvent, ThreadMetadata>(
  client
);
// +++

----------------------------------------

TITLE: Implementing Zustand Store Without Liveblocks Middleware in TypeScript
DESCRIPTION: Basic Zustand store implementation without Liveblocks middleware. This shows the setup of a simple to-do list store with state types and actions.

LANGUAGE: typescript
CODE:
import create from "zustand";

type State = {
  draft: string;
  isTyping: boolean;
  todos: Todo[];
  setDraft: (draft: string) => void;
  addTodo: () => void;
  deleteTodo: (index: number) => void;
};

create<State>(/* ... */);

----------------------------------------

TITLE: Configuring User Mentions in LiveblocksProvider with TypeScript
DESCRIPTION: This code demonstrates how to set up user mentions and mention suggestions in a Lexical text editor using the LiveblocksProvider component. It configures callbacks to resolve user information and generate mention suggestions.

LANGUAGE: tsx
CODE:
import { LiveblocksProvider } from "@liveblocks/react/suspense";

function App() {
  return (
    <LiveblocksProvider
      resolveUsers={async ({ userIds }) => {
        // Return user info from their `userIds`
        // ...
      }}
      resolveMentionSuggestions={async ({ text, roomId }) => {
        // Return suggestions from the search `text`
        // ...
      }}
    >
      {/* children */}
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Configuring storageMapping in liveblocks middleware
DESCRIPTION: Example of how to use storageMapping to synchronize part of the Zustand state with Liveblocks Room storage. The scientist object is mapped to be persisted in Liveblocks storage.

LANGUAGE: javascript
CODE:
const useStore = create(
  liveblocks(
    (set) => ({
      scientist: { name: "" },
    }),
    {
      client,
      storageMapping: { scientist: true },
    }
  )
);

----------------------------------------

TITLE: Setting Up Liveblocks Client
DESCRIPTION: Creating a Liveblocks client instance with a public API key, which handles communication with the Liveblocks backend.

LANGUAGE: ts
CODE:
const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

----------------------------------------

TITLE: Installing Liveblocks Packages for Next.js
DESCRIPTION: Command to install the required Liveblocks client and React packages for a Next.js project. All packages should use the same version.

LANGUAGE: bash
CODE:
npm install @liveblocks/client @liveblocks/react

----------------------------------------

TITLE: Using useMyPresence Hook to Manage User Presence
DESCRIPTION: Demonstrates how to use the useMyPresence hook to get and update the current user's presence data. Updates are merged with existing presence data rather than replacing it entirely.

LANGUAGE: ts
CODE:
import { useMyPresence } from "@liveblocks/react/suspense";

const [myPresence, updateMyPresence] = useMyPresence();
updateMyPresence({ x: 0 });
updateMyPresence({ y: 0 });

// At the next render, "myPresence" will be equal to "{ x: 0, y: 0 }"

----------------------------------------

TITLE: Integrating Zustand with Liveblocks Middleware
DESCRIPTION: Example of integrating a Zustand store with Liveblocks middleware to enable real-time collaboration. Shows how to map local state to Liveblocks presence and storage.

LANGUAGE: typescript
CODE:
import create from "zustand";
import { createClient } from "@liveblocks/client";
import { middleware } from "@liveblocks/zustand";

const client = createClient({ /*...*/ });

type State = {
  draft: string;
  isTyping: boolean;
  todos: Todo[];
  setDraft: (draft: string) => void;
  addTodo: () => void;
  deleteTodo: (index: number) => void;
};

create(
  middleware<State>(/* ... */, {
    client,
    presenceMapping: { isTyping: true },
    storageMapping: { todos: true }
  })
);

----------------------------------------

TITLE: Initializing Liveblocks Client and Retrieving Comment Data in TypeScript
DESCRIPTION: Sets up the Liveblocks webhook handler and client to verify incoming webhook requests and retrieve comment data when a new comment is created. This snippet shows how to validate webhook payloads and fetch both the comment content and thread participants.

LANGUAGE: typescript
CODE:
import { Liveblocks, WebhookHandler } from "@liveblocks/node";

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";
const liveblocks = new Liveblocks({ secret: API_SECRET });

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When a comment has been created
  if (event.type === "commentCreated") {
    const { roomId, threadId, commentId } = event.data;

    try {
      // Get comment data and participants
      const [comment, { participantIds }] = await Promise.all([
        liveblocks.getComment({ roomId, threadId, commentId }),
        liveblocks.getThreadParticipants({ roomId, threadId }),
      ]);

      // Send notifications
      // ...
    } catch (err) {
      console.log(err);
      return new Response("Could not fetch comment data", { status: 500 });
    }
  }

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Complete Webhook Implementation with Email Notifications in TypeScript
DESCRIPTION: A complete implementation of a Liveblocks webhook handler that processes comment creation events, formats the comments into HTML, and sends email notifications to all thread participants. This snippet shows how to retrieve user information from a database and loop through participants to send personalized notifications.

LANGUAGE: typescript
CODE:
import { Liveblocks, WebhookHandler, stringifyCommentBody } from "@liveblocks/node";

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";
const liveblocks = new Liveblocks({ secret: API_SECRET });

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When a comment has been created
  if (event.type === "commentCreated") {
    const { roomId, threadId, commentId } = event.data;

    try {
      // Get comment data and participants
      const [comment, { participantIds }] = await Promise.all([
        liveblocks.getComment({ roomId, threadId, commentId }),
        liveblocks.getThreadParticipants({ roomId, threadId }),
      ]);

      // HTML comment body
      const htmlComment = await stringifyCommentBody(comment.body, {
        format: "html",

        async resolveUsers({ userIds }) {
          // Get the correct users from your database
          const users = await __getUsers__(userIds);

          return users.map((user) => ({
            name: user.name,
          }));
        },
      });

      // Get participating users from your database
      const users = await __getUsers__(participantIds);

      // Send notifications
      for (const user of users) {
        // Send email to the user's email address
        // send({
        //   from: "hello@my-company.com",
        //   to: user.email,
        //   title: "New comment",
        //   html: htmlComment
        // });
      }
    } catch (err) {
      console.log(err);
      return new Response("Could not fetch comment data", { status: 500 });
    }
  }

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Modifying Liveblocks Storage from Node.js Server
DESCRIPTION: This code demonstrates how to create a Liveblocks client and use the mutateStorage method to update storage in a server context. The example shows creating a client with a secret key and then implementing a POST handler that adds an item to a list in storage.

LANGUAGE: typescript
CODE:
// Creating a node client (centrally)
const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export async function POST() {
  console.log("Updating storage");

  // Mutate storage
  +++
  await liveblocks.mutateStorage(
    "my-room",

    ({ root }) => {
      root.get("list").push("item3");
    }
  );
  +++

  console.log("Storage update complete!");
}

----------------------------------------

TITLE: Defining CSS Classes for Rich Text Formatting
DESCRIPTION: CSS module containing styles for rich text formatting options such as bold, italic, underline, and paragraph spacing. These classes are referenced in the Lexical editor theme configuration.

LANGUAGE: css
CODE:
/* ... */

.textBold {
  font-weight: bold;
}

.textItalic {
  font-style: italic;
}

.textUnderline {
  text-decoration: underline;
}

.paragraph {
  margin: 0.2rem 0;
}

----------------------------------------

TITLE: Defining Presence Type in TypeScript Configuration
DESCRIPTION: TypeScript type definition for presence in liveblocks.config.ts that includes cursor coordinates with null option for off-screen cursors.

LANGUAGE: typescript
CODE:
// Presence type
Presence: {
  cursor: { x: number; y: number } | null;
};

----------------------------------------

TITLE: TypeScript Typing with client.enter for Liveblocks
DESCRIPTION: Alternative way to type Liveblocks data by passing generic types to client.enterRoom. This method allows creating different room types with their own typed hooks, which can be useful for applications with multiple room types.

LANGUAGE: typescript
CODE:
import { LiveList } from "@liveblocks/client";

// Each user's Presence
type Presence = {
  cursor: { x: number; y: number };
};

// The Storage tree for the room
type Storage = {
  animals: LiveList<string>;
};

// User information set when authenticating with a secret key
type UserMeta = {
  id: string;
  info: {
    // Custom properties, corresponds with userInfo
  };
};

// Custom events that can be broadcast, use a union for multiple events
type RoomEvent = {
  type: "REACTION";
  emoji: "🔥";
};

const { room, leave } = client.enterRoom<
  Presence,
  Storage,
  UserMeta,
  RoomEvent
>("my-room-id");

----------------------------------------

TITLE: Accessing the current Liveblocks room
DESCRIPTION: Retrieving the current Room instance from the liveblocks state, which provides access to the full Room API features.

LANGUAGE: javascript
CODE:
const {
  liveblocks: { room },
} = useStore();

----------------------------------------

TITLE: Real-world resolveMentionSuggestions Example for Liveblocks Comments
DESCRIPTION: Practical implementation of resolveMentionSuggestions that fetches all users and filters them based on the search text, returning matching user IDs for the mention suggestions UI.

LANGUAGE: tsx
CODE:
<LiveblocksProvider
  resolveUsers={async ({ userIds }) => {
    // ...
  }}
  resolveMentionSuggestions={async ({ text, roomId }) => {
    // Fetch all users from your back end
    let users = await __fetchAllUsers__();

    // If there's a query, filter for the relevant users
    if (text) {
      // Filter any way you'd like, e.g. checking if the name matches
      users = users.filter((user) => user.name.includes(text));
    }

    // Return the filtered `userIds`
    return users.map((user) => user.id);
  }}

  // ...
/>;

----------------------------------------

TITLE: Defining a Schema for Collaborative Todo List in TypeScript
DESCRIPTION: Example schema definition for a todo list application, showing how to define the Storage type with a LiveList of Todo objects. This schema ensures all todos have a text property and an optional checked property.

LANGUAGE: typescript
CODE:
type Storage {
  todos: LiveList<LiveObject<Todo>>
}

type Todo {
  text: string
  checked?: boolean
}

----------------------------------------

TITLE: Complete Webhook Request Handler Implementation
DESCRIPTION: A full example of implementing a webhook handler that verifies requests, processes event types, and returns appropriate HTTP status codes.

LANGUAGE: typescript
CODE:
import { WebhookHandler } from "@liveblocks/node";

// Will fail if not properly initialized with a secret
const webhookHandler = new WebhookHandler("whsec_...");

export default function webhookRequestHandler(req, res) {
  try {
    const event = webhookHandler.verifyRequest({
      headers: req.headers,
      rawBody: req.body,
    });

    // Use the event, for example...
    if (event.type === "storageUpdated") {
      // { roomId: "my-room-name", projectId: "8sfhs5s...", ... }
      console.log(event.data);
    }
  } catch (error) {
    console.error(error);
    return res.status(400).end();
  }

  res.status(200).end();
}

----------------------------------------

TITLE: Advanced TypeScript Configuration for Liveblocks with Examples
DESCRIPTION: Shows a more complete example of TypeScript definitions for Liveblocks, including examples for presence, storage, user metadata, room events, thread metadata, room info, and activities data.

LANGUAGE: ts
CODE:
import { LiveList } from "@liveblocks/client";

declare global {
  interface Liveblocks {
    // Each user's Presence, for useMyPresence, useOthers, etc.
    Presence: {
      // Example, real-time cursor coordinates
      cursor: { x: number; y: number };
    };

    // The Storage tree for the room, for useMutation, useStorage, etc.
    Storage: {
      // Example, a conflict-free list
      animals: LiveList<string>;
    };

    UserMeta: {
      id: string;
      // Custom user info set when authenticating with a secret key
      info: {
        // Example properties, for useSelf, useUser, useOthers, etc.
        name: string;
        avatar: string;
      };
    };

    // Custom events, for useBroadcastEvent, useEventListener
    // Example has two events, using a union
    RoomEvent: { type: "PLAY" } | { type: "REACTION"; emoji: "🔥" };

    // Custom metadata set on threads, for useThreads, useCreateThread, etc.
    ThreadMetadata: {
      // Example, attaching coordinates to a thread
      x: number;
      y: number;
    };

    // Custom room info set with resolveRoomsInfo, for useRoomInfo
    RoomInfo: {
      // Example, rooms with a title and url
      title: string;
      url: string;
    };

    // Custom activities data for custom notification kinds
    ActivitiesData: {
      // Example, a custom $alert kind
      $alert: {
        title: string;
        message: string;
      };
    };
  }
}

// Necessary if you have no imports/exports
export {};

----------------------------------------

TITLE: Integrating Toolbar and Leaf Components into Slate Editor
DESCRIPTION: Updates the main Editor component to include the text formatting toolbar and leaf renderer. Uses the renderLeaf callback to apply text formatting styles through the Leaf component.

LANGUAGE: tsx
CODE:
import { Toolbar } from "@/src/Toolbar";
import { Leaf } from "@/src/Leaf";
// ...

export default function SlateEditor() {
  // ...

  const renderLeaf = useCallback((props: any) => <Leaf {...props} />, []);

  return (
    <div className={styles.container}>
      <div className={styles.editorContainer}>
        <Slate editor={editor} initialValue={[emptyNode]}>
          <Cursors>
            <div className={styles.editorHeader}>
              <Toolbar />
            </div>
            <Editable
              className={styles.editor}
              placeholder="Start typing here…"
              renderLeaf={renderLeaf}
            />
          </Cursors>
        </Slate>
      </div>
    </div>
  );
}

----------------------------------------

TITLE: Displaying Other Users' Cursors with useOthers
DESCRIPTION: This comprehensive example shows how to track and display other users' cursor positions in real-time. It combines useOthers and useUpdateMyPresence hooks to update the current user's cursor position and render cursors for other connected users.

LANGUAGE: tsx
CODE:
import {
  useOthers,
  useUpdateMyPresence,
  RoomProvider,
} from "@liveblocks/react/suspense";

function App() {
  const others = useOthers();
  const updateMyPresence = useUpdateMyPresence();

  return (
    <div
      style={{ width: "100vw", height: "100vh" }}
      onPointerMove={(e) =>
        updateMyPresence({ cursor: { x: e.clientX, y: e.clientY } })
      }
      onPointerLeave={() => updateMyPresence({ cursor: null })}
    >
      {others.map(({ connectionId, presence }) =>
        presence.cursor ? (
          <Cursor
            key={connectionId}
            x={presence.cursor.x}
            y={presence.cursor.y}
          />
        ) : null
      )}
    </div>
  );
}

// Basic cursor component
function Cursor({ x, y }) {
  return (
    <img
      style={{
        position: "absolute",
        transform: `translate(${x}px, ${y}px)`,
      }}
      src="/assets/cursor.svg"
    />
  );
}

----------------------------------------

TITLE: Styling Avatars for Collaborative Editing
DESCRIPTION: CSS module for styling user avatars in a collaborative editor. Includes styles for avatar positioning, tooltips that show on hover, and circular image containers with border effects.

LANGUAGE: css
CODE:
.avatars {
  display: flex;
  padding: 0 0.75rem;
}

.avatar {
  display: flex;
  place-content: center;
  position: relative;
  border: 4px solid #fff;
  border-radius: 9999px;
  width: 42px;
  height: 42px;
  background-color: #9ca3af;
  margin-left: -0.75rem;
}

.avatar:before {
  content: attr(data-tooltip);
  position: absolute;
  top: 100%;
  opacity: 0;
  transition: opacity 0.15s ease;
  padding: 5px 10px;
  color: white;
  font-size: 0.75rem;
  border-radius: 8px;
  margin-top: 10px;
  z-index: 1;
  background: black;
  white-space: nowrap;
}

.avatar:hover:before {
  opacity: 1;
}

.avatar_picture {
  width: 100%;
  height: 100%;
  border-radius: 9999px;
}

----------------------------------------

TITLE: Configuring Zustand Store with Liveblocks Storage for Shapes
DESCRIPTION: Enhanced store setup that defines Shape type and configures Liveblocks storage mapping to persist shapes. This enables automatic synchronization of shape data across clients and persistence after users disconnect.

LANGUAGE: typescript
CODE:
import create from "zustand";
import { createClient } from "@liveblocks/client";
import { liveblocks } from "@liveblocks/zustand";
import type { WithLiveblocks } from "@liveblocks/zustand";

export type Shape = {
  x: number;
  y: number;
  fill: string;
};

type State = {
  shapes: Record<string, Shape>;
};

const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

const useStore = create<WithLiveblocks<State>>()(
  liveblocks(
    (set) => ({
      shapes: {},
    }),
    {
      client,
      storageMapping: { shapes: true },
    }
  )
);

export default useStore;

----------------------------------------

TITLE: Setting Up Liveblocks Client with Room Provider
DESCRIPTION: React component that initializes the Liveblocks client and creates a room. This sets up the virtual space where multiple users can collaborate in real-time.

LANGUAGE: tsx
CODE:
"use client";

import {
  LiveblocksProvider,
  RoomProvider,
} from "@liveblocks/react/suspense";
import { Editor } from "./Editor";

export default function App() {
  return (
    <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>\n      <RoomProvider id="my-room">
        {/* ... */}
      </RoomProvider>
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Setting Room Permissions for Liveblocks Session
DESCRIPTION: Configures which rooms and permissions the user session should have access to. This demonstrates setting both specific room access and wildcard permissions.

LANGUAGE: typescript
CODE:
session.allow("my-room-1", session.FULL_ACCESS);
session.allow("my-room-2", session.FULL_ACCESS);
session.allow("my-room-3", session.FULL_ACCESS);
session.allow("my-team:*", session.READ_ACCESS);

----------------------------------------

TITLE: Creating Live Avatars Component with Liveblocks Hooks
DESCRIPTION: A component that displays avatars for all users currently in the document using Liveblocks' useOthers and useSelf hooks. Each avatar displays the user's profile picture and shows their name on hover.

LANGUAGE: tsx
CODE:
import { useOthers, useSelf } from "@/liveblocks.config";
import styles from "./Avatars.module.css";

export function Avatars() {
  const users = useOthers();
  const currentUser = useSelf();

  return (
    <div className={styles.avatars}>
      {users.map(({ connectionId, info }) => {
        return (
          <Avatar key={connectionId} picture={info.picture} name={info.name} />
        );
      })}

      {currentUser && (
        <div className="relative ml-8 first:ml-0">
          <Avatar
            picture={currentUser.info.picture}
            name={currentUser.info.name}
          />
        </div>
      )}
    </div>
  );
}

export function Avatar({ picture, name }: { picture: string; name: string }) {
  return (
    <div className={styles.avatar} data-tooltip={name}>
      <img
        src={picture}
        className={styles.avatar_picture}
        data-tooltip={name}
      />
    </div>
  );
}

----------------------------------------

TITLE: Using History Hooks for Undo/Redo Operations
DESCRIPTION: Demonstrates usage of useHistory, useUndo, useRedo, useCanUndo, and useCanRedo hooks to manage the history stack for collaborative editing.

LANGUAGE: typescript
CODE:
import { useHistory } from "@liveblocks/react/suspense";

const { undo, redo, pause, resume } = useHistory();

LANGUAGE: typescript
CODE:
import { useUndo } from "@liveblocks/react/suspense";

const undo = useUndo();

LANGUAGE: typescript
CODE:
import { useRedo } from "@liveblocks/react/suspense";

const redo = useRedo();

LANGUAGE: typescript
CODE:
import { useCanUndo, useUpdateMyPresence } from "@liveblocks/react/suspense";

const updateMyPresence = useUpdateMyPresence();
const canUndo = useCanUndo();

updateMyPresence({ y: 0 });

// At the next render, "canUndo" will be true

LANGUAGE: typescript
CODE:
import {
  useCanRedo,
  useUndo,
  useUpdateMyPresence,
} from "@liveblocks/react/suspense";

const updateMyPresence = useUpdateMyPresence();
const undo = useUndo();
const canRedo = useCanRedo();

updateMyPresence({ y: 0 });
undo();

// At the next render, "canRedo" will be true

----------------------------------------

TITLE: Implementing a Collaborative Monaco Editor with Yjs and Liveblocks
DESCRIPTION: React component that integrates Monaco editor with Yjs and Liveblocks to create a collaborative code editor with real-time updates, cursor tracking, and synchronized editing.

LANGUAGE: tsx
CODE:
"use client";

import * as Y from "yjs";
import { LiveblocksYjsProvider } from "@liveblocks/yjs";
import { TypedLiveblocksProvider, useRoom } from "@/liveblocks.config";
import { useCallback, useEffect, useState } from "react";
import styles from "./CollaborativeEditor.module.css";
import { Editor } from "@monaco-editor/react";
import { editor } from "monaco-editor";
import { MonacoBinding } from "y-monaco";
import { Awareness } from "y-protocols/awareness";

// Collaborative code editor with undo/redo, live cursors, and live avatars
export function CollaborativeEditor() {
  const room = useRoom();
  const [provider, setProvider] = useState<TypedLiveblocksProvider>();
  const [editorRef, setEditorRef] = useState<editor.IStandaloneCodeEditor>();

  // Set up Liveblocks Yjs provider and attach Monaco editor
  useEffect(() => {
    let yProvider: TypedLiveblocksProvider;
    let yDoc: Y.Doc;
    let binding: MonacoBinding;

    if (editorRef) {
      yDoc = new Y.Doc();
      const yText = yDoc.getText("monaco");
      yProvider = new LiveblocksYjsProvider(room, yDoc);
      setProvider(yProvider);

      // Attach Yjs to Monaco
      binding = new MonacoBinding(
        yText,
        editorRef.getModel() as editor.ITextModel,
        new Set([editorRef]),
        yProvider.awareness as Awareness
      );
    }

    return () => {
      yDoc?.destroy();
      yProvider?.destroy();
      binding?.destroy();
    };
  }, [editorRef, room]);

  const handleOnMount = useCallback((e: editor.IStandaloneCodeEditor) => {
    setEditorRef(e);
  }, []);

  return (
    <div className={styles.container}>
      <div className={styles.editorContainer}>
        <Editor
          onMount={handleOnMount}
          height="100%"
          width="100hw"
          theme="vs-light"
          defaultLanguage="typescript"
          defaultValue=""
          options={{
            tabSize: 2,
            padding: { top: 20 },
          }}
        />
      </div>
    </div>
  );
}

----------------------------------------

TITLE: Implementing a Collaborative Slate Text Editor with Yjs
DESCRIPTION: Complete implementation of a collaborative text editor component using Slate with Yjs integration through Liveblocks. The component handles synchronization between users and editor state management.

LANGUAGE: tsx
CODE:
"use client";

import { getYjsProviderForRoom } from "@liveblocks/yjs";
import { useEffect, useMemo, useState } from "react";
import { createEditor, Editor, Transforms } from "slate";
import { Editable, Slate, withReact } from "slate-react";
import { withYjs, YjsEditor } from "@slate-yjs/core";
import * as Y from "yjs";
import { useRoom } from "../liveblocks.config";
import styles from "./CollaborativeEditor.module.css";

export function CollaborativeEditor() {
  const room = useRoom();
  const [connected, setConnected] = useState(false);

  // Set up Yjs
  const yProvider = getYjsProviderForRoom(room);
  const yDoc = yProvider.getYDoc();
  const sharedType = yDoc.get("slate", Y.XmlText) as Y.XmlText;

  useEffect(() => {
    yProvider.on("sync", setConnected);

    return () => {
      yProvider?.off("sync", setConnected);
    };
  }, [room]);

  if (!connected || !sharedType) {
    return <div>Loading…</div>;
  }

  return <SlateEditor sharedType={sharedType} />;
}

const emptyNode = {
  children: [{ text: "" }],
};

function SlateEditor({ sharedType }: { sharedType: Y.XmlText }) {
  const editor = useMemo(() => {
    const e = withReact(withYjs(createEditor(), sharedType));

    // Ensure editor always has at least 1 valid child
    const { normalizeNode } = e;
    e.normalizeNode = (entry) => {
      const [node] = entry;

      if (!Editor.isEditor(node) || node.children.length > 0) {
        return normalizeNode(entry);
      }

      Transforms.insertNodes(editor, emptyNode, { at: [0] });
    };

    return e;
  }, []);

  useEffect(() => {
    YjsEditor.connect(editor);
    return () => YjsEditor.disconnect(editor);
  }, [editor]);

  return (
    <div className={styles.container}>
      <div className={styles.editorContainer}>
        <Slate editor={editor} initialValue={[emptyNode]}>
          <Editable className={styles.editor} placeholder="Start typing here…" />
        </Slate>
      </div>
    </div>
  );
}

----------------------------------------

TITLE: Setting Initial Storage in Liveblocks
DESCRIPTION: Demonstrates how to initialize permanent data storage when first entering a Liveblocks room. Initial storage uses conflict-free data structures like LiveList and LiveObject to store application data.

LANGUAGE: ts
CODE:
import { LiveList, LiveObject } from "@liveblocks/client";

const { room, leave } = client.enterRoom("my-room-id", {
  // +++
  initialStorage: {
    title: "Untitled",
    shapes: new LiveList([
      new LiveObject({ type: "rectangle", color: "yellow" }),
    ]),
  },
  // +++

  // Other options
  // ...
});

----------------------------------------

TITLE: Joining a Liveblocks Room with ClientSideSuspense
DESCRIPTION: React component that sets up a Liveblocks room with a loading indicator using ClientSideSuspense. This allows for proper loading states while connecting to the room.

LANGUAGE: tsx
CODE:
"use client";

import {
  LiveblocksProvider,
  RoomProvider,
  ClientSideSuspense,
} from "@liveblocks/react/suspense";
import { Room } from "./Room";

export default function App() {
  return (
    <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>      <RoomProvider id="my-room">
        <ClientSideSuspense fallback={<div>Loading…</div>}>
          <Room />
        </ClientSideSuspense>
      </RoomProvider>
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Filtering and Paginating Rooms with Liveblocks.getRooms
DESCRIPTION: Shows how to apply various filters when retrieving rooms, including limiting results, filtering by group IDs, user IDs, and using advanced query options with pagination support.

LANGUAGE: typescript
CODE:
const {
  data: rooms,
  nextCursor,
  nextPage,
} = await liveblocks.getRooms({
  // Optional, the amount of rooms to load, between 1 and 100, defaults to 20
  limit: 20,

  // Optional, filter for rooms that allow entry to group ID(s) in `groupsAccesses`
  groupIds: ["engineering", "design"],

  // Optional, filter for rooms that allow entry to a user's ID in `usersAccesses`
  userId: "my-user-id",

  // Optional, use advanced filtering
  query: {
    // Optional, filter for rooms with an ID that starts with specific string
    roomId: {
      startsWith: "liveblocks:",
    },
    // Optional, filter for rooms with custom metadata in `metadata`
    metadata: {
      roomType: "whiteboard",
    },
  },

  // Optional, cursor used for pagination, use `nextCursor` from the previous page's response
  startingAfter: "L3YyL3Jvb21z...",
});

----------------------------------------

TITLE: Basic TypeScript Configuration for Liveblocks
DESCRIPTION: Shows how to define a global Liveblocks interface in TypeScript to enable type checking for Liveblocks data. This approach is recommended for setting up type definitions for presence, storage, and other Liveblocks features.

LANGUAGE: ts
CODE:
declare global {
  interface Liveblocks {
    // Each user's Presence, for useMyPresence, useOthers, etc.
    Presence: {};

    // The Storage tree for the room, for useMutation, useStorage, etc.
    Storage: {};

    UserMeta: {
      id: string;
      // Custom user info set when authenticating with a secret key
      info: {};
    };

    // Custom events, for useBroadcastEvent, useEventListener
    RoomEvent: {};

    // Custom metadata set on threads, for useThreads, useCreateThread, etc.
    ThreadMetadata: {};

    // Custom room info set with resolveRoomsInfo, for useRoomInfo
    RoomInfo: {};

    // Custom activities data for custom notification kinds
    ActivitiesData: {};
  }
}

// Necessary if you have no imports/exports
export {};

----------------------------------------

TITLE: Adding a Floating Comments Composer to Lexical Editor with TypeScript
DESCRIPTION: This snippet shows how to add a floating comments composer to the Lexical editor. The FloatingComposer component enables users to create comments and annotations directly in the editor interface.

LANGUAGE: tsx
CODE:
<LexicalComposer initialConfig={initialConfig}>
  <LiveblocksPlugin>
    <FloatingComposer />
  </LiveblocksPlugin>
</LexicalComposer>

----------------------------------------

TITLE: Configuring preventUnsavedChanges Option in LiveblocksProvider
DESCRIPTION: Example of using preventUnsavedChanges option in React's LiveblocksProvider to prevent browser tabs from being closed while local changes are not yet synchronized.

LANGUAGE: tsx
CODE:
<LiveblocksProvider preventUnsavedChanges />

----------------------------------------

TITLE: Configuring LiveblocksProvider with Auth Endpoint in React
DESCRIPTION: Example showing how to set up LiveblocksProvider with an authentication endpoint. This is the recommended approach for production applications for secure access control.

LANGUAGE: tsx
CODE:
import { LiveblocksProvider } from "@liveblocks/react/suspense";

function App() {
  return (
    <LiveblocksProvider authEndpoint="/api/liveblocks-auth">
      {/* children */}
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Creating a Text Formatting Toolbar for Tiptap
DESCRIPTION: A basic text formatting toolbar component for Tiptap that provides buttons for bold, italic, and strikethrough formatting. Each button checks the editor state to determine if the formatting can be applied or is currently active.

LANGUAGE: tsx
CODE:
import { Editor } from "@tiptap/react";
import styles from "./Toolbar.module.css";

type Props = {
  editor: Editor | null;
};

export function Toolbar({ editor }: Props) {
  if (!editor) {
    return null;
  }

  return (
    <div className={styles.toolbar}>
      <button
        className={styles.button}
        onClick={() => editor.chain().focus().toggleBold().run()}
        disabled={!editor.can().chain().focus().toggleBold().run()}
        data-active={editor.isActive("bold") ? "is-active" : undefined}
        aria-label="bold"
      >
        B
      </button>
      <button
        className={styles.button}
        onClick={() => editor.chain().focus().toggleItalic().run()}
        disabled={!editor.can().chain().focus().toggleItalic().run()}
        data-active={editor.isActive("italic") ? "is-active" : undefined}
        aria-label="italic"
      >
        i
      </button>
      <button
        className={styles.button}
        onClick={() => editor.chain().focus().toggleStrike().run()}
        disabled={!editor.can().chain().focus().toggleStrike().run()}
        data-active={editor.isActive("strike") ? "is-active" : undefined}
        aria-label="strikethrough"
      >
        S
      </button>
    </div>
  );
}

----------------------------------------

TITLE: Accessing User Data in React Components
DESCRIPTION: Shows how to access user information in React components using the useUser hook. This allows components to display user data that was provided through the resolveUsers function in the Liveblocks client.

LANGUAGE: tsx
CODE:
import { useUser } from "@liveblocks/react/suspense";

function Component() {
  const user = useUser("marc@example.com");

  // { name: "Marc", avatar: "https://...", ... }
  console.log(user);
}

----------------------------------------

TITLE: Using useOthers Hook with TypeScript in Liveblocks React
DESCRIPTION: The useOthers hook extracts data from the list of other users in the same Room and subscribes to updates on the selected data. It accepts a selector function that helps optimize rendering by only updating when specifically selected data changes.

LANGUAGE: tsx
CODE:
// ✅ Rerenders only if the number of users changes
const numOthers = useOthers((others) => others.length);

// ✅ Rerenders only if someone starts or stops typing
const isSomeoneTyping = useOthers((others) =>
  others.some((other) => other.presence.isTyping)
);

// ✅ Rerenders only if actively typing users are updated
const typingUsers = useOthers(
  (others) => others.filter((other) => other.presence.isTyping),
  shallow // 👈
);

----------------------------------------

TITLE: Initializing Storage with LiveObject in RoomProvider
DESCRIPTION: Creates initial storage data using LiveObject when setting up the RoomProvider component in App.tsx. This instantiates the person object with initial values.

LANGUAGE: tsx
CODE:
<RoomProvider
  id={roomId}
  initialStorage={{
    person: new LiveObject({ name: "Marie", age: 30 }),
  }}
>

----------------------------------------

TITLE: Setting Up Collaborative Monaco Code Editor with Liveblocks and Yjs
DESCRIPTION: Implements a collaborative Monaco code editor using Liveblocks for real-time collaboration and Yjs as the CRDT. This code initializes the Liveblocks client, creates a room, sets up the Yjs document, initializes the Monaco editor, and binds them together for real-time collaboration.

LANGUAGE: javascript
CODE:
import { createClient } from "@liveblocks/client";
import { getYjsProviderForRoom } from "@liveblocks/yjs";
import * as Y from "yjs";
import * as monaco from "monaco-editor";
import { MonacoBinding } from "y-monaco";

// Set up Liveblocks client
const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

// Enter a multiplayer room
const { room, leave } = client.enterRoom("my-room");

// Set up Yjs document, shared text, and Liveblocks Yjs provider
const yProvider = getYjsProviderForRoom(room);
const yDoc = yProvider.getYDoc();
const yText = yDoc.getText("monaco");

// Set up the Monaco editor
const parent = document.querySelector("#editor");
const editor = monaco.editor.create(parent, {
  value: "",
  language: "javascript"
})

// Attach Yjs to Monaco
const monacoBinding = new MonacoBinding(
  yText,
  editorRef.getModel(),
  new Set([editor]),
  yProvider.awareness
);

----------------------------------------

TITLE: Updating App to Show Shape Selection States
DESCRIPTION: Modifies the App and Rectangle components to visually indicate which shapes are selected by the current user (blue border) and other users (green border). Uses Liveblocks' others data to track remote users' selections.

LANGUAGE: tsx
CODE:
import { useEffect } from "react";
import useStore from "./store";

import "./App.css";

export default function App() {
  const shapes = useStore((state) => state.shapes);
  const insertRectangle = useStore((state) => state.insertRectangle);
  const others = useStore((state) => state.liveblocks.others);
  const selectedShape = useStore((state) => state.selectedShape);

  /* ... */

  return (
    <>
      <div className="canvas">
        {Object.entries(shapes).map(([shapeId, shape]) => {
          let selectionColor = "transparent";

          if (selectedShape === shapeId) {
            selectionColor = "blue";
          } else if (
            others.some((user) => user.presence?.selectedShape === shapeId)
          ) {
            selectionColor = "green";
          }

          return (
            <Rectangle
              key={shapeId}
              id={shapeId}
              shape={shape}
              selectionColor={selectionColor}
            />
          );
        })}
      </div>
      <div className="toolbar">
        <button onClick={insertRectangle}>Rectangle</button>
      </div>
    </>
  );
}

const Rectangle = (props: {
  id: string;
  shape: Shape;
  selectionColor: string;
}) => {
  const { id, shape, selectionColor } = props;
  const onShapePointerDown = useStore((state) => state.onShapePointerDown);

  return (
    <div
      className="rectangle"
      style={{
        transform: `translate(${shape.x}px, ${shape.y}px)`,
        backgroundColor: shape.fill ? shape.fill : "#CCC",
        borderColor: selectionColor,
      }}
      onPointerDown={(e) => {
        e.stopPropagation();
        onShapePointerDown(id);
      }}
    ></div>
  );
};

----------------------------------------

TITLE: Creating a Customized Toolbar for Tiptap Editor
DESCRIPTION: Demonstrates how to build a custom toolbar by composing different toolbar sections like BlockSelector, SectionInline, and SectionCollaboration.

LANGUAGE: tsx
CODE:
function CustomToolbar({ editor }: { editor: Editor | null }) {
  return (
    <Toolbar editor={editor}>
      // +++
      <Toolbar.BlockSelector />
      <Toolbar.SectionInline />
      <Toolbar.Separator />
      <Toolbar.SectionCollaboration />
      // +++
    </Toolbar>
  );
}

----------------------------------------

TITLE: Using RoomProvider Component in React with Liveblocks
DESCRIPTION: Basic implementation of RoomProvider that makes a Room available in the component hierarchy. It joins the room on mount and leaves on unmount, allowing collaboration within the specified room ID.

LANGUAGE: tsx
CODE:
import { RoomProvider } from "@liveblocks/react/suspense";

function App() {
  return <RoomProvider id="my-room-id">{/* children */}</RoomProvider>;
}

----------------------------------------

TITLE: Subscribing to Storage Status Changes in Liveblocks Room (TypeScript)
DESCRIPTION: Demonstrates how to track the synchronization status of Storage with Liveblocks servers. The callback receives a status parameter that can be 'not-loaded', 'loading', 'synchronizing', or 'synchronized'.

LANGUAGE: typescript
CODE:
const unsubscribe = room.subscribe("storage-status", (status) => {
  switch (status) {
    case "not-loaded":
      // Storage has not been loaded yet
      break;
    case "loading":
      // Storage is currently loading
      break;
    case "synchronizing":
      // Local Storage changes are being synchronized
      break;
    case "synchronized":
      // Local Storage changes have been synchronized
      break;
  }
});

----------------------------------------

TITLE: CSS Styling for Whiteboard Canvas and Shapes
DESCRIPTION: CSS styles for the whiteboard application, including the canvas, rectangle shapes, loading state, and toolbar. Defines styling for positioning, appearance, and interactions with the whiteboard elements.

LANGUAGE: css
CODE:
body {
  background-color: #eeeeee;
}

.loading {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100vh;
  width: 100vw;
}

.canvas {
  background-color: #eeeeee;
  touch-action: none;
  width: 100vw;
  height: 100vh;
}

.rectangle {
  position: absolute;
  /* transition: all 0.1s ease; */
  stroke-width: 1;
  border-style: solid;
  border-width: 2px;
  height: 100px;
  width: 100px;
}

.toolbar {
  position: fixed;
  top: 12px;
  left: 50%;
  transform: translateX(-50%);
  padding: 4px;
  border-radius: 8px;
  box-shadow:
    0px 2px 4px rgba(0, 0, 0, 0.1),
    0px 0px 0px 1px rgba(0, 0, 0, 0.05);
  display: flex;
  background-color: #ffffff;
  user-select: none;
}

.toolbar button {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 4px 8px;
  border-radius: 4px;
  background-color: #f8f8f8;
  color: #181818;
  border: none;
  box-shadow:
    0px 2px 4px rgba(0, 0, 0, 0.1),
    0px 0px 0px 1px rgba(0, 0, 0, 0.05);
  margin: 4px;
  font-weight: 500;
  font-size: 12px;
}

.toolbar button:hover,
.toolbar button:focus {
  background-color: #ffffff;
}

.toolbar button:active {
  background-color: #eeeeee;
}

----------------------------------------

TITLE: Joining a Liveblocks Room with ClientSideSuspense
DESCRIPTION: Extended React component that adds ClientSideSuspense for handling loading states while the application connects to the Liveblocks room and loads collaborative components.

LANGUAGE: tsx
CODE:
"use client";

import {
  LiveblocksProvider,
  RoomProvider,
  ClientSideSuspense,
} from "@liveblocks/react/suspense";
import { Editor } from "./Editor";

export default function App() {
  return (
    <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>\n      <RoomProvider id="my-room">
        <ClientSideSuspense fallback={<div>Loading…</div>}>
          <Editor />
        </ClientSideSuspense>
      </RoomProvider>
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Sending Emails to Users with Liveblocks Comment Notifications
DESCRIPTION: This code demonstrates how to send an email containing comment notifications to the appropriate user. It retrieves the user's email address and sends the formatted comment HTML.

LANGUAGE: ts
CODE:
const emailAddress = __getUserEmail__(userId);

// Send email to the user that received the inbox notification
__sendEmail__({
  from: "hello@my-company.com",
  to: emailAddress,
  title: "Unread comment",
  react: `
    <h1>Unread comment</h1>
    ${commentHtml}
  `,
});

----------------------------------------

TITLE: Creating a Liveblocks Room Component in Next.js
DESCRIPTION: Setting up a Liveblocks room with LiveblocksProvider, RoomProvider, and ClientSideSuspense for a Next.js app. This file creates a virtual space where multiple users can collaborate in realtime.

LANGUAGE: tsx
CODE:
"use client";

import { ReactNode } from "react";
import {
  LiveblocksProvider,
  RoomProvider,
  ClientSideSuspense,
} from "@liveblocks/react/suspense";

export function Room({ children }: { children: ReactNode }) {
  return (
    <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>
      <RoomProvider id="my-room">
        <ClientSideSuspense fallback={<div>Loading…</div>}>
          {children}
        </ClientSideSuspense>
      </RoomProvider>
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Complete AnchoredThreads Integration with Lexical Editor
DESCRIPTION: Comprehensive example of implementing AnchoredThreads in a Lexical editor, showing the necessary imports, configuration, and integration with useThreads hook to retrieve thread data that will be displayed alongside the editor.

LANGUAGE: tsx
CODE:
import { LexicalComposer } from "@lexical/react/LexicalComposer";
import { RichTextPlugin } from "@lexical/react/LexicalRichTextPlugin";
import { ContentEditable } from "@lexical/react/LexicalContentEditable";
import { LexicalErrorBoundary } from "@lexical/react/LexicalErrorBoundary";
import { useThreads } from "@liveblocks/react/suspense";
import {
  liveblocksConfig,
  LiveblocksPlugin,
  FloatingComposer,
  // +++
  AnchoredThreads,
  // +++
} from "@liveblocks/react-lexical";

const initialConfig = liveblocksConfig({
  namespace: "MyEditor",
  theme: {},
  nodes: [],
  onError: (err) => console.error(err),
});

function Editor() {
  // +++
  const { threads } = useThreads();
  // +++

  return (
    <LexicalComposer initialConfig={initialConfig}>
      <LiveblocksPlugin>
        <FloatingComposer />
        // +++
        <AnchoredThreads threads={threads} style={{ width: "350px" }} />
        // +++
      </LiveblocksPlugin>
      <RichTextPlugin
        contentEditable={<ContentEditable />}
        placeholder={<div>Enter some text...</div>}
        ErrorBoundary={LexicalErrorBoundary}
      />
    </LexicalComposer>
  );
}

----------------------------------------

TITLE: Setting Initial Presence in Liveblocks
DESCRIPTION: Shows how to set the initial presence values when entering a Liveblocks room. Presence is used for temporary user-based values like cursor position or selection that are reset when users disconnect.

LANGUAGE: ts
CODE:
const { room, leave } = client.enterRoom("my-room-id", {
  // +++
  initialPresence: {
    cursor: null,
    colors: ["red", "purple"],
    selection: {
      id: 72426,
    },
  },
  // +++

  // Other options
  // ...
});

----------------------------------------

TITLE: Adding Live Cursors to Quill Editor
DESCRIPTION: Enhances the collaborative Quill editor with live cursors functionality by registering the cursors module and synchronizing user information through Liveblocks awareness.

LANGUAGE: tsx
CODE:
import { useSelf } from "../liveblocks.config.ts";
// ...

Quill.register("modules/cursors", QuillCursors);

// ...

function QuillEditor({ yText, provider }: EditorProps) {
  // Add user info to cursors from Liveblocks authentication endpoint
  const userInfo = useSelf((me) => me.info);
  useEffect(() => {
    const { name, color } = userInfo;
    provider.awareness.setLocalStateField("user", {
      name,
      color,
    });
  }, [userInfo]);

  // ...

  return (
    <div className={styles.container}>
      <div className={styles.editorContainer}>
        <ReactQuill
          className={styles.editor}
          placeholder="Start typing here…"
          ref={reactQuillRef}
          theme="snow"
          modules={{
            cursors: true,
            toolbar: false,
            history: {
              // Local undo shouldn't undo changes from remote users
              userOnly: true,
            },
          }}
        />
      </div>
    </div>
  );
}

----------------------------------------

TITLE: Server-side Text Editor Manipulation with TypeScript
DESCRIPTION: This code demonstrates how to interact with the Lexical document from the server using withLexicalDocument. It shows how to retrieve text content and make real-time updates that will be visible to all connected users, enabling AI agent integration.

LANGUAGE: tsx
CODE:
await withLexicalDocument(
  { roomId: "my-room-id", client: liveblocks },
  async (doc) => {
    // Get editor content
    const textContent = doc.getTextContent();

    await doc.update(async () => {
      // Make real-time updates
      // ...
    });
  }
);

----------------------------------------

TITLE: Implementing Live Avatars with Liveblocks Presence Hooks
DESCRIPTION: React component that displays avatars for all users currently in the editor using Liveblocks presence hooks. The component shows both the current user and other active users, with tooltips displaying their names.

LANGUAGE: tsx
CODE:
import { useOthers, useSelf } from "@/liveblocks.config";
import styles from "./Avatars.module.css";

export function Avatars() {
  const users = useOthers();
  const currentUser = useSelf();

  return (
    <div className={styles.avatars}>
      {users.map(({ connectionId, info }) => {
        return (
          <Avatar key={connectionId} picture={info.picture} name={info.name} />
        );
      })}

      {currentUser && (
        <div className="relative ml-8 first:ml-0">
          <Avatar
            picture={currentUser.info.picture}
            name={currentUser.info.name}
          />
        </div>
      )}
    </div>
  );
}

export function Avatar({ picture, name }: { picture: string; name: string }) {
  return (
    <div className={styles.avatar} data-tooltip={name}>
      <img
        src={picture}
        className={styles.avatar_picture}
        data-tooltip={name}
      />
    </div>
  );
}

----------------------------------------

TITLE: Installing Liveblocks and Tiptap Packages
DESCRIPTION: Command to install all required dependencies for implementing a collaborative text editor with Liveblocks and Tiptap. Includes client libraries, React integration, UI components, and the Tiptap editor core with its starter kit.

LANGUAGE: bash
CODE:
npm install @liveblocks/client @liveblocks/react @liveblocks/react-ui @liveblocks/react-tiptap @tiptap/react @tiptap/starter-kit

----------------------------------------

TITLE: Adding ClientSideSuspense for Loading States in Liveblocks
DESCRIPTION: Extended React component setup that adds ClientSideSuspense for handling loading states when joining a Liveblocks room, providing a better user experience while connecting.

LANGUAGE: tsx
CODE:
"use client";

import {
  LiveblocksProvider,
  RoomProvider,
  ClientSideSuspense,
} from "@liveblocks/react/suspense";
import { CollaborativeEditor } from "./CollaborativeEditor";

export default function App() {
  return (
    <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>
      <RoomProvider id="my-room">
        <ClientSideSuspense fallback={<div>Loading…</div>}>
          <CollaborativeEditor />
        </ClientSideSuspense>
      </RoomProvider>
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Implementing a Collaborative Slate Editor with Yjs and Liveblocks
DESCRIPTION: Creates a collaborative text editor component using Slate, integrating with Yjs for document synchronization and Liveblocks for real-time collaboration.

LANGUAGE: tsx
CODE:
import { LiveblocksYjsProvider } from "@liveblocks/yjs";
import { useEffect, useMemo, useState } from "react";
import { createEditor, Editor, Transforms } from "slate";
import { Editable, Slate, withReact } from "slate-react";
import { withYjs, YjsEditor } from "@slate-yjs/core";
import * as Y from "yjs";
import { LiveblocksProviderType, useRoom } from "../liveblocks.config";
import styles from "./Editor.module.css";

export default function CollaborativeEditor() {
  const room = useRoom();
  const [connected, setConnected] = useState(false);
  const [sharedType, setSharedType] = useState<Y.XmlText>();
  const [provider, setProvider] = useState<LiveblocksProviderType>();

  // Set up Liveblocks Yjs provider
  useEffect(() => {
    const yDoc = new Y.Doc();
    const yProvider = new LiveblocksYjsProvider(room, yDoc);
    const sharedDoc = yDoc.get("slate", Y.XmlText) as Y.XmlText;
    yProvider.on("sync", setConnected);

    setSharedType(sharedDoc);
    setProvider(yProvider);

    return () => {
      yDoc?.destroy();
      yProvider?.off("sync", setConnected);
      yProvider?.destroy();
    };
  }, [room]);

  if (!connected || !sharedType || !provider) {
    return <div>Loading…</div>;
  }

  return <SlateEditor sharedType={sharedType} />;
}

const emptyNode = {
  children: [{ text: "" }],
};

function SlateEditor({ sharedType }: { sharedType: Y.XmlText }) {
  // Set up editor with plugins
  const editor = useMemo(() => {
    const e = withReact(withYjs(createEditor(), sharedType));

    // Ensure editor always has at least 1 valid child
    const { normalizeNode } = e;
    e.normalizeNode = (entry) => {
      const [node] = entry;

      if (!Editor.isEditor(node) || node.children.length > 0) {
        return normalizeNode(entry);
      }

      Transforms.insertNodes(editor, emptyNode, { at: [0] });
    };

    return e;
  }, [sharedType]);

  useEffect(() => {
    YjsEditor.connect(editor);
    return () => YjsEditor.disconnect(editor);
  }, [editor]);

  return (
    <div className={styles.container}>
      <div className={styles.editorContainer}>
        <Slate editor={editor} initialValue={[emptyNode]}>
          <Editable
            className={styles.editor}
            placeholder="Start typing here…"
          />
        </Slate>
      </div>
    </div>
  );
}

----------------------------------------

TITLE: Comparing Old and New TypeScript Patterns in Liveblocks 2.0
DESCRIPTION: Demonstrates the transition from the previous pattern using createRoomContext() to the new global type augmentation pattern in Liveblocks 2.0. The new approach simplifies type definitions and imports.

LANGUAGE: tsx
CODE:
// ❌ This pattern is no longer recommended unless you need multiple room types
export const {
  suspense: { RoomProvider, useRoom, useThread },
} = createRoomContext<
  MyPresence,
  MyStorage,
  MyUserMeta,
  MyRoomEvent,
  MyThreadMetadata
>(client);

// ✅ After
declare global {
  // These custom types are all optional, just define the ones you want/need
  interface Liveblocks {
    Presence: MyPresence;
    Storage: MyStorage;
    UserMeta: MyUserMeta;
    RoomEvent: MyRoomEvent;
    ThreadMetadata: MyThreadMetadata;
  }
}

----------------------------------------

TITLE: Integrating the Collaborative Editor into a Next.js Page
DESCRIPTION: Next.js page component that incorporates the collaborative editor inside a Liveblocks Room. This connects all the pieces to create a functional collaborative editing experience.

LANGUAGE: tsx
CODE:
import { Room } from "./Room";
import CollaborativeEditor from "@/components/Editor";

export default function Page() {
  return (
    <Room>
      <CollaborativeEditor />
    </Room>
  );
}

----------------------------------------

TITLE: Using useMutation for Storage Modifications
DESCRIPTION: Shows how to use the useMutation hook to create callbacks that modify the shared storage state, with examples of both direct mutation and parameterized mutations.

LANGUAGE: tsx
CODE:
import { useMutation } from "@liveblocks/react/suspense";

const fillWithRed = useMutation(
  // Mutation context is passed as the first argument
  ({ storage, setMyPresence }) => {
    // Mutate Storage
    storage.get("shapes").get("circle1").set("fill", "red");
    //                                   ^^^

    // ...or Presence
    setMyPresence({ lastUsedColor: "red" });
  },
  []
);

// JSX
return <button onClick={fillWithRed} />;

LANGUAGE: tsx
CODE:
// Local state maintained outside Liveblocks
const [currentColor, setCurrentColor] = useState("red");

const fillWithCurrentColor = useMutation(
  ({ storage, setMyPresence }) => {
    storage.get("shapes").get("circle1").set("fill", currentColor);
    setMyPresence({ lastUsedColor: currentColor });
  },
  // +++
  [currentColor] // Works just like it would in useCallback
  // +++
);

// JSX
return <button onClick={fillWithCurrentColor} />;

LANGUAGE: tsx
CODE:
const fill = useMutation(
  // +++
  // Note the second argument
  ({ storage, setMyPresence }, color: string) => {
    // +++
    storage.get("shapes").get("circle1").set("fill", color);
    setMyPresence({ lastUsedColor: color });
  },
  []
);

// JSX
// +++
return <button onClick={() => fill("red")} />;
//                            ^^^^^^^^^^^ Now fill takes a color argument
// +++

----------------------------------------

TITLE: Fetching Authentication Token from API Endpoint in LiveblocksProvider
DESCRIPTION: A complete example of fetching an authentication token from a custom API endpoint within the LiveblocksProvider authEndpoint callback. It demonstrates how to make a POST request with custom headers and pass the room parameter to the endpoint.

LANGUAGE: tsx
CODE:
import { LiveblocksProvider } from "@liveblocks/react/suspense";

function App() {
  return (
    <LiveblocksProvider
      authEndpoint={async (room) => {
        const response = await fetch("/api/liveblocks-auth", {
          method: "POST",
          headers: {
            Authentication: "<your own headers here>",
            "Content-Type": "application/json",
          },
          // Don't forget to pass `room` down. Note that it
          // can be undefined when using Notifications.
          body: JSON.stringify({ room }),
        });
        return await response.json();
      }}
    >
      {/* children */}
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Mutate Storage with Asynchronous Callback in TypeScript
DESCRIPTION: Modifies Storage contents from the server using an asynchronous callback. This allows for creating a stream of mutations that happen over time, with some changes occurring immediately and others after asynchronous operations complete.

LANGUAGE: typescript
CODE:
// Mutate a single room
await liveblocks.mutateStorage(
  "my-room-id",

  async ({ root }) => {
    // These changes happen immediately
    const animals = root.get("animals");
    animals.clear();
    animals.push("Thinking...");

    await thinkForAWhile();

    // These changes happen after `await` has run
    animals.clear();
    animals.push("🐶");
    animals.push("🦘");
  }
);

----------------------------------------

TITLE: Implementing a Collaborative Monaco Editor with Yjs Integration
DESCRIPTION: Complete implementation of a collaborative code editor component using Monaco Editor, Yjs, and Liveblocks. This component sets up the editor, connects it to Yjs, and establishes real-time collaboration features including cursors and text synchronization.

LANGUAGE: tsx
CODE:
"use client";

import * as Y from "yjs";
import { getYjsProviderForRoom } from "@liveblocks/yjs";
import { useRoom } from "@/liveblocks.config";
import { useCallback, useEffect, useState } from "react";
import { Editor } from "@monaco-editor/react";
import { editor } from "monaco-editor";
import { MonacoBinding } from "y-monaco";
import { Awareness } from "y-protocols/awareness";

// Collaborative text editor with simple rich text, live cursors, and live avatars
export function CollaborativeEditor() {
  const [editorRef, setEditorRef] = useState<editor.IStandaloneCodeEditor>();
  const room = useRoom();
  const yProvider = getYjsProviderForRoom(room);

  // Set up Liveblocks Yjs provider and attach Monaco editor
  useEffect(() => {
    let binding: MonacoBinding;

    if (editorRef) {
      const yDoc = yProvider.getYDoc();
      const yText = yDoc.getText("monaco");

      // Attach Yjs to Monaco
      binding = new MonacoBinding(
        yText,
        editorRef.getModel() as editor.ITextModel,
        new Set([editorRef]),
        yProvider.awareness as Awareness
      );
    }

    return () => {
      binding?.destroy();
    };
  }, [editorRef, room]);

  const handleOnMount = useCallback((e: editor.IStandaloneCodeEditor) => {
    setEditorRef(e);
  }, []);

  return (
    <Editor
      onMount={handleOnMount}
      height="100vh"
      width="100hw"
      theme="vs-light"
      defaultLanguage="typescript"
      defaultValue=""
      options={{
        tabSize: 2,
      }}
    />
  );
}

----------------------------------------

TITLE: Setting Up Liveblocks Client with LiveblocksProvider and RoomProvider
DESCRIPTION: React component that initializes the Liveblocks client and creates a room connection. It uses LiveblocksProvider for client setup and RoomProvider to join a specific room.

LANGUAGE: tsx
CODE:
"use client";

import {
  LiveblocksProvider,
  RoomProvider,
} from "@liveblocks/react/suspense";
import { Room } from "./Room";

export default function App() {
  return (
    <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>      <RoomProvider id="my-room">
        {/* ... */}
      </RoomProvider>
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Fetching Yjs Document Data from Liveblocks using REST API in TypeScript
DESCRIPTION: Implementation of a webhook handler that verifies incoming webhook requests and retrieves the current Yjs document data from the Liveblocks REST API. It uses the WebhookHandler to verify requests and fetches document data when a 'ydocUpdated' event is received.

LANGUAGE: typescript
CODE:
import { WebhookHandler } from "@liveblocks/node";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When Yjs document data has been updated
  if (event.type === "ydocUpdated") {
    const { roomId } = event.data;

    // Get Yjs data from Liveblocks REST API
    const url = `https://api.liveblocks.io/v2/rooms/${roomId}/ydoc`;
    const response = await fetch(url, {
      headers: { Authorization: `Bearer ${API_SECRET}` },
    });

    if (!response.ok) {
      return new Response("Problem accessing Liveblocks REST APIs", {
        status: 500,
      });
    }

    // Your JSON Yjs document data as a string
    const yDocData = await response.text();

    // Update database
    // ...
  }

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Implementing Live Cursors with Yjs Awareness in React
DESCRIPTION: This component connects Liveblocks user information with Yjs awareness to display real-time cursors in a code editor. It dynamically generates CSS styles for each connected user to visualize their cursor position and name.

LANGUAGE: tsx
CODE:
import { useEffect, useMemo, useState } from "react";
import {
  AwarenessList,
  TypedLiveblocksProvider,
  UserAwareness,
  useSelf,
} from "@/liveblocks.config";

type Props = {
  yProvider: TypedLiveblocksProvider;
};

export function Cursors({ yProvider }: Props) {
  // Get user info from Liveblocks authentication endpoint
  const userInfo = useSelf((me) => me.info);

  const [awarenessUsers, setAwarenessUsers] = useState<AwarenessList>([]);

  useEffect(() => {
    // Add user info to Yjs awareness
    const localUser: UserAwareness["user"] = userInfo;
    yProvider.awareness.setLocalStateField("user", localUser);

    // On changes, update `awarenessUsers`
    function setUsers() {
      setAwarenessUsers([...yProvider.awareness.getStates()] as AwarenessList);
    }
    yProvider.awareness.on("change", setUsers);
    setUsers();

    return () => {
      yProvider.awareness.off("change", setUsers);
    };
  }, [yProvider]);

  // Insert awareness info into cursors with styles
  const styleSheet = useMemo(() => {
    let cursorStyles = "";

    for (const [clientId, client] of awarenessUsers) {
      if (client?.user) {
        cursorStyles += `
          .yRemoteSelection-${clientId},
          .yRemoteSelectionHead-${clientId}  {
            --user-color: ${client.user.color};
          }

          .yRemoteSelectionHead-${clientId}::after {
            content: "${client.user.name}";
          }
        `;
      }
    }

    return { __html: cursorStyles };
  }, [awarenessUsers]);

  return <style dangerouslySetInnerHTML={styleSheet} />;
}

----------------------------------------

TITLE: Implementing Rectangle Movement in Liveblocks Store
DESCRIPTION: Implementation of drag-and-drop functionality for rectangles by updating the store with new x and y coordinates when the user drags a selected shape. The code handles pointer events and updates the shape position accordingly.

LANGUAGE: typescript
CODE:
/* ... */

type State = {
  shapes: Record<string, Shape>;
  selectedShape: string | null;
  isDragging: boolean;
  insertRectangle: () => void;
  onShapePointerDown: (shapeId: string | null) => void;
  deleteShape: () => void;
  onCanvasPointerUp: () => void;
  onCanvasPointerMove: (e: React.PointerEvent) => void;
};

/* ... */

const useStore = create<WithLiveblocks<State>>()(
  liveblocks(
    (set, get) => ({
      shapes: {},
      selectedShape: null,
      isDragging: false,

      insertRectangle: () => {
        /* ... */
      },
      onShapePointerDown: (shapeId) => {
        set({ selectedShape: shapeId, isDragging: true });
      },
      deleteShape: () => {
        /* ... */
      },
      onCanvasPointerUp: () => {
        set({ isDragging: false });
      },
      onCanvasPointerMove: (e) => {
        e.preventDefault();

        const { isDragging, shapes, selectedShape } = get();
        if (!selectedShape) {
          /* Nothing todo */
          return;
        }

        const shape = shapes[selectedShape];

        if (shape && isDragging) {
          set({
            shapes: {
              ...shapes,
              [selectedShape]: {
                ...shape,
                x: e.clientX - 50,
                y: e.clientY - 50,
              },
            },
          });
        }
      },
    }),
    {
      client,
      storageMapping: { shapes: true },
      presenceMapping: { selectedShape: true },
    }
  )
);

export default useStore;

----------------------------------------

TITLE: Implementing a Collaborative Lexical Editor with Yjs and Liveblocks
DESCRIPTION: React component that sets up a collaborative text editor using Lexical, Yjs, and Liveblocks. It configures the Lexical editor and establishes real-time collaboration through LiveblocksYjsProvider.

LANGUAGE: tsx
CODE:
"use client";

import { LiveblocksYjsProvider } from "@liveblocks/yjs";
import * as Y from "yjs";
import { useRoom } from "@/liveblocks.config";
import styles from "./Editor.module.css";
import {
  $createParagraphNode,
  $createTextNode,
  $getRoot,
  LexicalEditor,
} from "lexical";
import { LexicalComposer } from "@lexical/react/LexicalComposer";
import { RichTextPlugin } from "@lexical/react/LexicalRichTextPlugin";
import { ContentEditable } from "@lexical/react/LexicalContentEditable";
import LexicalErrorBoundary from "@lexical/react/LexicalErrorBoundary";
import { CollaborationPlugin } from "@lexical/react/LexicalCollaborationPlugin";
import { Provider } from "@lexical/yjs";

// Set up editor config
const initialConfig = {
  // NOTE: This is critical for collaboration plugin to set editor state to null. It
  // would indicate that the editor should not try to set any default state
  // (not even empty one), and let collaboration plugin do it instead
  editorState: null,
  namespace: "Demo",
  nodes: [],
  onError: (error: unknown) => {
    throw error;
  },
};

// Define initial editor state
function initialEditorState(editor: LexicalEditor): void {
  const root = $getRoot();
  const paragraph = $createParagraphNode();
  const text = $createTextNode();
  paragraph.append(text);
  root.append(paragraph);
}

// Collaborative text editor with simple rich text
export default function Editor() {
  // Get Liveblocks room
  const room = useRoom();

  return (
    <div className={styles.container}>
      <LexicalComposer initialConfig={initialConfig}>
        <div className={styles.editorContainer}>
          <RichTextPlugin
            contentEditable={<ContentEditable className={styles.editor} />}
            placeholder={
              <p className={styles.placeholder}>Start typing here…</p>
            }
            ErrorBoundary={LexicalErrorBoundary}
          />
          <CollaborationPlugin
            id="yjs-plugin"
            providerFactory={(id, yjsDocMap) => {
              // Set up Liveblocks Yjs provider
              const doc = new Y.Doc();
              yjsDocMap.set(id, doc);
              const provider = new LiveblocksYjsProvider(room, doc) as Provider;
              return provider;
            }}
            initialEditorState={initialEditorState}
            shouldBootstrap={true}
          />
        </div>
      </LexicalComposer>
    </div>
  );
}

----------------------------------------

TITLE: Enhancing Zustand Store with Liveblocks Storage for Persisting To-Dos
DESCRIPTION: Extends the Zustand store to include todos array and CRUD operations (add, delete). Uses Liveblocks storageMapping to sync and persist todos across sessions, maintaining collaborative state even when users disconnect.

LANGUAGE: typescript
CODE:
/* ... */

type State = {
  draft: string;
  isTyping: boolean;
  todos: { text: string }[];
  setDraft: (draft: string) => void;
  addTodo: () => void;
  deleteTodo: (index: number) => void;
};

/* ... */

const useStore = create<WithLiveblocks<State>>()(
  liveblocks(
    (set) => ({
      draft: "",
      isTyping: false,
      todos: [],
      setDraft: (draft) => set({ draft, isTyping: draft !== "" }),
      addTodo: () =>
        set((state) => ({
          todos: state.todos.concat({ text: state.draft }),
          draft: "",
        })),
      deleteTodo: (index) =>
        set((state) => ({
          todos: state.todos.filter((_, i) => index !== i),
        })),
    }),
    {
      client,
      presenceMapping: { isTyping: true },
      storageMapping: { todos: true },
    }
  )
);

export default useStore;

----------------------------------------

TITLE: Using ClientSideSuspense for Server-Safe Rendering in React
DESCRIPTION: Shows how to use ClientSideSuspense as a replacement for Suspense to avoid server-side rendering issues with Liveblocks Suspense hooks, always rendering the fallback on the server.

LANGUAGE: tsx
CODE:
import { ClientSideSuspense } from "@liveblocks/react/suspense";

function Page() {
  return (
    <LiveblocksProvider authEndpoint="/api/liveblocks-auth">
      <RoomProvider id="my-room-id">
        <ClientSideSuspense fallback={<div>Loading…</div>}>
          <App />
        </ClientSideSuspense>
      </RoomProvider>
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Implementing Drag Functionality in Redux Store
DESCRIPTION: Updates the Redux store to handle rectangle movement by adding isDragging state and implementing pointer event handlers that update shape coordinates when dragging. This enables users to move rectangles across the canvas with real-time updates.

LANGUAGE: javascript
CODE:
/* ... */

const initialState = {
  shapes: {},
  selectedShape: null,
  isDragging: false,
};

const slice = createSlice({
  name: "state",
  initialState,
  reducers: {
    insertRectangle: (state) => {
      /* ... */
    },
    onShapePointerDown: (state, action) => {
      state.selectedShape = action.payload;
      state.isDragging = true;
    },
    deleteShape: (state) => {
      /* ... */
    },
    onCanvasPointerUp: (state) => {
      state.isDragging = false;
    },
    onCanvasPointerMove: (state, action) => {
      if (state.isDragging && state.selectedShape) {
        state.shapes[state.selectedShape].x = action.payload.x - 50;
        state.shapes[state.selectedShape].y = action.payload.y - 50;
      }
    },
  },
});

export const {
  insertRectangle,
  onShapePointerDown,
  deleteShape,
  onCanvasPointerUp,
  onCanvasPointerMove,
} = slice.actions;

export function makeStore() {
  return configureStore({
    reducer: slice.reducer,
    enhancers: [
      liveblocksEnhancer({
        client,
        presenceMapping: { selectedShape: true },
        storageMapping: { shapes: true },
      }),
    ],
  });
}

const store = makeStore();

export default store;

----------------------------------------

TITLE: Implementing a Collaborative Tiptap Editor with Yjs and Liveblocks
DESCRIPTION: React component that integrates Tiptap editor with Yjs and Liveblocks for real-time collaboration. It sets up the Yjs document, connects it to Liveblocks, and configures Tiptap with collaboration extensions.

LANGUAGE: tsx
CODE:
"use client";

import { useEditor, EditorContent } from "@tiptap/react";
import StarterKit from "@tiptap/starter-kit";
import Collaboration from "@tiptap/extension-collaboration";
import CollaborationCursor from "@tiptap/extension-collaboration-cursor";
import * as Y from "yjs";
import { LiveblocksYjsProvider } from "@liveblocks/yjs";
import { useRoom } from "@/liveblocks.config";
import { useEffect, useState } from "react";
import styles from "./CollaborativeEditor.module.css";

// Collaborative text editor with simple rich text, live cursors, and live avatars
export function CollaborativeEditor() {
  const room = useRoom();
  const [doc, setDoc] = useState<Y.Doc>();
  const [provider, setProvider] = useState<any>();

  // Set up Liveblocks Yjs provider
  useEffect(() => {
    const yDoc = new Y.Doc();
    const yProvider = new LiveblocksYjsProvider(room, yDoc);
    setDoc(yDoc);
    setProvider(yProvider);

    return () => {
      yDoc?.destroy();
      yProvider?.destroy();
    };
  }, [room]);

  if (!doc || !provider) {
    return null;
  }

  return <TiptapEditor doc={doc} provider={provider} />;
}

type EditorProps = {
  doc: Y.Doc;
  provider: any;
};

function TiptapEditor({ doc, provider }: EditorProps) {
  // Set up editor with plugins
  const editor = useEditor({
    editorProps: {
      attributes: {
        // Add styles to editor element
        class: styles.editor,
      },
    },
    extensions: [
      StarterKit.configure({
        // The Collaboration extension comes with its own history handling
        history: false,
      }),
      // Register the document with Tiptap
      Collaboration.configure({
        document: doc,
      }),
      // Attach provider and user info
      CollaborationCursor.configure({
        provider: provider,
      }),
    ],
  });

  return (
    <div className={styles.container}>
      <EditorContent editor={editor} className={styles.editorContainer} />
    </div>
  );
}

----------------------------------------

TITLE: Creating Liveblocks Client with preventUnsavedChanges Option
DESCRIPTION: Example of how to enable preventUnsavedChanges feature when creating a Liveblocks client to prevent browser tabs from being closed while local changes are not yet synchronized.

LANGUAGE: JavaScript
CODE:
createClient({ preventUnsavedChanges: true })

----------------------------------------

TITLE: Configuring Lost Connection Timeout
DESCRIPTION: Sets up a custom timeout period for detecting lost connections in Liveblocks. The lostConnectionTimeout value (in milliseconds) determines how quickly the client emits a lost-connection event when unable to reconnect.

LANGUAGE: typescript
CODE:
import { createClient } from "@liveblocks/client";

const client = createClient({
  lostConnectionTimeout: 5000,

  // Other options
  // ...
});

----------------------------------------

TITLE: Recommended Thread Components Usage with Responsive Design
DESCRIPTION: Recommended implementation using both FloatingThreads and AnchoredThreads together with responsive design. Shows how to filter out resolved threads and conditionally display different thread types based on screen size using Tailwind CSS.

LANGUAGE: tsx
CODE:
import { useThreads } from "@liveblocks/react/suspense";
import { AnchoredThreads, FloatingThreads } from "@liveblocks/react-lexical";

function ThreadOverlay() {
  const { threads } = useThreads({ query: { resolved: false } });

  return (
    <>
      <FloatingThreads
        threads={threads}
        className="w-[350px] block md:hidden"
      />
      <AnchoredThreads
        threads={threads}
        className="w-[350px] hidden sm:block"
      />
    </>
  );
}

----------------------------------------

TITLE: Complete Editor Implementation with FloatingThreads
DESCRIPTION: A more complete implementation of a text editor with Liveblocks comments integration. Shows how to use FloatingThreads along with other Lexical components, and how to fetch threads using the useThreads hook.

LANGUAGE: tsx
CODE:
import { LexicalComposer } from "@lexical/react/LexicalComposer";
import { RichTextPlugin } from "@lexical/react/LexicalRichTextPlugin";
import { ContentEditable } from "@lexical/react/LexicalContentEditable";
import { LexicalErrorBoundary } from "@lexical/react/LexicalErrorBoundary";
import { useThreads } from "@liveblocks/react/suspense";
import {
  liveblocksConfig,
  LiveblocksPlugin,
  FloatingComposer,
  // +++
  FloatingThreads,
  // +++
} from "@liveblocks/react-lexical";

const initialConfig = liveblocksConfig({
  namespace: "MyEditor",
  theme: {},
  nodes: [],
  onError: (err) => console.error(err),
});

function Editor() {
  // +++
  const { threads } = useThreads();
  // +++

  return (
    <LexicalComposer initialConfig={initialConfig}>
      <LiveblocksPlugin>
        <FloatingComposer />
        // +++
        <FloatingThreads threads={threads} style={{ width: "350px" }} />
        // +++
      </LiveblocksPlugin>
      <RichTextPlugin
        contentEditable={<ContentEditable />}
        placeholder={<div>Enter some text...</div>}
        ErrorBoundary={LexicalErrorBoundary}
      />
    </LexicalComposer>
  );
}

----------------------------------------

TITLE: Configuring User Resolution in Liveblocks
DESCRIPTION: Implementation of the resolveUsers function that maps user IDs to user data objects with properties like name, avatar, and color. This function is used by the useUser hook to retrieve user information.

LANGUAGE: ts
CODE:
async function resolveUsers({ userIds }) {
  // ["olivier@example.com"]
  console.log(userIds);

  return [
    {
      name: "Olivier",
      avatar: "https://example.com/olivier.png",
      color: "red",
    },
  ];
}

----------------------------------------

TITLE: Basic TypeScript Type Definitions for Liveblocks
DESCRIPTION: Setting up TypeScript type definitions for Liveblocks by extending the global Liveblocks interface. This provides type safety for Presence, Storage, UserMeta, and other Liveblocks features.

LANGUAGE: typescript
CODE:
declare global {
  interface Liveblocks {
    // Each user's Presence
    Presence: {};

    // The Storage tree for the room
    Storage: {};

    UserMeta: {
      id: string;
      // Custom user info set when authenticating with a secret key
      info: {};
    };

    // Custom events
    RoomEvent: {};

    // Custom metadata set on threads
    ThreadMetadata: {};

    // Custom room info set with resolveRoomsInfo
    RoomInfo: {};

    // Custom activities data for custom notification kinds
    ActivitiesData: {};
  }
}

// Necessary if you have no imports/exports
export {};

----------------------------------------

TITLE: Creating Nested Data Structures in Liveblocks Storage
DESCRIPTION: Shows how to instantiate and set up nested LiveObject, LiveList, and LiveMap structures, then add them to Storage. This example creates a person with a list of pets and adds them to a map of people.

LANGUAGE: typescript
CODE:
import { LiveObject, LiveList, LiveMap } from "@liveblocks/client";

const pets = new LiveList(["Cat", "Dog"]);
const person = new LiveObject({ name: "Alicia", pets });
const people = new LiveMap();
people.set("alicia", person);

const { root } = await room.getStorage();
root.set(people);

----------------------------------------

TITLE: Efficient Cursors Rendering Pattern with Liveblocks Hooks
DESCRIPTION: This pattern demonstrates how to efficiently render cursors with Liveblocks hooks. It uses a memoized parent component with useOthersConnectionIds and child components with useOther to ensure minimal rerenders.

LANGUAGE: tsx
CODE:
const Cursors =
  // +++
  // (1) Wrap parent component in a memo and make sure it takes no props
  React.memo(function () {
    const othersConnectionIds = useOthersConnectionIds(); // (2)
    // +++
    return (
      <>
        {othersConnectionIds.map((connectionId) => (
          <Cursor
            // +++
            key={connectionId} // (3)
            // +++
            connectionId={connectionId}
          />
        ))}
      </>
    );
  });

----------------------------------------

TITLE: Verifying Liveblocks Webhook Requests in Next.js
DESCRIPTION: Implementation of webhook verification using the @liveblocks/node package. This code verifies that incoming requests are legitimate webhook events from Liveblocks by checking the signature with a webhook secret key.

LANGUAGE: typescript
CODE:
import { WebhookHandler } from "@liveblocks/node";

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // Send notifications
  // ...

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Setting Up Collaborative Tiptap Editor in Svelte
DESCRIPTION: Svelte component implementation that sets up a collaborative text editor using Tiptap with Liveblocks and Yjs for real-time synchronization. The code initializes the client, connects to a room, configures the Yjs document and providers, and sets up the Tiptap editor with collaboration extensions.

LANGUAGE: html
CODE:
<script>
import { onMount, onDestroy } from "svelte";
import { createClient } from "@liveblocks/client";
import { getYjsProviderForRoom } from "@liveblocks/yjs";
import * as Y from "yjs";
import { Editor } from "@tiptap/core";
import StarterKit from "@tiptap/starter-kit";
import Collaboration from "@tiptap/extension-collaboration";
import CollaborationCursor from "@tiptap/extension-collaboration-cursor";

let element;

// Set up Liveblocks client
const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

onMount(() => {
  // Enter a multiplayer room
  const { room, leave } = client.enterRoom("my-room");

  // Set up Yjs document and Liveblocks Yjs provider
  const yProvider = getYjsProviderForRoom(room);
  const yDoc = yProvider.getYDoc();

  // Set up the Tiptap editor
  editor = new Editor({
    element,
    extensions: [
      StarterKit.configure({
        // The Collaboration extension comes with its own history handling
        history: false,
      }),
      // Register the Yjs document with Tiptap
      Collaboration.configure({
        document: yDoc,
      }),
      CollaborationCursor.configure({
        provider: yProvider,
      }),
    ],
    onTransaction: () => {
      // Force re-render so `editor.isActive` works as expected
      editor = editor
    },
  });

  return () => {
    editor.destroy();
    leave();
  };
});
</script>

<div bind:this={element}></div>

----------------------------------------

TITLE: Configuring Redux store with Liveblocks enhancer
DESCRIPTION: Sets up the Redux store with Liveblocks enhancer to enable real-time collaboration. This connects to the Liveblocks client using a public API key and initializes the store structure.

LANGUAGE: javascript
CODE:
import { createClient } from "@liveblocks/client";
import { liveblocksEnhancer } from "@liveblocks/redux";
import { configureStore, createSlice } from "@reduxjs/toolkit";

const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

const initialState = {};

const slice = createSlice({
  name: "state",
  initialState,
  reducers: {
    /* logic will be added here */
  },
});

export function makeStore() {
  return configureStore({
    reducer: slice.reducer,
    enhancers: [
      liveblocksEnhancer({
        client,
      }),
    ],
  });
}

const store = makeStore();

export default store;

----------------------------------------

TITLE: Creating Threaded Comments Component for Tiptap
DESCRIPTION: React component that implements threaded comments functionality using Liveblocks. Utilizes FloatingComposer for creating new threads, and AnchoredThreads and FloatingThreads for displaying threads on desktop and mobile devices.

LANGUAGE: tsx
CODE:
import { useThreads } from "@liveblocks/react/suspense";
import {
  AnchoredThreads,
  FloatingComposer,
  FloatingThreads,
} from "@liveblocks/react-tiptap";
import { Editor } from "@tiptap/react";

export function Threads({ editor }: { editor: Editor | null }) {
  const { threads } = useThreads({ query: { resolved: false } });

  return (
    <>
      <div className="anchored-threads">
        <AnchoredThreads editor={editor} threads={threads} />
      </div>
      <FloatingThreads
        editor={editor}
        threads={threads}
        className="floating-threads"
      />
      <FloatingComposer editor={editor} className="floating-composer" />
    </>
  );
}

----------------------------------------

TITLE: Integrating Avatars into the Tiptap Editor
DESCRIPTION: Code showing how to integrate the live avatars component into the editor. The Avatars component is placed in the editorHeader alongside the formatting toolbar.

LANGUAGE: tsx
CODE:
import { Avatars } from "./Avatars";
// ...

function TiptapEditor({ doc, provider }: EditorProps) {
  // ...

  return (
    <div className={styles.container}>
      <div className={styles.editorHeader}>
        <Toolbar editor={editor} />
        <Avatars />
      </div>
      <EditorContent editor={editor} className={styles.editorContainer} />
    </div>
  );
}

----------------------------------------

TITLE: Initializing Nested Data Structures in RoomProvider
DESCRIPTION: Demonstrates how to initialize complex nested data structures with LiveObject, LiveList, and LiveMap in the RoomProvider component.

LANGUAGE: tsx
CODE:
import { LiveObject, LiveList, LiveMap } from "@liveblocks/client";
import { RoomProvider } from "@liveblocks/react/suspense";

function App() {
  return (
    <RoomProvider
      id="my-room-name"
      initialStorage={{
        // +++
        people: new LiveMap([
          [
            "alicia",
            new LiveObject({
              name: "Alicia",
              pets: new LiveList(["Fido", "Felix"]),
            }),
          ],
        ]),
        // +++
      }}
    >
      {/* children */}
    </RoomProvider>
  );
}

----------------------------------------

TITLE: Implementing Collaborative CodeMirror Editor with Yjs and Liveblocks
DESCRIPTION: Complete implementation of a collaborative code editor component using CodeMirror, Yjs, and Liveblocks. Sets up real-time synchronization, undo/redo functionality, and editor state management.

LANGUAGE: tsx
CODE:
"use client";

import * as Y from "yjs";
import { yCollab } from "y-codemirror.next";
import { EditorView, basicSetup } from "codemirror";
import { EditorState } from "@codemirror/state";
import { javascript } from "@codemirror/lang-javascript";
import { useCallback, useEffect, useState } from "react";
import { LiveblocksYjsProvider } from "@liveblocks/yjs";
import { TypedLiveblocksProvider, useRoom } from "@/liveblocks.config";
import styles from "./CollaborativeEditor.module.css";

// Collaborative code editor with undo/redo, live cursors, and live avatars
export function CollaborativeEditor() {
  const room = useRoom();
  const [element, setElement] = useState<HTMLElement>();
  const [yUndoManager, setYUndoManager] = useState<Y.UndoManager>();

  const ref = useCallback((node: HTMLElement | null) => {
    if (!node) return;
    setElement(node);
  }, []);

  // Set up Liveblocks Yjs provider and attach CodeMirror editor
  useEffect(() => {
    let provider: TypedLiveblocksProvider;
    let ydoc: Y.Doc;
    let view: EditorView;

    if (!element || !room || !userInfo) {
      return;
    }

    // Create Yjs provider and document
    ydoc = new Y.Doc();
    provider = new LiveblocksYjsProvider(room as any, ydoc);
    const ytext = ydoc.getText("codemirror");
    const undoManager = new Y.UndoManager(ytext);
    setYUndoManager(undoManager);

    // Set up CodeMirror and extensions
    const state = EditorState.create({
      doc: ytext.toString(),
      extensions: [
        basicSetup,
        javascript(),
        yCollab(ytext, provider.awareness, { undoManager }),
      ],
    });

    // Attach CodeMirror to element
    view = new EditorView({
      state,
      parent: element,
    });

    return () => {
      ydoc?.destroy();
      provider?.destroy();
      view?.destroy();
    };
  }, [element, room, userInfo]);

  return (
    <div className={styles.container}>
      <div className={styles.editorContainer} ref={ref}></div>
    </div>
  );
}

----------------------------------------

TITLE: Creating ID Token for User Authentication in Liveblocks
DESCRIPTION: This snippet demonstrates how to create a JSON Web Token (JWT) using liveblocks.identifyUser() to verify a user's identity when connecting to a Liveblocks room.

LANGUAGE: typescript
CODE:
const { body, status } = await liveblocks.identifyUser({
  userId: "olivier@example.com",
});

// '{ token: "eyJga7..." }'
console.log(body);

----------------------------------------

TITLE: Initializing LiveblocksProvider with Basic Configuration in React
DESCRIPTION: Basic example of setting up the LiveblocksProvider component in a React application. This shows the minimal required props where you must specify either a publicApiKey or authEndpoint.

LANGUAGE: tsx
CODE:
import { LiveblocksProvider } from "@liveblocks/react/suspense";

function App() {
  return (
    <LiveblocksProvider
    // publicApiKey=""
    // authEndpoint="/api/liveblocks-auth"
    >
      {/* children */}
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Entering a Liveblocks Room with Redux Actions
DESCRIPTION: Dispatches the enterRoom action to join a specific room and start syncing it with Redux state.

LANGUAGE: js
CODE:
import { actions } from "@liveblocks/redux";
import { useDispatch, useSelector } from "react-redux";

const dispatch = useDispatch();

dispatch(actions.enterRoom("roomId"));

----------------------------------------

TITLE: Displaying Connected Users Count with useOthers in React
DESCRIPTION: This snippet demonstrates how to use the useOthers hook from Liveblocks to display the number of other users connected to the room. The component is wrapped in a RoomProvider to establish the connection to a Liveblocks room.

LANGUAGE: tsx
CODE:
import { RoomProvider, useOthers } from "@liveblocks/react/suspense";

function App() {
  const others = useOthers();

  return <div>There are {others.length} other users with you in the room.</div>;
}

function Index() {
  return (
    <RoomProvider id="my-room-id">
      <App />
    </RoomProvider>
  );
}

----------------------------------------

TITLE: Configuring LiveblocksProvider for Node.js environment
DESCRIPTION: Example showing how to pass WebSocket and fetch polyfills to the LiveblocksProvider when using Liveblocks in a Node.js environment.

LANGUAGE: tsx
CODE:
import { LiveblocksProvider } from "@liveblocks/react/suspense";
import fetch from "node-fetch";
import WebSocket from "ws";

function App() {
  return (
    <LiveblocksProvider
      polyfills={{
        fetch,
        WebSocket,
      }}

      // Other props
      // ...
    >
      {/* children */}
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Installing Live Cursors Example with Liveblocks CLI
DESCRIPTION: Command to set up the live cursors example project using the Liveblocks CLI. This automatically downloads the example and helps retrieve an API key from your Liveblocks account.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-live-cursors --api-key

----------------------------------------

TITLE: Styling the Collaborative Text Editor with CSS
DESCRIPTION: Provides CSS styles for positioning the editor and threads components. It includes responsive design considerations for both desktop and mobile views, ensuring a consistent experience across devices.

LANGUAGE: css
CODE:
html {
  font-family: Inter, sans-serif;
  background: #f9f9f9;
}

@media (prefers-color-scheme: dark) {
  html {
    background: #0c0c0c;
  }
}

.editor {
  position: absolute;
  inset: 0;
  max-width: 1024px;
  margin: 0 auto;
  padding: 48px 0;
}

.bn-editor {
  padding: 36px 52px;
  min-height: 100%;
}

/* For mobile */
.floating-threads {
  display: none;
}

/* For desktop */
.anchored-threads {
  display: block;
  max-width: 300px;
  width: 100%;
  position: absolute;
  right: 12px;
}

@media (max-width: 640px) {
  .floating-threads {
    display: block;
  }

  .anchored-threads {
    display: none;
  }
}

----------------------------------------

TITLE: Creating Thread Content with Links and Mentions in TypeScript
DESCRIPTION: Example of creating a CommentBody that includes advanced elements like user mentions and hyperlinks. This shows how to reference users and create clickable links in thread content.

LANGUAGE: ts
CODE:
const body: CommentBody = {
  version: 1,
  content: [
    // +++
    {
      type: "paragraph",
      children: [
        { type: "mention", id: "jody.hekla" },
        { text: " the " },
        { text: "Liveblocks", type: "link", url: "https://liveblocks.io" },
        { text: " website is cool!" },
      ],
    },
    // +++
  ],
};

----------------------------------------

TITLE: Implementing Document Version History with Liveblocks React and Tiptap
DESCRIPTION: This code snippet demonstrates how to create a document history component using Liveblocks hooks and components. It fetches version history with useHistoryVersions, displays a list of versions with HistoryVersionSummaryList, and shows previews of selected versions with HistoryVersionPreview.

LANGUAGE: tsx
CODE:
import {
  useHistoryVersions,
  HistoryVersionSummaryList,
} from "@liveblocks/react";
import { HistoryVersionPreview } from "@liveblocks/react-tiptap";

function DocumentHistory() {
  const [selectedVersionId, setSelectedVersionId] = useState<string>();
  const { versions, isLoading } = useHistoryVersions();
  const selectedVersion = useMemo(
    () => versions?.find((version) => version.id === selectedVersionId),
    [selectedVersionId, versions]
  );

  if (isLoading) {
    return <div>Loading version history...</div>;
  }

  return (
    <>
      <div>
        {selectedVersion ? (
          <HistoryVersionPreview
            version={selectedVersion}
            className="w-full h-full"
            onVersionRestore={onVersionRestore}
          />
        ) : (
          <div>No version selected</div>
        )}
      </div>

      <div>
        <HistoryVersionSummaryList>
          {versions?.map((version) => (
            <HistoryVersionSummary
              onClick={() => {
                setSelectedVersionId(version.id);
              }}
              key={version.id}
              version={version}
              selected={version.id === selectedVersionId}
            />
          ))}
        </HistoryVersionSummaryList>
      </div>
    </>
  );
}

----------------------------------------

TITLE: Checking Liveblocks Synchronization Status
DESCRIPTION: Demonstrates how to get the current synchronization status between the client and Liveblocks server using client.getSyncStatus(). Returns either "synchronizing" or "synchronized".

LANGUAGE: ts
CODE:
const syncStatus = client.getSyncStatus();
// "synchronizing" | "synchronized"

----------------------------------------

TITLE: Implementing Live Cursors in CodeMirror with Liveblocks and Yjs
DESCRIPTION: This code snippet demonstrates how to implement live cursors in a CodeMirror editor using Liveblocks and Yjs. It connects the editor to Liveblocks room, sets up Yjs document and provider, and attaches user information to Yjs awareness to enable collaborative editing with visible cursors.

LANGUAGE: tsx
CODE:
import { useRoom, useSelf } from "@/liveblocks.config";
// ...

// Collaborative code editor with undo/redo, live cursors, and live avatars
export function CollaborativeEditor() {
  const room = useRoom();
  const [element, setElement] = useState<HTMLElement>();
  const [yUndoManager, setYUndoManager] = useState<Y.UndoManager>();

  // Get user info from Liveblocks authentication endpoint
  const userInfo = useSelf((me) => me.info);

  const ref = useCallback((node: HTMLElement | null) => {
    if (!node) return;
    setElement(node);
  }, []);

  // Set up Liveblocks Yjs provider and attach CodeMirror editor
  useEffect(() => {
    let provider: TypedLiveblocksProvider;
    let ydoc: Y.Doc;
    let view: EditorView;

    if (!element || !room || !userInfo) {
      return;
    }

    // Create Yjs provider and document
    ydoc = new Y.Doc();
    provider = new LiveblocksYjsProvider(room as any, ydoc);
    const ytext = ydoc.getText("codemirror");
    const undoManager = new Y.UndoManager(ytext);
    setYUndoManager(undoManager);

    // Attach user info to Yjs
    provider.awareness.setLocalStateField("user", {
      name: userInfo.name,
      color: userInfo.color,
      colorLight: userInfo.color + "80", // 6-digit hex code at 50% opacity
    });

    // Set up CodeMirror and extensions
    const state = EditorState.create({
      doc: ytext.toString(),
      extensions: [
        basicSetup,
        javascript(),
        yCollab(ytext, provider.awareness, { undoManager }),
      ],
    });

    // Attach CodeMirror to element
    view = new EditorView({
      state,
      parent: element,
    });

    return () => {
      ydoc?.destroy();
      provider?.destroy();
      view?.destroy();
    };
  }, [element, room, userInfo]);

  return (
    <div className={styles.container}>
      <div className={styles.editorContainer} ref={ref}></div>
    </div>
  );
}

----------------------------------------

TITLE: Installing Live Cursors Example with Liveblocks CLI
DESCRIPTION: Command to set up the live cursors example project using the Liveblocks CLI. This automatically downloads the example and helps retrieve an API key from your Liveblocks account.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-live-cursors --api-key

----------------------------------------

TITLE: Initializing Liveblocks Config File
DESCRIPTION: Command to initialize the Liveblocks configuration file for a React project, which sets up the client and necessary types.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --init --framework react

----------------------------------------

TITLE: Implementing Live Typing Indicators with Liveblocks Presence
DESCRIPTION: Creates a component that displays a message when other users are typing, using Liveblocks presence data. The component checks other users' presence state and conditionally renders a notification when someone is typing.

LANGUAGE: javascript
CODE:
import React, { useEffect } from "react";
import { useDispatch, useSelector } from "react-redux";
import { actions } from "@liveblocks/redux";

import { setDraft } from "./store";

import "./App.css";

/* WhoIsHere */

function SomeoneIsTyping() {
  const someoneIsTyping = useSelector((state) =>
    state.liveblocks.others.some((user) => user.presence?.isTyping)
  );

  return someoneIsTyping ? (
    <div className="someone_is_typing">Someone is typing</div>
  ) : null;
}

export default function App() {
  const draft = useSelector((state) => state.draft);
  const dispatch = useDispatch();

  useEffect(() => {
    dispatch(actions.enterRoom("redux-demo-room"));

    return () => {
      dispatch(actions.leaveRoom("redux-demo-room"));
    };
  }, [dispatch]);

  return (
    <div className="container">
      <WhoIsHere />
      <input
        className="input"
        type="text"
        placeholder="What needs to be done?"
        value={draft}
        onChange={(e) => dispatch(setDraft(e.target.value))}
      ></input>
      <SomeoneIsTyping />
    </div>
  );
}

----------------------------------------

TITLE: Complete Implementation of Realtime Data Revalidation with SWR and Liveblocks
DESCRIPTION: A full implementation that combines SWR for data fetching with Liveblocks for realtime revalidation. This component displays a list of users, provides a button to add new users, and broadcasts events to ensure all clients see the updated data.

LANGUAGE: tsx
CODE:
import { useBroadcastevent, useEventListener } from "../liveblocks.config";

function Component() {
  // Data updates on every button click
  const { data, mutate } = useSWR("/api/user", fetcher);

  // Listen for custom event
  useEventListener(({ event }) => {
    if (event.type === "REVALIDATE") {
      mutate();
    }
  });

  // Create broadcast hook
  const broadcast = useBroadcastEvent();

  function addUser() {
    // Code to add a new user to your list
    // ...

    // Broadcast the custom event
    broadcast({ type: "REVALIDATE" });
  }

  return (
    <div>
      {users.map((user) => /* ... */)}:
      <button onClick={addUser}>Add new user</button>
    </div>
  );
}

----------------------------------------

TITLE: Referencing LiveList, LiveMap, and LiveObject in Liveblocks Storage
DESCRIPTION: This snippet mentions the core conflict-free data types in Liveblocks Storage that can be used to build multiplayer tools. These types (LiveList, LiveMap, and LiveObject) are designed to handle collaborative data synchronization.

LANGUAGE: markdown
CODE:
LiveList, LiveMap, and LiveObject conflict-free data types can be used to build all sorts of multiplayer tools.

----------------------------------------

TITLE: Using the useClient hook with LiveblocksProvider
DESCRIPTION: Example of using the useClient hook to access the Liveblocks client instance in a component.

LANGUAGE: ts
CODE:
import { useClient } from "@liveblocks/react/suspense";

const client = useClient();

----------------------------------------

TITLE: Setting Up Collaborative Tiptap Editor with Liveblocks
DESCRIPTION: Creates a collaborative text editor by combining Tiptap and Liveblocks. Uses useLiveblocksExtension to enable real-time synchronization between users and implements FloatingToolbar for text selection actions.

LANGUAGE: tsx
CODE:
"use client";

import { useLiveblocksExtension, FloatingToolbar } from "@liveblocks/react-tiptap";
import { useEditor, EditorContent } from "@tiptap/react";
import StarterKit from "@tiptap/starter-kit";
import { Threads } from "./Threads";

export function Editor() {
  const liveblocks = useLiveblocksExtension();

  const editor = useEditor({
    extensions: [
      liveblocks,
      StarterKit.configure({
        // The Liveblocks extension comes with its own history handling
        history: false,
      }),
    ],
    immediatelyRender: false,
  });

  return (
    <div>
      <EditorContent editor={editor} className="editor" />
      <Threads editor={editor} />
      <FloatingToolbar editor={editor} />
    </div>
  );
}

----------------------------------------

TITLE: Implementing Multiplayer Undo/Redo Functionality
DESCRIPTION: Adds undo and redo buttons to the toolbar that interact with the Liveblocks history API. This enables collaborative undo/redo functionality where changes to the shared storage can be reverted and reapplied across all connected clients.

LANGUAGE: jsx
CODE:
import { useEffect } from "react";
import "./App.css";
import { useDispatch, useSelector } from "react-redux";
import { actions } from "@liveblocks/redux";

import {
  insertRectangle,
  onShapePointerDown,
  deleteShape,
  onCanvasPointerUp,
  onCanvasPointerMove,
  client,
} from "./store";

const roomId = "redux-whiteboard";

export default function App() {
  const shapes = useSelector((state) => state.shapes);
  const isLoading = useSelector((state) => state.liveblocks.isStorageLoading);
  const selectedShape = useSelector((state) => state.selectedShape);
  const others = useSelector((state) => state.liveblocks.others);

  const dispatch = useDispatch();

  /* ... */

  return (
    <>
      <div
        className="canvas"
        onPointerMove={(e) => {
          /* ... */
        }}
        onPointerUp={() => {
          /* ... */
        }}
      >
        {/* ... */}
      </div>
      <div className="toolbar">
        <button onClick={() => dispatch(insertRectangle())}>Rectangle</button>
        <button
          onClick={() => dispatch(deleteShape())}
          disabled={selectedShape == null}
        >
          Delete
        </button>
        <button onClick={() => client.getRoom(roomId).history.undo()}>
          Undo
        </button>
        <button onClick={() => client.getRoom(roomId).history.redo()}>
          Redo
        </button>
      </div>
    </>
  );
}

/* Rectangle */

----------------------------------------

TITLE: Rendering a Cursor Component with Coordinates
DESCRIPTION: Example of how to render the Cursor component with specific x and y coordinates. This component visualizes a user's cursor position on the screen.

LANGUAGE: tsx
CODE:
<Cursor x={141} y={252} />

----------------------------------------

TITLE: Setting Up Collaborative Quill Text Editor with Liveblocks and Yjs
DESCRIPTION: Configures a collaborative Quill text editor using Liveblocks for real-time syncing and Yjs as the CRDT. This setup includes cursor tracking, toolbar configuration, and binding the Quill editor to Yjs text.

LANGUAGE: javascript
CODE:
import { createClient } from "@liveblocks/client";
import { getYjsProviderForRoom } from "@liveblocks/yjs";
import * as Y from "yjs";
import Quill from "quill";
import { QuillBinding } from "y-quill";
import QuillCursors from "quill-cursors";

// Set up Liveblocks client
const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

// Enter a multiplayer room
const { room, leave } = client.enterRoom("my-room");

// Set up Yjs document, shared text, and Liveblocks Yjs provider
const yProvider = getYjsProviderForRoom(room);
const yDoc = yProvider.getYDoc();
const yText = yDoc.getText("quill");

// Attach cursors plugin
Quill.register("modules/cursors", QuillCursors);

// Set up Quill editor and modules
const parent = document.querySelector("#editor");
const quill = new Quill(parent, {
  placeholder: "Start collaborating…",
  theme: "snow",
  modules: {
    cursors: true,
    toolbar: [
      [{ header: [1, 2, false] }],
      ["bold", "italic", "underline"],
      ["code-block"],
    ],
    history: {
      // Local undo shouldn't undo changes made by other users
      userOnly: true,
    },
  },
});

// Attach Yjs to Quill
const binding = new QuillBinding(yText, quill, provider.awareness);

----------------------------------------

TITLE: Creating LiveObjects in Liveblocks
DESCRIPTION: Demonstrates how to create LiveObject instances with and without initial data. LiveObjects are synchronized JavaScript objects used for storing records with fixed key names.

LANGUAGE: typescript
CODE:
import { LiveObject } from "@liveblocks/client";

const object = new LiveObject();

LANGUAGE: typescript
CODE:
import { LiveObject } from "@liveblocks/client";

const object = new LiveObject({ firstName: "Margaret", lastName: "Hamilton" });

----------------------------------------

TITLE: Using useUpdateMyPresence with History Support
DESCRIPTION: Demonstrates how to use the useUpdateMyPresence function with addToHistory option to add presence changes to the undo/redo stack for history management.

LANGUAGE: ts
CODE:
updateMyPresence({ selectedId: "xxx" }, { addToHistory: true });

----------------------------------------

TITLE: Setting Up Liveblocks Authentication API Route (Pages Router)
DESCRIPTION: Alternative API route using Next.js Pages Router that handles Liveblocks authentication. Creates a session for the user and authorizes access to a specified room.

LANGUAGE: typescript
CODE:
import { Liveblocks } from "@liveblocks/node";
import type { NextApiRequest, NextApiResponse } from "next";

const API_KEY = "{{SECRET_KEY}}";

const liveblocks = new Liveblocks({
  secret: API_KEY!,
});

export default async function handler(
  request: NextApiRequest,
  response: NextApiResponse
) {
  // Get the current user's info from your database
  const user = {
    id: "charlielayne@example.com",
    info: {
      name: "Charlie Layne",
      color: "#D583F0",
      picture: "https://liveblocks.io/avatars/avatar-1.png",
    },
  };

  // Create a session for the current user
  // userInfo is made available in Liveblocks presence hooks, e.g. useOthers
  const session = liveblocks.prepareSession(user.id, {
    userInfo: user.info,
  });

  // Give the user access to the room
  const { room } = request.body;
  session.allow(room, session.FULL_ACCESS);

  // Authorize the user and return the result
  const { status, body } = await session.authorize();
  response.status(status).send(body);
}

----------------------------------------

TITLE: Handling Different Event Types in Subscription Callbacks
DESCRIPTION: Demonstrates how to handle different event types in a subscription callback using type checking.

LANGUAGE: typescript
CODE:
room.subscribe("event", ({ event, user, connectionId }) => {
  if (event.type === "REACTION") {
    // Do something
  }
  if (event.type === "ACTION") {
    // Do something else
  }
});

----------------------------------------

TITLE: Implementing Real-time Typing Indicator with Liveblocks
DESCRIPTION: Enhances the JavaScript to display a typing indicator when other users are typing. It subscribes to the 'others' event from Liveblocks room, checks if any user's presence indicates typing, and updates the UI accordingly.

LANGUAGE: javascript
CODE:
import { createClient } from "@liveblocks/client";

const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

function run() {
  const { room, leave } = client.enterRoom("javascript-todo-app", {
    initialPresence: { isTyping: false },
  });

  const whoIsHere = document.getElementById("who_is_here");
  const todoInput = document.getElementById("todo_input");
  const someoneIsTyping = document.getElementById("someone_is_typing");

  room.subscribe("others", (others) => {
    whoIsHere.innerHTML = `There are ${others.count} other users online`;

    someoneIsTyping.innerHTML = others
      .toArray()
      .some((user) => user.presence?.isTyping)
      ? "Someone is typing..."
      : "";
  });

  todoInput.addEventListener("keydown", (e) => {
    // Clear the input when the user presses "Enter".
    // We'll add todo later on
    if (e.key === "Enter") {
      room.updatePresence({ isTyping: false });
      todoInput.value = "";
    } else {
      room.updatePresence({ isTyping: true });
    }
  });

  todoInput.addEventListener("blur", () => {
    room.updatePresence({ isTyping: false });
  });
}

run();

----------------------------------------

TITLE: Styling Remote Cursor Selection for Collaborative Editing
DESCRIPTION: Global CSS styles for remote cursor visualization in a collaborative editor. Defines styling for cursor selection background, caret, and user name display using CSS variables for dynamic coloring.

LANGUAGE: css
CODE:
/* Cursor selection background */
.yRemoteSelection {
  opacity: 0.5;
  background-color: var(--user-color);
  margin-right: -1px;
}

/* Cursor caret */
.yRemoteSelectionHead {
  position: absolute;
  box-sizing: border-box;
  height: 100%;
  border-left: 2px solid var(--user-color);
}

/* Cursor name */
.yRemoteSelectionHead::after {
  position: absolute;
  top: -1.4em;
  left: -2px;
  padding: 2px 6px;
  background: var(--user-color);
  color: #fff;
  border: 0;
  border-radius: 6px;
  border-bottom-left-radius: 0;
  line-height: normal;
  white-space: nowrap;
  font-size: 14px;
  font-style: normal;
  font-weight: 600;
  pointer-events: none;
  user-select: none;
  z-index: 1000;
}

----------------------------------------

TITLE: Creating a Custom Thread Composer with Composer Primitive in React
DESCRIPTION: Shows how to build a custom rich-text composer using the Composer primitive to create new threads when submitted, integrating with Liveblocks hooks.

LANGUAGE: tsx
CODE:
import { Composer } from "@liveblocks/react-ui/primitives";
import { useCreateThread } from "../liveblocks.config.ts";

// Render a custom composer that creates a thread on submit
function MyComposer() {
  const createThread = useCreateThread();

  return (
    <Composer.Form
      onComposerSubmit={({ body }, event) => {
        event.preventdefault();
        const thread = createThread({
          body,
          metadata: {},
        });
      }}
    >
      <Composer.Editor components={/* Your custom component parts */} />
      <Composer.Submit>Create thread</Composer.Submit>
    </Composer.Form>
  );
}

----------------------------------------

TITLE: Initializing a Tiptap Editor Document with Yjs
DESCRIPTION: This code shows how to initialize a Tiptap editor document with Yjs. It creates Yjs XML elements to represent a Tiptap document structure with a paragraph containing text, inserts them into an XML fragment, and sends the update to Liveblocks. This is specific to Tiptap editor integration.

LANGUAGE: typescript
CODE:
import * as Y from "yjs";
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});
const roomId = "my-room-name";

export async function POST() {
  // Create a Yjs document
  const yDoc = new Y.Doc();

  // The Tiptap Yjs state we're creating
  const yXmlElement = new Y.XmlElement("paragraph");
  yXmlElement.insert(0, [new Y.XmlText("Hello world")]);

  // Create your data structures and make your update
  const yXmlFragment = yDoc.getXmlFragment("default");
  yXmlFragment.insert(0, [yXmlElement]);

  // Encode the document state as an update message
  const yUpdate = Y.encodeStateAsUpdate(yDoc);

  // Create the new room
  const room = await liveblocks.createRoom(roomId, {
    defaultAccesses: ["room:write"],
  });

  // Initialize the Yjs document with the update
  await liveblocks.sendYjsBinaryUpdate(roomId, yUpdate);
}

----------------------------------------

TITLE: Creating Nested Data Structures with LiveObject, LiveList, and LiveMap
DESCRIPTION: Shows how to define complex nested data structures by combining LiveObject, LiveList, and LiveMap to create a type-safe storage schema.

LANGUAGE: typescript
CODE:
import { LiveObject, LiveList, LiveMap } from "@liveblocks/client";

type Person = LiveObject<{
  name: string;
  pets: LiveList<string>;
}>;

declare global {
  interface Liveblocks {
    Storage: {
      people: LiveMap<string, Person>;
    };
  }
}

----------------------------------------

TITLE: Implementing a Collaborative Quill Editor with Yjs and Liveblocks
DESCRIPTION: Creates a collaborative text editor component using Quill, Yjs, and Liveblocks. Sets up real-time synchronization between multiple users working in the same document.

LANGUAGE: tsx
CODE:
"use client";

import Quill from "quill";
import ReactQuill from "react-quill";
import { QuillBinding } from "y-quill";
import * as Y from "yjs";
import { LiveblocksYjsProvider } from "@liveblocks/yjs";
import { useRoom } from "@/liveblocks.config";
import { useEffect, useRef, useState } from "react";
import styles from "./Editor.module.css";

// Collaborative text editor with simple rich text, live cursors, and live avatars
export function CollaborativeEditor() {
  const room = useRoom();
  const [text, setText] = useState<Y.Text>();
  const [provider, setProvider] = useState<any>();

  // Set up Liveblocks Yjs provider
  useEffect(() => {
    const yDoc = new Y.Doc();
    const yText = yDoc.getText("quill");
    const yProvider = new LiveblocksYjsProvider(room, yDoc);
    setText(yText);
    setProvider(yProvider);

    return () => {
      yDoc?.destroy();
      yProvider?.destroy();
    };
  }, [room]);

  if (!text || !provider) {
    return null;
  }

  return <QuillEditor yText={text} provider={provider} />;
}

type EditorProps = {
  yText: Y.Text;
  provider: any;
};

function QuillEditor({ yText, provider }: EditorProps) {
  const reactQuillRef = useRef<ReactQuill>(null);

  // Set up Yjs and Quill
  useEffect(() => {
    let quill: ReturnType<ReactQuill["getEditor"]>;
    let binding: QuillBinding;

    if (!reactQuillRef.current) {
      return;
    }

    quill = reactQuillRef.current.getEditor();
    binding = new QuillBinding(yText, quill, provider.awareness);
    return () => {
      binding?.destroy?.();
    };
  }, [yText, provider]);

  return (
    <div className={styles.container}>
      <div className={styles.editorContainer}>
        <ReactQuill
          className={styles.editor}
          placeholder="Start typing here…"
          ref={reactQuillRef}
          theme="snow"
          modules={{
            toolbar: false,
            history: {
              // Local undo shouldn't undo changes from remote users
              userOnly: true,
            },
          }}
        />
      </div>
    </div>
  );
}

----------------------------------------

TITLE: Comprehensive error handling with useErrorListener
DESCRIPTION: Complete example showing how to handle different types of errors that can occur with the Liveblocks platform using the useErrorListener hook.

LANGUAGE: ts
CODE:
import { useErrorListener } from "@liveblocks/react/suspense";

useErrorListener((error) => {
  switch (error.context.type) {
    // Can happen if you use Presence, Storage, or Yjs
    case "ROOM_CONNECTION_ERROR": {
      const { code } = error.context;
      // -1   = Authentication error
      // 4001 = You don't have access to this room
      // 4005 = Room was full
      // 4006 = Room ID has changed
      break;
    }

    // Can happen if you use Comments or Notifications
    case "CREATE_THREAD_ERROR":
      const { roomId, threadId, commentId, body, metadata } = error.context;
      break;

    case "DELETE_THREAD_ERROR":
      const { roomId, threadId } = error.context;
      break;

    case "EDIT_THREAD_METADATA_ERROR":
      const { roomId, threadId, metadata } = error.context;
      break;

    case "MARK_THREAD_AS_RESOLVED_ERROR":
    case "MARK_THREAD_AS_UNRESOLVED_ERROR":
      const { roomId, threadId } = error.context;
      break;

    case "CREATE_COMMENT_ERROR":
    case "EDIT_COMMENT_ERROR":
      const { roomId, threadId, commentId, body } = error.context;
      break;

    case "DELETE_COMMENT_ERROR":
      const { roomId, threadId, commentId } = error.context;
      break;

    case "ADD_REACTION_ERROR":
    case "REMOVE_REACTION_ERROR":
      const { roomId, threadId, commentId, emoji } = error.context;
      break;

    case "MARK_INBOX_NOTIFICATION_AS_READ_ERROR":
      const { inboxNotificationId, roomId } = error.context;
      break;

    case "DELETE_INBOX_NOTIFICATION_ERROR":
      const { roomId } = error.context;
      break;

    case "MARK_ALL_INBOX_NOTIFICATIONS_AS_READ_ERROR":
    case "DELETE_ALL_INBOX_NOTIFICATIONS_ERROR":
      break;

    case "UPDATE_NOTIFICATION_SETTINGS_ERROR":
      const { roomId } = error.context;
      break;

    default:
      // Ignore any error from the future
      break;
  }
});

----------------------------------------

TITLE: Creating an Access Token Session in Liveblocks
DESCRIPTION: This snippet demonstrates how to create an access token session for a user, giving them different access levels to specific rooms. The example grants full access to a single design room and read access to all product rooms using a wildcard pattern.

LANGUAGE: typescript
CODE:
const session = liveblocks.prepareSession("olivier@example.com");

// Giving write access to one room, then read access to multiple rooms with a wildcard
session.allow("Vu78Rt:design:9Hdu73", session.FULL_ACCESS);
session.allow("Vu78Rt:product:*", session.READ_ACCESS);

const { body, status } = await session.authorize();

// '{ token: "j6Fga7..." }'
console.log(body);

----------------------------------------

TITLE: Configuring Liveblocks Client for Redux Integration
DESCRIPTION: Creates a Liveblocks client with authentication endpoint and uses it in the liveblocksEnhancer configuration.

LANGUAGE: js
CODE:
import { createClient } from "@liveblocks/client";
import { liveblocksEnhancer } from "@liveblocks/redux";

const client = createClient({
  authEndpoint: "/api/liveblocks-auth",
});

const store = configureStore({
  reducer: /* reducer */,
  enhancers: [
    liveblocksEnhancer({
      client,
    }),
  ],
});

----------------------------------------

TITLE: Defining Storage Root Type in Liveblocks Schema
DESCRIPTION: Demonstrates the required Storage root type declaration that must be included in every Liveblocks schema. This is a special type that serves as the entry point for your schema definition.

LANGUAGE: typescript
CODE:
type Storage {

}

----------------------------------------

TITLE: Configuring Regular Hooks in Liveblocks Config File
DESCRIPTION: Example of how to export regular (non-Suspense) versions of hooks from the Liveblocks config file. This configuration enables the use of standard hooks that require manual error handling.

LANGUAGE: tsx
CODE:
// ...

export const {
  // Export from here to use regular hooks
  useThreads,
  useUser,
} = createRoomContext(client, {});

----------------------------------------

TITLE: Adding Shape Selection with Liveblocks Presence
DESCRIPTION: Enhances the Redux store to track shape selection using Liveblocks Presence. This implementation adds a selectedShape state variable that allows tracking which shape each user has selected, with presenceMapping to sync this state across all connected users.

LANGUAGE: javascript
CODE:
/* ... */

const initialState = {
  shapes: {},
  selectedShape: null,
};

const slice = createSlice({
  name: "state",
  initialState,
  reducers: {
    insertRectangle: (state) => {
      /* ... */
    },
    onShapePointerDown: (state, action) => {
      state.selectedShape = action.payload;
    },
  },
});

export const { insertRectangle, onShapePointerDown } = slice.actions;

export function makeStore() {
  return configureStore({
    reducer: slice.reducer,
    enhancers: [
      liveblocksEnhancer({
        client,
        storageMapping: { shapes: true },
        presenceMapping: { selectedShape: true },
      }),
    ],
  });
}

const store = makeStore();

export default store;

----------------------------------------

TITLE: Implementing Comments with Liveblocks Hooks and Components
DESCRIPTION: Creates a collaborative app component that uses the useThreads hook to retrieve comment threads and renders them using the Thread component. Also includes a Composer component for creating new comments.

LANGUAGE: tsx file
CODE:
"use client";

import { useThreads } from "@liveblocks/react/suspense";
import { Composer, Thread } from "@liveblocks/react-ui";

export function CollaborativeApp() {
  const { threads } = useThreads();

  return (
    <div>
      {threads.map((thread) => (
        <Thread key={thread.id} thread={thread} />
      ))}
      <Composer />
    </div>
  );
}

----------------------------------------

TITLE: Implementing Live Cursors Component in Slate with React
DESCRIPTION: A React component that displays other users' cursors and selections in a collaborative text editor. It uses the slate-yjs package to track cursor positions and renders them with appropriate styling according to user information from Liveblocks.

LANGUAGE: tsx
CODE:
import {
  CursorOverlayData,
  useRemoteCursorOverlayPositions,
} from "@slate-yjs/react";
import React, { CSSProperties, ReactNode, useRef } from "react";
import { Cursor } from "./types";
import styles from "./Cursors.module.css";

export function Cursors({ children }: { children: ReactNode }) {
  const containerRef = useRef<HTMLDivElement>(null);
  const [cursors] = useRemoteCursorOverlayPositions<Cursor>({
    containerRef,
  });

  return (
    <div className={styles.cursors} ref={containerRef}>
      {children}
      {cursors.map((cursor) => (
        <Selection key={cursor.clientId} {...cursor} />
      ))}
    </div>
  );
}

function Selection({
  data,
  selectionRects,
  caretPosition,
}: CursorOverlayData<Cursor>) {
  if (!data) {
    return null;
  }

  const selectionStyle: CSSProperties = {
    backgroundColor: data.color,
  };

  return (
    <>
      {selectionRects.map((position, i) => (
        <div
          style={{ ...selectionStyle, ...position }}
          className={styles.selection}
          key={i}
        />
      ))}
      {caretPosition && <Caret caretPosition={caretPosition} data={data} />}
    </>
  );
}

type CaretProps = Pick<CursorOverlayData<Cursor>, "caretPosition" | "data">;

function Caret({ caretPosition, data }: CaretProps) {
  const caretStyle: CSSProperties = {
    ...caretPosition,
    background: data?.color,
  };

  const labelStyle: CSSProperties = {
    transform: "translateY(-100%)",
    background: data?.color,
  };

  return (
    <div style={caretStyle} className={styles.caretMarker}>
      <div className={styles.caret} style={labelStyle}>
        {data?.name}
      </div>
    </div>
  );
}

----------------------------------------

TITLE: Implementing Rectangle Insertion with Redux and Liveblocks
DESCRIPTION: This code sets up a Redux store with Liveblocks integration to handle collaborative state management. It includes functions for creating random rectangles with random colors and positions, and configures Liveblocks to sync the shapes across users.

LANGUAGE: javascript
CODE:
import { createClient } from "@liveblocks/client";
import { liveblocksEnhancer } from "@liveblocks/redux";
import { configureStore, createSlice } from "@reduxjs/toolkit";

export const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

const COLORS = ["#DC2626", "#D97706", "#059669", "#7C3AED", "#DB2777"];

function getRandomInt(max) {
  return Math.floor(Math.random() * max);
}

function getRandomColor() {
  return COLORS[getRandomInt(COLORS.length)];
}

const initialState = {
  shapes: {},
};

const slice = createSlice({
  name: "state",
  initialState,
  reducers: {
    insertRectangle: (state) => {
      const shapeId = Date.now().toString();
      const shape = {
        x: getRandomInt(300),
        y: getRandomInt(300),
        fill: getRandomColor(),
      };
      state.shapes[shapeId] = shape;
    },
  },
});

export const { insertRectangle } = slice.actions;

export function makeStore() {
  return configureStore({
    reducer: slice.reducer,
    enhancers: [
      liveblocksEnhancer({
        client,
        storageMapping: { shapes: true },
      }),
    ],
  });
}

const store = makeStore();

export default store;

----------------------------------------

TITLE: Using Async Functions in Subscription Callbacks
DESCRIPTION: Shows how to use async functions inside subscription callbacks, with the caveat that the callback itself is synchronous and there's no guarantee of completion timing.

LANGUAGE: typescript
CODE:
const { root } = await room.getStorage();

const unsubscribe = room.subscribe(root, (updatedRoot) => {
  async function doThing() {
    await fetch(/* ... */);
  }

  doThing();
});

----------------------------------------

TITLE: Implementing Undo/Redo Functionality in the App Component
DESCRIPTION: Addition of undo and redo buttons to the toolbar that leverage Liveblocks' built-in history management. The buttons are connected to the room.history.undo and room.history.redo methods.

LANGUAGE: tsx
CODE:
import { useEffect } from "react";
import useStore from "./store";

import "./App.css";

export default function App() {
  const shapes = useStore((state) => state.shapes);
  const insertRectangle = useStore((state) => state.insertRectangle);
  const others = useStore((state) => state.liveblocks.others);
  const selectedShape = useStore((state) => state.selectedShape);
  const deleteShape = useStore((state) => state.deleteShape);
  const onCanvasPointerMove = useStore((state) => state.onCanvasPointerMove);
  const onCanvasPointerUp = useStore((state) => state.onCanvasPointerUp);
  const undo = useStore((state) => state.liveblocks.room?.history.undo);
  const redo = useStore((state) => state.liveblocks.room?.history.redo);

  /* ... */

  return (
    <>
      <div
        className="canvas"
        onPointerMove={onCanvasPointerMove}
        onPointerUp={onCanvasPointerUp}
      >
        {/* ... */}
      </div>
      <div className="toolbar">
        <button onClick={insertRectangle}>Rectangle</button>
        <button onClick={deleteShape} disabled={selectedShape === null}>
          Delete
        </button>
        <button onClick={undo}>Undo</button>
        <button onClick={redo}>Redo</button>
      </div>
    </>
  );
}

/* Rectangle */

----------------------------------------

TITLE: Using useStorage to Render LiveList Data
DESCRIPTION: Demonstrates how to use the useStorage hook to access and render an immutable copy of the LiveList data as a regular JavaScript array.

LANGUAGE: tsx
CODE:
import { useStorage } from "@liveblocks/react/suspense";

function App() {
  const animals = useStorage((root) => root.animals);

  // ["Fido", "Felix"]
  console.log(animals);

  return (
    <ul>
      {animals.map((animal) => (
        <li key={animal}>{animal}</li>
      ))}
    </ul>
  );
}

----------------------------------------

TITLE: Rendering with useOthersMapped in JSX for Liveblocks React
DESCRIPTION: This example demonstrates how to use the results from useOthersMapped to render UI components for each user, using the connection ID as a React key for efficient rendering.

LANGUAGE: tsx
CODE:
const others = useOthersMapped((other) => other.presence.cursor);

// In JSX
return (
  <>
    {others.map(([connectionId, cursor]) => (
      <Cursor key={connectionId} x={cursor.x} y={cursor.y} />
    ))}
  </>
);

----------------------------------------

TITLE: Defining User Types in Liveblocks Configuration
DESCRIPTION: Shows how to define global Liveblocks interface types for Presence and UserMeta to customize user data in a Liveblocks application. This configuration defines cursor position for presence and user identification information.

LANGUAGE: typescript
CODE:
declare global {
  interface Liveblocks {
    // Each user's Presence
    // +++
    Presence: {
      cursor: { x: number; y: number };
    };
    // +++

    UserMeta: {
      id: string;
      // Custom user info set when authenticating with a secret key
      // +++
      info: {
        name: string;
        avatar: string;
      };
      // +++
    };
  }
}

----------------------------------------

TITLE: Importing Liveblocks Suspense and Regular Hooks in React
DESCRIPTION: Demonstrates the two different ways to import Liveblocks hooks - either from the Suspense-enabled path or the regular path. The Suspense version is recommended for easier collaborative application development.

LANGUAGE: tsx
CODE:
// Import the Suspense hook
import { useThreads } from "@/liveblocks/react/suspense";

// Import the regular hook
import { useThreads } from "@/liveblocks/react";

----------------------------------------

TITLE: Rendering Threads with useThreads in React
DESCRIPTION: This snippet demonstrates how to use the Thread component with the useThreads hook to render all threads in a Liveblocks room. It maps through the threads array and renders each thread with its own component.

LANGUAGE: tsx
CODE:
import { Thread } from "@liveblocks/react-ui";
import { useThreads } from "../liveblocks.config";

function Component() {
  const { threads } = useThreads();

  return (
    <>
      {threads.map((thread) => (
        <Thread key={thread.id} thread={thread} />
      ))}
    </>
  );
}

----------------------------------------

TITLE: Typing Storage with LiveList in TypeScript
DESCRIPTION: Shows how to type your Storage values by setting the Storage interface in the global Liveblocks namespace to enable type checking for LiveList.

LANGUAGE: typescript
CODE:
import { LiveList } from "@liveblocks/client";

declare global {
  interface Liveblocks {
    Storage: {
      animals: LiveList<string>;
    };
  }
}

----------------------------------------

TITLE: Using useStorage with Selectors for Efficient Rendering
DESCRIPTION: Shows different selector patterns with useStorage to efficiently subscribe to specific parts of the storage state to avoid unnecessary rerenders.

LANGUAGE: tsx
CODE:
// ✅ Rerenders if todos (or their children) change
const items = useStorage((root) => root.todos);

// ✅ Rerenders when todos are added or deleted
const numTodos = useStorage((root) => root.todos.length);

// ✅ Rerenders when the value of allDone changes
const allDone = useStorage((root) => root.todos.every((item) => item.done));

// ✅ Rerenders if any _unchecked_ todo items change
const uncheckedItems = useStorage(
  (root) => root.todos.filter((item) => !item.done),
  shallow // 👈
);

----------------------------------------

TITLE: Integrating Live Cursors with Editor Component in React
DESCRIPTION: Updates the main Editor component to incorporate live cursors functionality. Configures the editor with withCursors and withYjs plugins, and wraps the Editable component with the Cursors component to display other users' cursor positions.

LANGUAGE: tsx
CODE:
import { withCursors, withYjs, YjsEditor } from "@slate-yjs/core";
import { useSelf } from "../liveblocks.config";
import { Cursors } from "./Cursors";
// ...

export default function SlateEditor() {
  // Get user info from Liveblocks authentication endpoint
  const userInfo = useSelf((self) => self.info);

  // Set up editor with plugins, and place user info into Yjs awareness and cursors
  const editor = useMemo(() => {
    const e = withReact(
      withCursors(
        withYjs(createEditor(), sharedType),
        provider.awareness as any,
        {
          data: userInfo,
        }
      )
    );

    // ...
  }, [sharedType, provider.awareness, userInfo]);

  return (
    <div className={styles.container}>
      <div className={styles.editorContainer}>
        <Slate editor={editor} initialValue={[emptyNode]}>
          <Cursors>
            <Editable
              className={styles.editor}
              placeholder="Start typing here…"
            />
          </Cursors>
        </Slate>
      </div>
    </div>
  );
}

----------------------------------------

TITLE: Deploying Tldraw Whiteboard to Vercel with Liveblocks
DESCRIPTION: Command to create and deploy the tldraw whiteboard example to Vercel. This downloads the example and opens a browser to complete the Vercel deployment process.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-tldraw-whiteboard-storage --vercel

----------------------------------------

TITLE: Setting Up Collaborative CodeMirror Editor with Liveblocks and Yjs
DESCRIPTION: Complete JavaScript implementation for setting up a collaborative code editor. This code initializes Liveblocks client, creates a multiplayer room, sets up Yjs document with a shared text instance, and configures CodeMirror with collaborative extensions.

LANGUAGE: javascript
CODE:
import { createClient } from "@liveblocks/client";
import { getYjsProviderForRoom } from "@liveblocks/yjs";
import * as Y from "yjs";
import { yCollab } from "y-codemirror.next";
import { EditorView, basicSetup } from "codemirror";
import { EditorState } from "@codemirror/state";
import { javascript } from "@codemirror/lang-javascript";

// Set up Liveblocks client
const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

// Enter a multiplayer room
const { room, leave } = client.enterRoom("my-room");

// Set up Yjs document, shared text, and Liveblocks Yjs provider
const yProvider = getYjsProviderForRoom(room);
const yDoc = yProvider.getYDoc()
const yText = yDoc.getText("codemirror");

// Set up CodeMirror and extensions
const state = EditorState.create({
  doc: yText.toString(),
  extensions: [
    basicSetup,
    javascript(),
    yCollab(ytext, yProvider.awareness, { undoManager }),
  ],
});

// Attach CodeMirror to element
const parent = document.querySelector("#editor");
view = new EditorView({
  state,
  parent,
});

----------------------------------------

TITLE: Creating a Liveblocks Client with Auth Endpoint in TypeScript
DESCRIPTION: Example showing how to create a Liveblocks client using an authentication endpoint URL. This is the recommended approach for secure production applications.

LANGUAGE: ts
CODE:
import { createClient } from "@liveblocks/client";

const client = createClient({ authEndpoint: "/api/liveblocks-auth" });

----------------------------------------

TITLE: Creating a Custom Thread Component with Comment and Composer
DESCRIPTION: Demonstrates how to build a custom thread component by combining Comment and Composer components. The Composer is used to reply to an existing thread, while the Comments display existing thread content.

LANGUAGE: tsx
CODE:
import { Comment, Composer } from "@liveblocks/react-ui";
import { ThreadData } from "@liveblocks/client";
import { useThreads } from "@liveblocks/react/suspense";

// Renders a list of comments and a composer for adding new comments
function CustomThread({ thread }: { thread: ThreadData }) {
  return (
    <>
      {thread.comments.map((comment) => (
        <Comment key={comment.id} comment={comment} />
      ))}
      <Composer threadId={thread.id} />
    </>
  );
}

// Renders a list of custom thread components
function Component() {
  const { threads } = useThreads();

  return (
    <>
      {threads.map((thread) => (
        <CustomThread key={thread.id} />
      ))}
    </>
  );
}

----------------------------------------

TITLE: Creating LiveblocksContext with typed hooks
DESCRIPTION: Example of setting up a Liveblocks context with typed hooks in a configuration file, exporting the provider and hooks for use in the application.

LANGUAGE: tsx
CODE:
import { createClient } from "@liveblocks/client";
import { createRoomContext, createLiveblocksContext } from "@liveblocks/react";

const client = createClient({
  // publicApiKey: "",
  // authEndpoint: "/api/liveblocks-auth",
  // throttle: 100,
});

// ...

export const { RoomProvider } = createRoomContext(client);

export const {
  LiveblocksProvider,
  useInboxNotifications,

  // Other hooks
  // ...
} = createLiveblocksContext(client);

----------------------------------------

TITLE: Retrieving Element at Specific Index from LiveList in TypeScript
DESCRIPTION: Shows how to get the element at a specified index in a LiveList using the get() method. Returns undefined if the index doesn't exist in the list.

LANGUAGE: typescript
CODE:
const list = new LiveList(["adrien", "jonathan"]);

// "jonathan"
list.get(1);

----------------------------------------

TITLE: Complete Implementation of useIsEditorReady with Loading State
DESCRIPTION: Comprehensive example showing how to use the useIsEditorReady hook in a Lexical editor to conditionally render the editor or a loading indicator based on the content loading status.

LANGUAGE: tsx
CODE:
import { LexicalComposer } from "@lexical/react/LexicalComposer";
import { RichTextPlugin } from "@lexical/react/LexicalRichTextPlugin";
import { ContentEditable } from "@lexical/react/LexicalContentEditable";
import { LexicalErrorBoundary } from "@lexical/react/LexicalErrorBoundary";
import {
  liveblocksConfig,
  LiveblocksPlugin,
  // +++
  useIsEditorReady,
  // +++
} from "@liveblocks/react-lexical";

const initialConfig = liveblocksConfig({
  namespace: "MyEditor",
  theme: {},
  nodes: [],
  onError: (err) => console.error(err),
});

function Editor() {
  // +++
  const ready = useIsEditorReady();
  // +++

  return (
    <LexicalComposer initialConfig={initialConfig}>
      <LiveblocksPlugin>
        <FloatingThreads />
        <FloatingComposer />
        <AnchoredThreads />
      </LiveblocksPlugin>
      // +++
      {!ready ? (
        <div>Loading...</div>
      ) : (
        <RichTextPlugin
          contentEditable={<ContentEditable />}
          placeholder={<div>Enter some text...</div>}
          ErrorBoundary={LexicalErrorBoundary}
        />
      )}
      // +++
    </LexicalComposer>
  );
}

----------------------------------------

TITLE: Iterating Through LiveMap Values in TypeScript
DESCRIPTION: Demonstrates how to iterate through the values of a LiveMap using the values() method, which returns an Iterator object. This is useful for processing each value in the map without needing the keys.

LANGUAGE: typescript
CODE:
for (const value of map.values()) {
  // Iterate over all the values of the map
}

----------------------------------------

TITLE: Setting Up Authentication Endpoint with Express
DESCRIPTION: Creates an Express endpoint that handles Liveblocks authentication. This endpoint identifies users and determines their access to specific rooms.

LANGUAGE: typescript
CODE:
const express = require("express");
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

const app = express();
app.use(express.json());

app.post("/api/liveblocks-auth", (req, res) => {
  // Get the current user from your database
  const user = __getUserFromDB__(req);

  // Identify the user and return the result
  const { status, body } = await liveblocks.identifyUser(
    {
      userId: user.id,
      groupIds, // Optional
    },
    { userInfo: user.metadata },
  );

  return res.status(status).end(body);
});

----------------------------------------

TITLE: Creating Comment Content with Rich Text in TypeScript
DESCRIPTION: Example of creating formatted comment content with multiple paragraphs and text styling. This demonstrates constructing a CommentBody object to be used with room.createComment.

LANGUAGE: tsx
CODE:
import { CommentBody } from "@liveblocks/client";

const thread = await room.createThread(/* ... */);

const body: CommentBody = {
  version: 1,
  content: [
    // +++
    {
      type: "paragraph",
      children: [{ text: "Hello " }, { text: "world", bold: true }],
    },
    {
      type: "paragraph",
      children: [{ text: "Second", italic: true }, { text: " paragraph!" }],
    },
    // +++
  ],
};

const comment = await room.createComment({ threadId: thread.id, body });

----------------------------------------

TITLE: Retrieving a Specific Thread by ID in Liveblocks (TypeScript)
DESCRIPTION: Shows how to retrieve a specific thread and its associated inbox notification using its ID. The example also demonstrates how to get the thread ID from a newly created thread.

LANGUAGE: typescript
CODE:
const { thread, inboxNotification } = await room.getThread("th_xxx");

----------------------------------------

TITLE: Implementing a collaborative Monaco code editor in Vue.js
DESCRIPTION: Vue component that sets up a real-time collaborative Monaco code editor using Liveblocks and Yjs. It handles initialization of the editor, connecting to a Liveblocks room, and binding the editor to Yjs for real-time synchronization.

LANGUAGE: html
CODE:
<script setup>
import { ref, onMounted, onUnmounted } from "vue";
import { createClient } from "@liveblocks/client";
import { getYjsProviderForRoom } from "@liveblocks/yjs";
import * as Y from "yjs";
import * as monaco from "monaco-editor";
import { MonacoBinding } from "y-monaco";

const element = ref(null);
const editor = ref(null);
const binding = ref(null);
const leave = ref(null);

// Set up Liveblocks client
const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

// Enter a multiplayer room
const info = client.enterRoom("my-room");
const room = info.room;
leave.value = info.leave;

// Set up Yjs document, shared text, and Liveblocks Yjs provider
const yProvider = getYjsProviderForRoom(room);
const yDoc = yProvider.getYDoc();
const yText = yDoc.getText("monaco");

onMounted(() => {
  // Set up the Monaco editor
  editor.value = monaco.editor.create(element.value, {
    value: "",
    language: "javascript"
  })

  // Attach Yjs to Monaco
  binding.value = new MonacoBinding(
    yText,
    editorRef.getModel(),
    new Set([editor]),
    yProvider.awareness
  );
});

onUnmounted(() => {
  binding?.destroy();
  editor?.dispose();
  leave?.();
});
</script>

<template>
  <div ref="element" />
</template>

----------------------------------------

TITLE: Deploying the Issue Tracker to Vercel with Liveblocks CLI
DESCRIPTION: Command to download the example project and prepare it for deployment on Vercel. This will guide you through the deployment process while setting up the necessary environment.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-linear-like-issue-tracker --vercel

----------------------------------------

TITLE: Modifying Storage with useMutation Hook
DESCRIPTION: Implements adding and deleting todos using the useMutation hook to modify Liveblocks storage. The component provides functions to push new items to the LiveList and delete existing ones, with proper event handlers.

LANGUAGE: tsx
CODE:
import {
  LiveblocksProvider,
  RoomProvider,
  ClientSideSuspense,
  useOthers,
  useUpdateMyPresence,
  useStorage,
  useMutation,
} from "@liveblocks/react/suspense";
import { LiveList } from "@liveblocks/client";
import { useState } from "react";

/* WhoIsHere */
/* SomeoneIsTyping */

export default function TodoList() {
  const [draft, setDraft] = useState("");
  const updateMyPresence = useUpdateMyPresence();
  const todos = useStorage((root) => root.todos);

  const addTodo = useMutation(({ storage }, text) => {
    storage.get("todos").push({ text })
  }, []);

  const deleteTodo = useMutation(({ storage }, index) => {
    storage.get("todos").delete(index);
  }, []);

  return (
    <div className="container">
      <WhoIsHere />
      <input
        {/* ... */}

        onKeyDown={(e) => {
          if (e.key === "Enter") {
            updateMyPresence({ isTyping: false });
            addTodo(draft);
            setDraft("");
          }
        }}
      />
      <SomeoneIsTyping />
      {todos.map((todo, index) => {
        return (
          <div key={index} className="todo_container">
            <div className="todo">{todo.text}</div>

            <button
              className="delete_button"
              onClick={() => deleteTodo(index)}
            >
              ✕
            </button>

          </div>
        );
      })}
    </div>
  );
}

/* Page */

----------------------------------------

TITLE: Reconnecting a Liveblocks Room in TypeScript
DESCRIPTION: Demonstrates how to use the room.reconnect method to reauthenticate a user in a Liveblocks room without refreshing the page or losing client state. This preserves important state like undo/redo history.

LANGUAGE: typescript
CODE:
const { room, leave } = client.enterRoom("my-room", {
  // ...
});

room.reconnect();

----------------------------------------

TITLE: Installing Liveblocks Packages with npm
DESCRIPTION: Command to install all required Liveblocks packages for implementing comments functionality in React. All packages should use the same version.

LANGUAGE: bash
CODE:
npm install @liveblocks/client @liveblocks/react @liveblocks/react-ui

----------------------------------------

TITLE: Implementing AnchoredThreads Component in Lexical Editor
DESCRIPTION: Basic implementation showing how to add the AnchoredThreads component within a LexicalComposer setup. This component displays Thread components vertically alongside the editor at the same vertical coordinates as their corresponding text highlights.

LANGUAGE: tsx
CODE:
<LexicalComposer initialConfig={initialConfig}>
  <LiveblocksPlugin>
    <AnchoredThreads threads={threads} />
  </LiveblocksPlugin>
</LexicalComposer>

----------------------------------------

TITLE: Implementing Rectangle Insertion in Zustand Store with Liveblocks
DESCRIPTION: Sets up a Zustand store with Liveblocks integration to manage shapes and provide an insertRectangle function that creates randomly positioned and colored rectangles. The store uses Liveblocks' storage mapping to sync shapes between users.

LANGUAGE: typescript
CODE:
import create from "zustand";
import { createClient } from "@liveblocks/client";
import { liveblocks } from "@liveblocks/zustand";
import type { WithLiveblocks } from "@liveblocks/zustand";

export type Shape = {
  x: number;
  y: number;
  fill: string;
};

type State = {
  shapes: Record<string, Shape>;
  insertRectangle: () => void;
};

const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

const COLORS = ["#DC2626", "#D97706", "#059669", "#7C3AED", "#DB2777"];

function getRandomInt(max: number) {
  return Math.floor(Math.random() * max);
}

function getRandomColor() {
  return COLORS[getRandomInt(COLORS.length)];
}

const useStore = create<WithLiveblocks<State>>()(
  liveblocks(
    (set, get) => ({
      shapes: {},
      insertRectangle: () => {
        const { shapes } = get();

        const shapeId = Date.now().toString();
        const shape = {
          x: getRandomInt(300),
          y: getRandomInt(300),
          fill: getRandomColor(),
        };

        set({
          shapes: { ...shapes, [shapeId]: shape },
        });
      },
    }),
    {
      client,
      storageMapping: { shapes: true },
    }
  )
);

export default useStore;

----------------------------------------

TITLE: Reading from Storage with useStorage Hook
DESCRIPTION: Demonstrates how to use the useStorage hook to access and display todos from Liveblocks storage. This component maps through the LiveList of todos to render each item in the UI.

LANGUAGE: tsx
CODE:
import {
  LiveblocksProvider,
  RoomProvider,
  ClientSideSuspense,
  useOthers,
  useUpdateMyPresence,
  useStorage,
} from "@liveblocks/react/suspense";
import { LiveList } from "@liveblocks/client";
import { useState } from "react";

/* WhoIsHere */
/* SomeoneIsTyping */

function TodoList() {
  const [draft, setDraft] = useState("");
  const updateMyPresence = useUpdateMyPresence();
  const todos = useStorage((root) => root.todos);

  return (
    <div className="container">
      <WhoIsHere />
      <input
        {/* ... */}
        onKeyDown={(e) => {
          if (e.key === "Enter") {
            updateMyPresence({ isTyping: false });
            setDraft("");
          }
        }}
      />
      <SomeoneIsTyping />
      {todos.map((todo, index) => {
        return (
          <div key={index} className="todo_container">
            <div className="todo">{todo.text}</div>
            <button
              className="delete_button"
            >
              ✕
            </button>
          </div>
        );
      })}
    </div>
  );
}

/* Page */

----------------------------------------

TITLE: Creating a Session with Liveblocks in Node.js
DESCRIPTION: Prepares a session for a user with optional user metadata. This is the first step in implementing access token-based authentication.

LANGUAGE: typescript
CODE:
const session = liveblocks.prepareSession(
  "marie@example.com",   // Required, user ID from your DB
  {
    // Optional, custom static metadata for the session
    userInfo: {
      name: "Marie",
      avatar: "https://example.com/avatar/marie.jpg",
    },
  }
);

----------------------------------------

TITLE: Setting up Monaco collaborative code editor in Svelte
DESCRIPTION: Svelte component that initializes a collaborative Monaco code editor using Liveblocks and Yjs. It sets up the Liveblocks client, creates a room, configures the Yjs document and provider, and binds them to the Monaco editor.

LANGUAGE: html
CODE:
<script>
import { onMount, onDestroy } from "svelte";
import { createClient } from "@liveblocks/client";
import { getYjsProviderForRoom } from "@liveblocks/yjs";
import * as Y from "yjs";
import * as monaco from "monaco-editor";
import { MonacoBinding } from "y-monaco";

let element;
const roomId = "my-room";

// Set up Liveblocks client
const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

onMount(() => {
  // Enter a multiplayer room
  const { room, leave } = client.enterRoom(roomId);

  // Set up Yjs document, shared text, and Liveblocks Yjs provider
  const yProvider = getYjsProviderForRoom(room);
  const yDoc = yProvider.getYDoc();
  const yText = yDoc.getText("monaco");

  // Set up the Monaco editor
  const editor = monaco.editor.create(element, {
    value: "",
    language: "javascript"
  })

  // Attach Yjs to Monaco
  const binding = new MonacoBinding(
    yText,
    editorRef.getModel(),
    new Set([editor]),
    yProvider.awareness
  );

  return () => {
    binding.destroy();
    editor.dispose();
    leave();
  };
});

</script>

<div bind:this={element}></div>

----------------------------------------

TITLE: Reconnecting to Liveblocks Server (TypeScript)
DESCRIPTION: Demonstrates how to reconnect a local room instance to the Liveblocks server using room.reconnect(). This method creates a new WebSocket connection to the server.

LANGUAGE: typescript
CODE:
room.reconnect();

----------------------------------------

TITLE: Accessing Liveblocks Storage with useStorage Hook
DESCRIPTION: Demonstrates how to access storage data using the useStorage hook with a selector function. The component displays the scientist's first and last name in input fields, which update in realtime across clients.

LANGUAGE: typescript
CODE:
import { useStorage } from "@liveblocks/react";

function App() {
  const scientist = useStorage((root) => root.scientist);

  if (scientist == null) {
    return <div>Loading...</div>;
  }

  return (
    <>
      <input value={scientist.firstName} />
      <input value={scientist.lastName} />
    </>
  );
}

----------------------------------------

TITLE: Using Suspense with createRoomContext in Liveblocks
DESCRIPTION: Example of exporting suspense-ready hooks from createRoomContext. This allows the use of React suspense version of Liveblocks hooks, enabling better loading states and error handling.

LANGUAGE: tsx
CODE:
import { createClient } from "@liveblocks/client";
import { createRoomContext } from "@liveblocks/react";

const client = createClient({
  // publicApiKey: "",
  // authEndpoint: "/api/liveblocks-auth",
});

type Presence = {};
type Storage = {};
type UserMeta = {};
type RoomEvent = {};
type ThreadMetadata = {};

export const {
  // +++
  suspense: {
    RoomProvider,
    useMyPresence,

    // Other suspense hooks
    // ...
  },
  // +++
} = createRoomContext<Presence, Storage, UserMeta, RoomEvent, ThreadMetadata>(
  client
);

----------------------------------------

TITLE: Using useOthersListener Hook to Track User Events
DESCRIPTION: Demonstrates how to use the useOthersListener hook to track when users enter, leave, or update their presence in a room. This hook allows applications to respond to various user events in real-time.

LANGUAGE: ts
CODE:
function App() {
  useOthersListener(({ type, user, others }) => {
    switch (type) {
      case "enter":
        // `user` has entered the room
        break;

      case "leave":
        // `user` has left the room
        break;

      case "update":
        // Presence for `user` has updated
        break;

      case "reset":
        // Others list has been emptied
        break;
    }
  });
}

----------------------------------------

TITLE: Entering a Liveblocks Room
DESCRIPTION: Demonstrates how to enter a Liveblocks room using the client.enterRoom method, which returns both the room instance and a leave function to disconnect from the room.

LANGUAGE: ts
CODE:
const { room, leave } = client.enterRoom("my-room-id", {
  // Options
  // ...
});

----------------------------------------

TITLE: Connecting to a Liveblocks Room in React Component
DESCRIPTION: React component that connects to and disconnects from a Liveblocks room using the enterRoom and leaveRoom methods from the Zustand store.

LANGUAGE: tsx
CODE:
import React, { useEffect } from "react";
import useStore from "./store";

import "./App.css";

export default function App() {
  const {
    liveblocks: { enterRoom, leaveRoom },
  } = useStore();

  useEffect(() => {
    enterRoom("zustand-todo-app");
    return () => {
      leaveRoom("zustand-todo-app");
    };
  }, [enterRoom, leaveRoom]);

  return <div className="container">To-do list app</div>;
}

----------------------------------------

TITLE: Fetching Authentication Endpoint with Liveblocks Client
DESCRIPTION: Creates a Liveblocks client that authenticates users by fetching an authorization token from a custom API endpoint. The authEndpoint callback passes the room information and custom headers to the server.

LANGUAGE: typescript
CODE:
import { createClient } from "@liveblocks/client";

const client = createClient({
  authEndpoint: async (room) => {
    const response = await fetch("/api/liveblocks-auth", {
      method: "POST",
      headers: {
        Authentication: "<your own headers here>",
        "Content-Type": "application/json",
      },
      // Don't forget to pass `room` down. Note that it
      // can be undefined when using Notifications.
      body: JSON.stringify({ room }),
    });
    return await response.json();
  },
});

----------------------------------------

TITLE: Checking for Key Existence in a LiveMap in TypeScript
DESCRIPTION: Shows how to check if a specific key exists in a LiveMap using the has method, which returns a boolean.

LANGUAGE: typescript
CODE:
const map = new LiveMap([
  ["nimesh", "developer"],
  ["pierre", "designer"],
]);

// true
map.has("nimesh");

// false
map.has("alicia");

----------------------------------------

TITLE: Configuring Redux Store with Liveblocks Presence for Typing Indicators
DESCRIPTION: Sets up a Redux store with Liveblocks integration, adding presence mapping to track and sync user typing status across clients. The store includes draft state for input values and isTyping flag that is mapped to Liveblocks presence.

LANGUAGE: javascript
CODE:
import { createClient } from "@liveblocks/client";
import { liveblocksEnhancer } from "@liveblocks/redux";
import { configureStore, createSlice } from "@reduxjs/toolkit";

const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

const initialState = {
  draft: "",
  isTyping: false,
};

const slice = createSlice({
  name: "state",
  initialState,
  reducers: {
    setDraft: (state, action) => {
      state.isTyping = action.payload === "" ? false : true;
      state.draft = action.payload;
    },
  },
});

export const { setDraft } = slice.actions;

export function makeStore() {
  return configureStore({
    reducer: slice.reducer,
    enhancers: [
      liveblocksEnhancer({
        client,
        presenceMapping: { isTyping: true },
      }),
    ],
  });
}

const store = makeStore();

export default store;

----------------------------------------

TITLE: YDocUpdatedEvent Schema in TypeScript
DESCRIPTION: TypeScript schema and example for the YDocUpdatedEvent webhook. This event is triggered when changes are made to a Yjs document in a room, and is throttled to fire at most once every five seconds.

LANGUAGE: typescript
CODE:
// Schema
type YDocUpdatedEvent = {
  type: "ydocUpdated";
  data: {
    projectId: string;
    roomId: string;
    updatedAt: string;
  };
};

// Example
const ydocUpdatedEvent = {
  type: "ydocUpdated",
  data: {
    projectId: "my-project-id",
    roomId: "my-room-id",
    updatedAt: "2013-06-26T19:10:19Z",
  },
};

----------------------------------------

TITLE: Creating a Room Component for Liveblocks
DESCRIPTION: React component that creates a Liveblocks room context using LiveblocksProvider and RoomProvider. This component sets up the authentication and room connection.

LANGUAGE: tsx
CODE:
"use client";

import { ReactNode } from "react";
import {
  LiveblocksProvider,
  RoomProvider,
  ClientSideSuspense,
} from "@liveblocks/react/suspense";

export function Room({ children }: { children: ReactNode }) {
  return (
    <LiveblocksProvider authEndpoint="/api/liveblocks-auth">
      <RoomProvider id="my-room">
        <ClientSideSuspense fallback={<div>Loading…</div>}>
          {children}
        </ClientSideSuspense>
      </RoomProvider>
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Opening the FloatingComposer with TipTap Commands
DESCRIPTION: Shows how to programmatically open the FloatingComposer by creating a toolbar button that calls the addPendingComment command. The example also demonstrates checking if the current selection is a comment using the liveblocksCommentMark attribute.

LANGUAGE: tsx
CODE:
import { Editor } from "@tiptap/react";

function Toolbar({ editor }: { editor: Editor | null }) {
  if (!editor) {
    return null;
  }

  return (
    <button
      onClick={() => {
        // +++
        editor.chain().focus().addPendingComment().run();
        // +++
      }}
      // +++
      data-active={editor.isActive("liveblocksCommentMark")}
      // +++
    >
      💬 New comment
    </button>
  );
}

----------------------------------------

TITLE: Implementing ID Token Authentication in Liveblocks
DESCRIPTION: Creates an ID token for a user with optional group IDs and user metadata. This approach is used when Liveblocks should be the source of truth for user permissions.

LANGUAGE: typescript
CODE:
const { body, status } = await liveblocks.identifyUser(
  {
    userId: "marie@example.com", // Required, user ID from your DB
    groupIds: ["marketing", "engineering"],
  },

  // Optional
  {
    userInfo: {
      name: "Marie",
      avatar: "https://example.com/avatar/marie.jpg",
    },
  }
);

return new Response(body, { status });

----------------------------------------

TITLE: Implementing Live Cursors with Liveblocks
DESCRIPTION: A comprehensive example showing how to implement live cursors using Liveblocks. Includes cursor position type definition, updating current user's cursor position, and rendering other users' cursors.

LANGUAGE: typescript
CODE:
declare global {
  interface Liveblocks {
    Presence: {
      cursor: { x: number; y: number };
    };
  }
}

LANGUAGE: typescript
CODE:
const { room, leave } = client.enterRoom("my-room-id");

// Call this to update the current user's Presence
function updateCursorPosition({ x, y }) {
  room.updatePresence({ cursor: { x, y } });
}

const others = room.getOthers();

// Run __renderCursor__ when any other connected user updates their presence
const unsubscribe = room.subscribe("others", (others, event) => {
  for (const { id, presence } of others) {
    const { x, y } = presence.cursor;
    __renderCursor__(id, { x, y });
  }
}

// Handle events and rendering
// ...

----------------------------------------

TITLE: Getting Current User Information in Liveblocks Room
DESCRIPTION: Retrieves the current user's User object, which includes connection ID, presence data, user ID, metadata, and permissions. Returns null if not connected to the room.

LANGUAGE: typescript
CODE:
const { connectionId, presence, id, info, canWrite, canComment } =
  room.getSelf();

LANGUAGE: typescript
CODE:
const user = room.getSelf();

// {
//   connectionId: 52,
//   presence: {
//     cursor: { x: 263, y: 786 },
//   },
//   id: "mislav.abha@example.com",
//   info: {
//     avatar: "/mislav.png",
//   },
//   canWrite: true,
//   canComment: true,
// }
console.log(user);

----------------------------------------

TITLE: Installing Liveblocks and BlockNote Dependencies with NPM
DESCRIPTION: Installs the required Liveblocks and BlockNote packages for creating a collaborative text editor. All Liveblocks packages should use the same version.

LANGUAGE: bash
CODE:
npm install @liveblocks/client @liveblocks/react @liveblocks/react-ui @liveblocks/react-blocknote @blocknote/core @blocknote/react @blocknote/mantine

----------------------------------------

TITLE: Implementing Live Cursors in Tiptap Editor with Liveblocks
DESCRIPTION: This code adds live cursor functionality to a Tiptap editor using the useSelf hook from Liveblocks to get current user information. The user info is passed to the CollaborationCursor plugin to display cursors with user names.

LANGUAGE: tsx
CODE:
import { useSelf } from "../liveblocks.config.ts";
// ...

function TiptapEditor({ doc, provider }: EditorProps) {
  // Get user info from Liveblocks authentication endpoint
  const userInfo = useSelf((me) => me.info);

  // Set up editor with plugins, and place user info into Yjs awareness and cursors
  const editor = useEditor({
    // ...
    extensions: [
      // ...

      // Attach provider and user info
      CollaborationCursor.configure({
        provider: provider,
        user: userInfo,
      }),
    ],
  });

  return (
    <div className={styles.container}>
      <EditorContent editor={editor} className={styles.editorContainer} />
    </div>
  );
}

----------------------------------------

TITLE: Deleting a Thread by ID in TypeScript
DESCRIPTION: Example of using the room.deleteThread method to remove a thread by its ID. This method doesn't return any value upon successful deletion.

LANGUAGE: ts
CODE:
await room.deleteThread("th_xxx");

----------------------------------------

TITLE: Various return values from useStorage selectors in React
DESCRIPTION: Shows how selectors can return various types of values: direct node selection, computed values, and array transformations with shallow comparison.

LANGUAGE: tsx
CODE:
const animals = useStorage((root) => root.animals);
// ["🦁", "🦊", "🐵"]

const ada = useStorage((root) => root.mathematician);
// { firstName: "Ada", lastName: "Lovelace" }

const fullname = useStorage(
  (root) => `${root.mathematician.firstName} ${root.mathematician.lastName}`
);
// "Ada Lovelace"

const fruits = useStorage((root) => [...root.fruitsByName.values()], shallow);
// ["🍎", "🍌", "🍒"]

----------------------------------------

TITLE: Accessing User Data with useUser Hook
DESCRIPTION: Example of using the useUser hook to access user data that was resolved through the resolveUsers function. This shows how to retrieve user information such as name, avatar, and custom properties within React components.

LANGUAGE: tsx
CODE:
import { useUser } from "@liveblocks/react/suspense";

function Component() {
  const user = useUser("marc@example.com");

  // { name: "Marc", avatar: "https://...", ... }
  console.log(user);
}

----------------------------------------

TITLE: Retrieving a Single Inbox Notification with getInboxNotification in TypeScript
DESCRIPTION: Shows how to retrieve a specific inbox notification for a user by providing both the userId and inboxNotificationId.

LANGUAGE: typescript
CODE:
const inboxNotification = await liveblocks.getInboxNotification({
  userId: "steven@example.com",
  inboxNotificationId: "in_3dH7sF3...",
});

// { id: "in_3dH7sF3...", kind: "thread", ... }
// or { id: "in_3dH7sF3...", kind: "textMention", ... }
// or { id: "in_3dH7sF3...", kind: "$yourKind", ... }
console.log(inboxNotification);

----------------------------------------

TITLE: Using AuthEndpoint as a Callback with Custom Headers
DESCRIPTION: Advanced configuration for LiveblocksProvider that uses a callback function for the authEndpoint prop to pass custom headers and body data to the authentication endpoint.

LANGUAGE: tsx
CODE:
<LiveblocksProvider
  authEndpoint={async (room) => {
    // Passing custom headers and body to your endpoint
    const headers = {
      // Custom headers
      // ...

      "Content-Type": "application/json",
    };

    const body = JSON.stringify({
      // Custom body
      // ...

      room,
    });

    const response = await fetch("/api/liveblocks-auth", {
      method: "POST",
      headers,
      body,
    });

    return await response.json();
  }}
/>

----------------------------------------

TITLE: Using the useOthers Hook for Room Connection Status
DESCRIPTION: React component that uses the useOthers hook from Liveblocks to display how many other users are currently connected to the same room. This demonstrates basic Presence functionality.

LANGUAGE: tsx
CODE:
"use client";

import { useOthers } from "./liveblocks.config";

export function Room() {
  const others = useOthers();
  const userCount = others.length;

  return <div>There are {userCount} other user(s) online</div>;
}

----------------------------------------

TITLE: Creating a Text Formatting Toolbar for Lexical Editor in React
DESCRIPTION: This component creates a basic text-style toolbar for a Lexical editor with buttons for bold, italic, and underline formatting. It uses the Lexical Composer context to access the editor instance and dispatch formatting commands.

LANGUAGE: tsx
CODE:
import { useLexicalComposerContext } from "@lexical/react/LexicalComposerContext";
import { FORMAT_TEXT_COMMAND } from "lexical";
import styles from "./Toolbar.module.css";

export function Toolbar() {
  const [editor] = useLexicalComposerContext();

  return (
    <div className={styles.toolbar}>
      <button
        className={styles.buttonBold}
        onClick={() => {
          editor.dispatchCommand(FORMAT_TEXT_COMMAND, "bold");
        }}
        aria-label="Format bold"
      >
        B
      </button>
      <button
        className={styles.buttonItalic}
        onClick={() => {
          editor.dispatchCommand(FORMAT_TEXT_COMMAND, "italic");
        }}
        aria-label="Format italic"
      >
        i
      </button>
      <button
        className={styles.buttonUnderline}
        onClick={() => {
          editor.dispatchCommand(FORMAT_TEXT_COMMAND, "underline");
        }}
        aria-label="Format underline"
      >
        u
      </button>
    </div>
  );
}

----------------------------------------

TITLE: Using Wildcard Permissions with Access Tokens in Liveblocks
DESCRIPTION: This snippet shows how to grant access to multiple rooms at once using wildcard patterns. It demonstrates granting full access to a specific design room and all rooms under the product group within an organization.

LANGUAGE: typescript
CODE:
const session = liveblocks.prepareSession("olivier@example.com");

// Giving full access to one room
session.allow("Vu78Rt:design:9Hdu73", session.FULL_ACCESS);

// Give full access to every room with an ID beginning with "Vu78Rt:product:"
session.allow("Vu78Rt:product:*", session.FULL_ACCESS);

const { body, status } = await session.authorize();

----------------------------------------

TITLE: Getting or Creating a Room with Liveblocks.getOrCreateRoom
DESCRIPTION: Demonstrates how to get a room by its ID, or create it if it doesn't exist. This provides a convenient way to ensure a room exists before attempting to use it.

LANGUAGE: typescript
CODE:
const room = await liveblocks.getOrCreateRoom("my-room-id", {
  defaultAccesses: ["room:write"],
});

// { type: "room", id: "my-room-id", metadata: {...}, ... }
console.log(room);

----------------------------------------

TITLE: Implementing Collaborative Quill Text Editor in Svelte
DESCRIPTION: A Svelte component that sets up a collaborative Quill text editor using Liveblocks and Yjs. It establishes a connection to a room, creates a shared document, and binds the editor to Yjs with cursor awareness.

LANGUAGE: html
CODE:
<script>
import { onMount, onDestroy } from "svelte";
import { createClient } from "@liveblocks/client";
import { getYjsProviderForRoom } from "@liveblocks/yjs";
import * as Y from "yjs";
import Quill from "quill";
import { QuillBinding } from "y-quill";
import QuillCursors from "quill-cursors";

let element;

// Set up Liveblocks client
const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

onMount(() => {
  // Enter a multiplayer room
  const { room, leave } = client.enterRoom("my-room");

  // Set up Yjs document, shared text, and Liveblocks Yjs provider
  const yProvider = getYjsProviderForRoom(room);
  const yDoc = yProvider.getYDoc();
  const yText = yDoc.getText("quill");

  // Attach cursors plugin
  Quill.register("modules/cursors", QuillCursors);

  // Set up Quill editor and modules
  const quill = new Quill(element, {
    placeholder: "Start collaborating…",
    theme: "snow",
    modules: {
      cursors: true,
      toolbar: [
        [{ header: [1, 2, false] }],
        ["bold", "italic", "underline"],
        ["code-block"],
      ],
      history: {
        // Local undo shouldn't undo changes made by other users
        userOnly: true,
      },
    },
  });

  // Attach Yjs to Quill
  const binding = new QuillBinding(yText, quill, yProvider.awareness);

  return () => {
    binding.destroy();
    leave();
  };
});
</script>

<div bind:this={element}></div>

----------------------------------------

TITLE: Subscribing to Nested LiveStructures in Liveblocks
DESCRIPTION: Demonstrates how to subscribe to different levels of nested live structures, including root, a LiveMap, and an item within the LiveMap.

LANGUAGE: typescript
CODE:
const { root } = await room.getStorage();
const people = root.get("people");
const steven = people.get("steven");

const unsubscribeRoot = room.subscribe(root, (updatedRoot) => {
  // ...
});

const unsubscribePeople = room.subscribe(people, (updatedPeople) => {
  // ...
});

const unsubscribeSteven = room.subscribe(steven, (updatedSteven) => {
  // ...
});

----------------------------------------

TITLE: LiveblocksProvider and RoomProvider Context Examples
DESCRIPTION: Shows different rendering contexts for the Header component depending on how it's wrapped with LiveblocksProvider and RoomProvider. Demonstrates how the useIsInsideRoom hook behaves in different provider scenarios.

LANGUAGE: tsx
CODE:
// 👥👤 Live avatar stack and your avatar
<LiveblocksProvider /* ... */>
  <RoomProvider /* ... */>
    <Header />
  </RoomProvider>
</LiveblocksProvider>


// 👤 Just your avatar
<LiveblocksProvider /* ... */>
  <Header />
</LiveblocksProvider>

// 👤 Just your avatar
<Header />

----------------------------------------

TITLE: Typing Liveblocks Storage in TypeScript
DESCRIPTION: Shows how to define TypeScript types for Liveblocks Storage by extending the global Liveblocks interface. This example sets up typing for a LiveList of animal objects.

LANGUAGE: typescript
CODE:
import { LiveList } from "@liveblocks/client";

declare global {
  interface Liveblocks {
    Storage: {
      animals: LiveList<{ name: string }>;
    };
  }
}

----------------------------------------

TITLE: Creating a Liveblocks Room Component in Next.js
DESCRIPTION: Sets up a Room component that creates a Liveblocks collaboration space. Implements LiveblocksProvider for client setup, RoomProvider for joining a specific room, and ClientSideSuspense for handling loading states.

LANGUAGE: tsx
CODE:
"use client";

import { ReactNode } from "react";
import {
  LiveblocksProvider,
  RoomProvider,
  ClientSideSuspense,
} from "@liveblocks/react/suspense";

export function Room({ children }: { children: ReactNode }) {
  return (
    <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>
      <RoomProvider id="my-room">
        <ClientSideSuspense fallback={<div>Loading…</div>}>
          {children}
        </ClientSideSuspense>
      </RoomProvider>
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Filtering Elements from LiveList in TypeScript
DESCRIPTION: Shows how to create a filtered array from a LiveList using the filter() method. The example returns a new array containing only the even numbers from the list.

LANGUAGE: typescript
CODE:
const list = new LiveList([0, 1, 2, 3, 4]);

// [0, 2, 4]
list.filter((i) => i % 2 === 0);

----------------------------------------

TITLE: Setting up the Liveblocks Client with LiveblocksProvider and RoomProvider
DESCRIPTION: React component setup demonstrating how to configure the Liveblocks client and join a room using LiveblocksProvider and RoomProvider components.

LANGUAGE: tsx
CODE:
"use client";

import {
  LiveblocksProvider,
  RoomProvider,
} from "@liveblocks/react/suspense";
import { Room } from "./Room";

export default function App() {
  return (
    <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"} >
      <RoomProvider id="my-room">
        {/* ... */}
      </RoomProvider>
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Setting Up Editor with AI Capabilities
DESCRIPTION: Demonstrates how to enable AI features in a Tiptap editor using useLiveblocksExtension and integrating the AiToolbar component.

LANGUAGE: tsx
CODE:
import {
  useLiveblocksExtension,
  // +++
  AiToolbar,
  // +++
  FloatingToolbar,
} from "@liveblocks/react-tiptap";
import { useEditor, EditorContent } from "@tiptap/react";

function TextEditor() {
  const liveblocks = useLiveblocksExtension({
    // +++
    ai: true,
    // +++
  });

  const editor = useEditor({
    extensions: [
      liveblocks,
      // ...
    ],
  });

  return (
    <div>
      <EditorContent editor={editor} />
      // +++
      <AiToolbar editor={editor} />
      // +++
      <FloatingToolbar editor={editor} />
    </div>
  );
}

----------------------------------------

TITLE: Connecting Redux Store to Liveblocks
DESCRIPTION: Creates a Liveblocks client and uses the liveblocksEnhancer in the Redux store setup. This adds a new state called 'liveblocks' to the store, enabling interaction with Presence and Storage APIs.

LANGUAGE: typescript
CODE:
"use client";

import { createClient } from "@liveblocks/client";
import { liveblocksEnhancer } from "@liveblocks/redux";
import { configureStore, createSlice } from "@reduxjs/toolkit";

const client = createClient({
  publicApiKey: "pk_prod_xxxxxxxxxxxxxxxxxxxxxxxx",
});

const initialState = {};

const slice = createSlice({
  name: "state",
  initialState,
  reducers: {
    /* logic will be added here */
  },
});

function makeStore() {
  return configureStore({
    reducer: slice.reducer,
    enhancers: [
      liveblocksEnhancer({
        client,
      }),
    ],
  });
}

const store = makeStore();

export default store;

----------------------------------------

TITLE: Using useRoom with Optional Room Context in Liveblocks
DESCRIPTION: Using useRoom with the allowOutsideRoom option to handle cases where the component might be used outside of a RoomProvider context. Returns null when outside a room instead of throwing an error.

LANGUAGE: ts
CODE:
import { useRoom } from "@liveblocks/react/suspense";

const room = useRoom({ allowOutsideRoom: true }); // Possibly `null`

----------------------------------------

TITLE: Setting Values in a LiveMap in TypeScript
DESCRIPTION: Shows how to add or update an element in a LiveMap with a specified key and value using the set method.

LANGUAGE: typescript
CODE:
const map = new LiveMap();
map.set("vincent", "engineer");

// Map { "vincent" => "engineer" }
map.toImmutable();

----------------------------------------

TITLE: Retrieving Attachment URLs with Room.getAttachmentUrl in TypeScript
DESCRIPTION: Demonstrates how to get a presigned URL for an attachment by its ID. The method returns a string containing the URL that can be used to access the attachment.

LANGUAGE: typescript
CODE:
const url = await room.getAttachmentUrl("at_xxx");

// "https://..."
console.log(url);

----------------------------------------

TITLE: Granting Access to Product Rooms Using Wildcards in Liveblocks (TSX)
DESCRIPTION: This code demonstrates how to use a wildcard in session.allow() to grant a user full access to all product rooms in an organization. The pattern 'Vu78Rt:product:*' gives access to any room that matches this pattern.

LANGUAGE: tsx
CODE:
// Access to every `product` room
session.allow("Vu78Rt:product:*", session.FULL_ACCESS);

----------------------------------------

TITLE: Initializing liveblocks middleware with Zustand
DESCRIPTION: Basic setup of the liveblocks middleware with Zustand, showing the integration pattern between a Zustand store and Liveblocks. The middleware connects the Zustand state to Liveblocks Presence and Storage features.

LANGUAGE: javascript
CODE:
import create from "zustand";
import { liveblocks } from "@liveblocks/zustand";

const useStore = create(
  liveblocks(
    (set) => ({
      /* state and actions */
    }),
    {
      client,
      presenceMapping: {},
      storageMapping: {},
    }
  )
);

----------------------------------------

TITLE: Using Typed Presence in Subscribe Callbacks
DESCRIPTION: Demonstrates how presence data is properly typed in subscription callbacks based on the global type definition.

LANGUAGE: typescript
CODE:
const unsubscribe = room.subscribe("my-presence", (presence) => {
  // { status: "typing", cursor: { x: 45, y: 67 }
  console.log(presence);
});

----------------------------------------

TITLE: Using useInboxNotifications hook in React with Liveblocks
DESCRIPTION: Demonstrates how to retrieve inbox notifications for the current user with basic usage. By default, returns up to 50 notifications from the current project.

LANGUAGE: tsx
CODE:
import { useInboxNotifications } from "@liveblocks/react/suspense";

const { inboxNotifications, error, isLoading } = useInboxNotifications();

----------------------------------------

TITLE: Implementing resolveUsers Function in Liveblocks Config
DESCRIPTION: This code snippet shows how to implement the resolveUsers function in your Liveblocks configuration file. This function retrieves user information from your backend based on user IDs and returns it to Liveblocks Comments.

LANGUAGE: typescript
CODE:
// ...

const client = createClient({
  // ...
  async resolveUsers({ userIds }) {
    // ["marc@example.com", ...]
    console.log(userIds);

    // Get users from your back end
    const users = await __fetchUsers__(userIds);

    // [{ name: "Marc", avatar: "https://example.com/marc.png" }, ...]
    console.log(users);

    // Return a list of users
    return users;
  },
});

----------------------------------------

TITLE: Creating a Liveblocks Room Client Component
DESCRIPTION: Defines a client component that wraps content with RoomProvider to join a specific Liveblocks room and initialize storage. This approach avoids issues with importing LiveObject in server components.

LANGUAGE: tsx
CODE:
"use client";

import { ReactNode } from "react";
import { RoomProvider } from "../liveblocks.config";
import { LiveObject } from "@liveblocks/client";

export default function Room({ children }: { children: ReactNode }) {
  return (
    <RoomProvider
      id="my-room-name"
      initialStorage={{
        // ✅ This is a client component, so everything works!
        session: new LiveObject(),
      }}
    >
      {children}
    </RoomProvider>
  );
}

----------------------------------------

TITLE: Multiple Ways to Update Notification Settings with useUpdateNotificationSettings
DESCRIPTION: Demonstrates various ways to use the updateSettings function from useUpdateNotificationSettings hook. Shows how to pass partials, enable custom notifications, and set complex settings across different notification channels.

LANGUAGE: tsx
CODE:
// You only need to pass partials
updateSettings({
  email: { thread: true },
});

// Enabling a custom notification on the slack channel
updateSettings({
  slack: { $myCustomNotification: true },
});

// Setting complex settings
updateSettings({
  email: {
    thread: true,
    textMention: false,
    $newDocument: true,
  },
  slack: {
    thread: false,
    $fileUpload: false,
  },
  teams: {
    thread: true,
  },
});

----------------------------------------

TITLE: Implementing ID Token Authentication in Next.js
DESCRIPTION: A complete example showing how to implement ID token-based authentication in a Next.js endpoint, retrieving user data and creating an ID token with user metadata.

LANGUAGE: typescript
CODE:
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export default async function auth(req, res) {
  /**
   * Implement your own security here.
   *
   * It's your responsibility to ensure that the caller of this endpoint
   * is a valid user by validating the cookies or authentication headers
   * and that it has access to the requested room.
   */

  // Get the current user from your database
  const user = __getUserFromDB__(req);

  // Create an ID token for the user
  const { body, status } = await liveblocks.identifyUser(
    {
      userId: user.id,
    },
    {
      userInfo: {
        name: user.fullName,
        color: user.favoriteColor,
      },
    }
  );

  return new Response(body, { status });
}

----------------------------------------

TITLE: Creating a Liveblocks Room Component in Next.js
DESCRIPTION: Sets up a Room component that configures LiveblocksProvider and RoomProvider with ClientSideSuspense for loading states. This creates a virtual space for users to collaborate in real-time.

LANGUAGE: tsx file
CODE:
"use client";

import { ReactNode } from "react";
import {
  LiveblocksProvider,
  RoomProvider,
  ClientSideSuspense,
} from "@liveblocks/react/suspense";

export function Room({ children }: { children: ReactNode }) {
  return (
    <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>
      <RoomProvider id="my-room">
        <ClientSideSuspense fallback={<div>Loading…</div>}>
          {children}
        </ClientSideSuspense>
      </RoomProvider>
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Importing Liveblocks Styles in Next.js Layout
DESCRIPTION: Imports Liveblocks and Tiptap default style sheets along with custom global styles in the Next.js root layout. This ensures all components are properly styled throughout the application.

LANGUAGE: tsx
CODE:
import "@liveblocks/react-ui/styles.css";
import "@liveblocks/react-tiptap/styles.css";
import "./globals.css";

----------------------------------------

TITLE: Creating a Custom Thread Component for AnchoredThreads
DESCRIPTION: Demonstrates building a fully custom Thread component for AnchoredThreads using the Comment primitives from Liveblocks React UI.

LANGUAGE: tsx
CODE:
import { Comment } from "@liveblocks/react-ui/primitives";

<AnchoredThreads
  editor={editor}
  threads={threads}
  style={{ width: "350px" }}
  className="my-anchored-thread"
  components={{
    Thread: (props) => (
      // +++
      <div>
        {props.thread.comments.map((comment) => (
          <Comment.Body
            key={comment.id}
            body={comment.body}
            components={/* ... */}
          />
        ))}
      </div>
      // +++
    ),
  }}
/>;

----------------------------------------

TITLE: Configuring Redux Store with Liveblocks Enhancer
DESCRIPTION: This snippet demonstrates how to set up a Redux store with Liveblocks enhancer. It creates a slice with initial state and reducers, then configures the store with the Liveblocks enhancer, specifying which state properties should be synchronized across clients using storageMapping.

LANGUAGE: javascript
CODE:
/* ...client setup... */

const initialState = {
  firstName: "Marie",
  lastName: "Curie",
  discoveries: ["Polonium", "Radium"],
};

const slice = createSlice({
  name: "state",
  initialState,
  reducers: {
    setFirstName: (state, action) => {
      state.firstName = action.payload;
    },
    setLastName: (state, action) => {
      state.lastName = action.payload;
    },
    addDiscovery: (state, action) => {
      state.discoveries.push(action.payload);
    },
  },
});

export const { setScientist } = slice.actions;

function makeStore() {
  return configureStore({
    reducer: slice.reducer,
    enhancers: [
      enhancer({
        client,
        storageMapping: { firstName: true, lastName: true, discoveries: true },
      }),
    ],
  });
}

const store = makeStore();

----------------------------------------

TITLE: Retrieving Rooms with Liveblocks.getRooms
DESCRIPTION: Demonstrates how to fetch a list of rooms from your Liveblocks project. Returns rooms sorted by creation time with pagination support via nextCursor and nextPage properties.

LANGUAGE: typescript
CODE:
const { data: rooms, nextCursor, nextPage } = await liveblocks.getRooms();

// A list of rooms
// [{ type: "room", id: "my-room-id", ... }, ...]
console.log(rooms);

// A pagination cursor used for retrieving the next page of results with `startingAfter`
// "L3YyL3Jvb21z..."
console.log(nextCursor);

// A pagination URL used for retrieving the next page of results with the REST API
// "/v2/rooms?startingAfter=L3YyL3Jvb21z..."
console.log(nextPage);

----------------------------------------

TITLE: Creating a Collaborative Tiptap Text Editor in Vue.js
DESCRIPTION: Vue.js component implementing a collaborative text editor using Liveblocks, Yjs, and Tiptap. The component sets up a Liveblocks client, connects to a room, configures a Yjs document, and initializes the Tiptap editor with collaboration extensions.

LANGUAGE: html
CODE:
<script setup>
import { onUnmounted } from "vue";
import { createClient } from "@liveblocks/client";
import { getYjsProviderForRoom } from "@liveblocks/yjs";
import * as Y from "yjs";
import { useEditor, EditorContent } from "@tiptap/vue-3";
import StarterKit from "@tiptap/starter-kit";
import Collaboration from "@tiptap/extension-collaboration";
import CollaborationCursor from "@tiptap/extension-collaboration-cursor";

const leave = ref(null);

// Set up Liveblocks client
const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

// Enter a multiplayer room
const info = client.enterRoom("my-room");
const room = info.room;
leave.value = info.leave;

// Set up Yjs document and Liveblocks Yjs provider
const yProvider = getYjsProviderForRoom(room);
const yDoc = yProvider.getYDoc();

// Set up the Tiptap editor
const editor = useEditor({
  element,
  extensions: [
    StarterKit.configure({
      // The Collaboration extension comes with its own history handling
      history: false,
    }),
    // Register the Yjs document with Tiptap
    Collaboration.configure({
      document: yDoc,
    }),
    CollaborationCursor.configure({
      provider: yProvider,
    }),
  ],
});

onUnmounted(() => {
  leave?.();
});
</script>

<template>
  <editor-content :editor="editor" />
</template>

----------------------------------------

TITLE: Complete FloatingComposer and FloatingThreads Integration in React-TipTap
DESCRIPTION: Demonstrates a complete implementation of the FloatingComposer alongside FloatingThreads to create a full commenting system. The example shows how to initialize both components with the editor and set appropriate styling.

LANGUAGE: tsx
CODE:
import {
  useLiveblocksExtension,
  // +++
  FloatingComposer,
  // +++
  FloatingThreads,
} from "@liveblocks/react-tiptap";
import { useEditor, EditorContent } from "@tiptap/react";

function TextEditor() {
  const liveblocks = useLiveblocksExtension();

  const editor = useEditor({
    extensions: [
      liveblocks,
      // ...
    ],
  });

  return (
    <div>
      <EditorContent editor={editor} />
      // +++
      <FloatingComposer editor={editor} style={{ width: "350px" }} />
      // +++
      <FloatingThreads editor={editor} style={{ width: "350px" }} />
    </div>
  );
}

----------------------------------------

TITLE: Using useLostConnectionListener Hook to Handle Connection Issues
DESCRIPTION: Shows how to use the useLostConnectionListener hook to handle exceptional situations where a connection is lost. This enables creating better UIs that inform users about connection status and recovery attempts.

LANGUAGE: ts
CODE:
import { toast } from "my-preferred-toast-library";

function App() {
  useLostConnectionListener((event) => {
    switch (event) {
      case "lost":
        toast.warn("Still trying to reconnect...");
        break;

      case "restored":
        toast.success("Successfully reconnected again!");
        break;

      case "failed":
        toast.error("Could not restore the connection");
        break;
    }
  });
}

----------------------------------------

TITLE: Using useMutation with Presence in Liveblocks React
DESCRIPTION: Demonstrates how to use the useMutation hook in Liveblocks to delete shapes selected by the current user. The mutation uses current presence state and updates storage and presence accordingly.

LANGUAGE: tsx
CODE:
const deleteSelectedShapes = useMutation(
  // You can use current "self" or "others" state in the mutation
  // +++
  ({ storage, self, others, setMyPresence }) => {
    // +++
    // Delete the selected shapes
    const shapes = storage.get("shapes");
    // +++
    for (const shapeId of self.presence.selectedShapeIds) {
      // +++
      shapes.delete(shapeId);
    }

    // Clear the current selection
    setMyPresence({ selectedShapeIds: [] });
  },
  []
);

// JSX
return <button onClick={deleteSelectedShapes} />;

----------------------------------------

TITLE: Implementing React Suspense with Liveblocks
DESCRIPTION: This code demonstrates how to use React's Suspense component with Liveblocks. The useStorage hook from @liveblocks/react/suspense is used to access storage data, with loading states handled by Suspense's fallback.

LANGUAGE: tsx
CODE:
import { LiveObject } from "@liveblocks/client";
import { Suspense } from "react";
import { RoomProvider, useStorage } from "@liveblocks/react/suspense";

function App() {
  const scientist = useStorage((root) => root.scientist);

  return (
    <>
      <input value={scientist.firstName} />
      <input value={scientist.lastName} />
    </>
  );
}

function Index() {
  return (
    <RoomProvider
      id="my-room-id"
      initialPresence={/* ... */}
      initialStorage={{
        scientist: new LiveObject({
          firstName: "Marie",
          lastName: "Curie",
        }),
      }}
    >
      <Suspense fallback={<div>Loading</div>}>
        <App />
      </Suspense>
    </RoomProvider>
  );
}

----------------------------------------

TITLE: ESLint Configuration for useMutation in Liveblocks
DESCRIPTION: ESLint configuration example for checking dependency arrays in useMutation hooks. Adds useMutation to the additionalHooks in the react-hooks/exhaustive-deps rule.

LANGUAGE: js
CODE:
{
  "rules": {
    // ...
    "react-hooks/exhaustive-deps": ["warn", {
      "additionalHooks": "useMutation"
    }]
  }
}

----------------------------------------

TITLE: Subscribing to Storage Updates in TypeScript
DESCRIPTION: Demonstrates how to access and subscribe to changes in the Storage, using the type definitions previously set up. This shows how to get properly typed data from the storage.

LANGUAGE: typescript
CODE:
const { root } = await room.getStorage();
const animals = root.get("animals");

const unsubscribe = room.subscribe(animals, (updatedAnimals) => {
  // LiveList<[{ name: "Fido" }, { name: "Felix" }]>
  console.log(updatedAnimals);
});

----------------------------------------

TITLE: Fetching Inbox Notifications with Client.getInboxNotifications in TypeScript
DESCRIPTION: Shows how to retrieve the current user's inbox notifications and their associated threads. The method returns the notifications, threads, and a requestedAt timestamp for subsequent polling.

LANGUAGE: typescript
CODE:
const { inboxNotifications, threads, requestedAt } =
  await client.getInboxNotifications();

// [{ id: "in_fwh3d4...", kind: "thread", }, ...]
console.log(inboxNotifications);

// [{ id: "th_s436g8...", type: "thread" }, ...]
console.log(threads);

----------------------------------------

TITLE: Accessing Undo/Redo Functions with Zustand and Liveblocks
DESCRIPTION: This example shows how to access undo and redo functions from a Liveblocks room through a Zustand store and implement them as buttons in a React component.

LANGUAGE: tsx
CODE:
import useStore from "../store";

function YourComponent() {
  const undo = useStore((state) => state.liveblocks.room?.history.undo);
  const redo = useStore((state) => state.liveblocks.room?.history.redo);

  return (
    <>
      <button onClick={undo}>Undo</button>
      <button onClick={redo}>Redo</button>
    </>
  );
}

----------------------------------------

TITLE: Using useIsInsideRoom Hook for Conditional Rendering in React Components
DESCRIPTION: This example demonstrates how to use the useIsInsideRoom hook to conditionally render components based on whether they're inside a Liveblocks room. It shows a header component that only displays live avatars when users are connected to a room.

LANGUAGE: tsx
CODE:
import { useIsInsideRoom, useOthers } from "@liveblocks/react/suspense";

function Header() {
  // +++
  const isInsideRoom = useIsInsideRoom();
  // +++

  return (
    <div>
      // +++
      {isInsideRoom ? <LiveAvatars /> : null}
      // +++
      <MyAvatar />
    </div>
  );
}

function LiveAvatars() {
  const others = useOthers();
  return others.map((other) => <img src={other.info.picture} />);
}

----------------------------------------

TITLE: Handling Custom Notification Kinds with useNotificationSettings in React
DESCRIPTION: This example shows how to implement notification settings for both standard and custom notification kinds ($documentInvite). It demonstrates checking if a notification channel exists before creating UI controls for its settings.

LANGUAGE: tsx
CODE:
import { useNotificationSettings } from "@liveblocks/react";

function NotificationSettings() {
  const [{ isLoading, error, settings }, updateSettings] =
    useNotificationSettings();

  if (isLoading || error) {
    return null;
  }

  return (
    <>
      {settings.email ? (
        <>
          // +++
          <label>
            Receive document invites notifications by email
            <input
              type="checkbox"
              checked={settings.email.$documentInvite}
              onChange={(e) =>
                updateSettings({ email: { $documentInvite: e.target.checked } })
              }
            />
          </label>
          // +++
          <label>
            Receive thread notifications by email
            <input
              type="checkbox"
              checked={settings.email.thread}
              onChange={(e) =>
                updateSettings({ email: { thread: e.target.checked } })
              }
            />
          </label>
        </>
      ) : null}
    </>
  );
}

----------------------------------------

TITLE: Accessing All Users' Awareness States via states Property
DESCRIPTION: Shows how to access the Map containing all users' awareness states through the states property.

LANGUAGE: typescript
CODE:
// A Map of each user's awareness state
const states: Map<number, unknown> = awareness.states;

----------------------------------------

TITLE: Joining a Liveblocks Room
DESCRIPTION: Code to enter a Liveblocks room, which is a virtual space where users collaborate. Returns the room object and a leave function to disconnect.

LANGUAGE: js
CODE:
const { room, leave } = client.enterRoom("my-room");

----------------------------------------

TITLE: Rendering the To-Do List with Add and Delete Functionality
DESCRIPTION: Implements the UI for displaying to-do items, adding new items on Enter key press, and deleting items. The component uses Redux actions to manage state changes that are automatically synced across clients by Liveblocks.

LANGUAGE: javascript
CODE:
import React, { useEffect } from "react";
import { useDispatch, useSelector } from "react-redux";
import { actions } from "@liveblocks/redux";

import { setDraft, addTodo, deleteTodo } from "./store";

import "./App.css";

/* WhoIsHere */
/* SomeoneIsTyping */

export default function App() {
  const todos = useSelector((state) => state.todos);
  const draft = useSelector((state) => state.draft);
  const dispatch = useDispatch();

  useEffect(() => {
    dispatch(actions.enterRoom("redux-demo-room"));

    return () => {
      dispatch(actions.leaveRoom("redux-demo-room"));
    };
  }, [dispatch]);

  return (
    <div className="container">
      <WhoIsHere />
      <input
        className="input"
        type="text"
        placeholder="What needs to be done?"
        value={draft}
        onChange={(e) => dispatch(setDraft(e.target.value))}
        onKeyDown={(e) => {
          if (e.key === "Enter") {
            dispatch(addTodo());
          }
        }}
      ></input>
      <SomeoneIsTyping />
      {todos.map((todo, index) => {
        return (
          <div className="todo_container" key={index}>
            <div className="todo">{todo.text}</div>
            <button
              className="delete_button"
              onClick={() => dispatch(deleteTodo(index))}
            >
              ✕
            </button>
          </div>
        );
      })}
    </div>
  );
}

----------------------------------------

TITLE: Configuring Liveblocks Zustand Store with Presence
DESCRIPTION: Sets up a Zustand store with Liveblocks middleware to track when a user is typing. The store includes draft text and an isTyping flag that is synced with Liveblocks Presence using presenceMapping.

LANGUAGE: typescript
CODE:
import create from "zustand";
import { createClient } from "@liveblocks/client";
import { liveblocks } from "@liveblocks/zustand";
import type { WithLiveblocks } from "@liveblocks/zustand";

type State = {
  draft: string;
  isTyping: boolean;
  setDraft: (draft: string) => void;
};

const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

const useStore = create<WithLiveblocks<State>>()(
  liveblocks(
    (set) => ({
      draft: "",
      isTyping: false,
      setDraft: (draft) => set({ draft, isTyping: draft !== "" }),
    }),
    {
      client,
      presenceMapping: { isTyping: true },
    }
  )
);

export default useStore;

----------------------------------------

TITLE: Nesting Liveblocks Data Structures with TypeScript Type Definitions
DESCRIPTION: Shows how to create complex nested data structures using LiveObject, LiveList, and LiveMap with proper TypeScript typing. Defines types for a Person object containing a list of pets.

LANGUAGE: typescript
CODE:
import { LiveObject, LiveList, LiveMap } from "@liveblocks/client";

type Person = LiveObject<{
  name: string;
  pets: LiveList<string>;
}>;

declare global {
  interface Liveblocks {
    Storage: {
      people: LiveMap<string, Person>;
    };
  }
}

----------------------------------------

TITLE: Using useOthersMapped Hook in Liveblocks React
DESCRIPTION: The useOthersMapped hook extracts data for every user in the room using a selector at the item level. It returns an array of pairs of connection IDs and selected data, making it easy to iterate over and render UI elements for each user.

LANGUAGE: tsx
CODE:
// Example 1
const others = useOthersMapped((other) => other.presence.cursor);
// [
//   [2, { x: 27, y: -8 }],
//   [3, { x: 0, y: 19 }],
// ]

// Example 2
const others = useOthersMapped(
  (other) => ({
    avatar: other.info.avatar,
    isTyping: other.presence.isTyping,
  }),
  shallow // 👈
);

// [
//   [2, { avatar: 'https://...', isTyping: true }],
//   [3, { avatar: null, isTyping: false }],
// ]

----------------------------------------

TITLE: Updating User Presence with useUpdateMyPresence
DESCRIPTION: This snippet demonstrates how to update a user's presence in real-time using the useUpdateMyPresence hook. It tracks the mouse position on pointer movements and sets the cursor to null when the pointer leaves the element.

LANGUAGE: tsx
CODE:
import { useUpdateMyPresence } from "@liveblocks/react/suspense";

function App() {
  const updateMyPresence = useUpdateMyPresence();

  return (
    <div
      style={{ width: "100vw", height: "100vh" }}
      onPointerMove={(e) =>
        updateMyPresence({ cursor: { x: e.clientX, y: e.clientY } })
      }
      onPointerLeave={() => updateMyPresence({ cursor: null })}
    />
  );
}

----------------------------------------

TITLE: ThreadCreatedEvent Schema in TypeScript
DESCRIPTION: TypeScript schema and example for the ThreadCreatedEvent webhook. This event is triggered when a new discussion thread is created in a room.

LANGUAGE: typescript
CODE:
// Schema
type ThreadCreatedEvent = {
  type: "threadCreated";
  data: {
    projectId: string;
    roomId: string;
    threadId: string;
    createdAt: string;
    createdBy: string;
  };
};

// Example
const threadCreatedEvent = {
  type: "threadCreated",
  data: {
    projectId: "my-project-id",
    roomId: "my-room-id",
    threadId: "my-thread-id",
    createdAt: "2021-10-06T01:45:56.558Z",
    createdBy: "my-user-id",
  },
};

----------------------------------------

TITLE: Getting or Creating a Room with Advanced Options
DESCRIPTION: Shows how to get or create a room with advanced configuration options, including permissions for groups and users, as well as custom metadata for the room.

LANGUAGE: typescript
CODE:
const room = await liveblocks.getOrCreateRoom("my-room-id", {
  // The default room permissions. `[]` for private, `["room:write"]` for public.
  defaultAccesses: [],

  // Optional, the room's group ID permissions
  groupsAccesses: {
    design: ["room:write"],
    engineering: ["room:presence:write", "room:read"],
  },

  // Optional, the room's user ID permissions
  usersAccesses: {
    "my-user-id": ["room:write"],
  },

  // Optional, custom metadata to attach to the room
  metadata: {
    myRoomType: "whiteboard",
  },
});

----------------------------------------

TITLE: Setting up LiveblocksProvider in App Component
DESCRIPTION: Implementation of LiveblocksProvider in an App component. This wraps the CollaborativeApplication component, enabling Liveblocks functionality throughout the application.

LANGUAGE: tsx
CODE:
return (
  <LiveblocksProvider publicApiKey={publicApiKey}>
    <CollaborativeApplication />
  </LiveblocksProvider>
);

----------------------------------------

TITLE: Receiving Broadcast Events in Liveblocks Room
DESCRIPTION: Demonstrates how to listen for events broadcast by other users using Room.subscribe("event"). The callback provides the event data and information about the sender.

LANGUAGE: typescript
CODE:
// User 1
room.broadcastEvent({ type: "REACTION", emoji: "🔥" });

// User 2
const unsubscribe = room.subscribe("event", ({ event, user, connectionId }) => {
  //                                                  ^^^^ User 1
  if (event.type === "REACTION") {
    // Do something
  }
});

----------------------------------------

TITLE: Subscribing to Other Users in Liveblocks
DESCRIPTION: Shows how to subscribe to presence updates from other users in the room, receiving an array of all connected users and event information.

LANGUAGE: typescript
CODE:
const unsubscribe = room.subscribe("others", (others, event) => {
  // Do something
});

----------------------------------------

TITLE: Creating a Room with Advanced Options using Liveblocks.createRoom
DESCRIPTION: Demonstrates how to create a room with advanced configuration options, including permissions for groups and users, as well as custom metadata for the room.

LANGUAGE: typescript
CODE:
const room = await liveblocks.createRoom("my-room-id", {
  // The default room permissions. `[]` for private, `["room:write"]` for public.
  defaultAccesses: [],

  // Optional, the room's group ID permissions
  groupsAccesses: {
    design: ["room:write"],
    engineering: ["room:presence:write", "room:read"],
  },

  // Optional, the room's user ID permissions
  usersAccesses: {
    "my-user-id": ["room:write"],
  },

  // Optional, custom metadata to attach to the room
  metadata: {
    myRoomType: "whiteboard",
  },
});

----------------------------------------

TITLE: Using Connection Status for UI Indicators in Liveblocks
DESCRIPTION: Example of implementing a connection status indicator using the status subscription. Updates a visual indicator based on the connection state of the Liveblocks room.

LANGUAGE: typescript
CODE:
let indicator = "⚪";

const unsubscribe = room.subscribe("status", (status) => {
  switch (status) {
    case "connecting":
      indiciator = "🟡";
      break;
    case "connected":
      indicator = "🟢";
      break;
    // ...
  }
});

----------------------------------------

TITLE: Setting Up Collaborative BlockNote Editor with Liveblocks
DESCRIPTION: Creating a collaborative text editor using BlockNote and Liveblocks. Uses useCreateBlockNoteWithLiveblocks hook to enable real-time collaboration in the editor.

LANGUAGE: tsx
CODE:
"use client";

import { useCreateBlockNoteWithLiveblocks } from "@liveblocks/react-blocknote";
import { BlockNoteView } from "@blocknote/mantine";
import { Threads } from "./Threads";

export function Editor() {
  const editor = useCreateBlockNoteWithLiveblocks({});

  return (
    <div>
      <BlockNoteView editor={editor} className="editor" />
      <Threads editor={editor} />
    </div>
  );
}

----------------------------------------

TITLE: Advanced TypeScript Type Definitions with Examples for Liveblocks
DESCRIPTION: More detailed TypeScript type definitions for Liveblocks with example values. This shows how to define types for various Liveblocks features like Presence, Storage with LiveList, user metadata, and custom events.

LANGUAGE: typescript
CODE:
import { LiveList } from "@liveblocks/client";

declare global {
  interface Liveblocks {
    // Each user's Presence
    Presence: {
      // Example, real-time cursor coordinates
      cursor: { x: number; y: number };
    };

    // The Storage tree for the room
    Storage: {
      // Example, a conflict-free list
      animals: LiveList<string>;
    };

    UserMeta: {
      id: string;
      // Custom user info set when authenticating with a secret key
      info: {
        // Example properties
        name: string;
        avatar: string;
      };
    };

    // Custom events
    // Example has two events, using a union
    RoomEvent: { type: "PLAY" } | { type: "REACTION"; emoji: "🔥" };

    // Custom metadata set on threads
    ThreadMetadata: {
      // Example, attaching coordinates to a thread
      x: number;
      y: number;
    };

    // Custom room info set with resolveRoomsInfo
    RoomInfo: {
      // Example, rooms with a title and url
      title: string;
      url: string;
    };

    // Custom activities data for custom notification kinds
    ActivitiesData: {
      // Example, a custom $alert kind
      $alert: {
        title: string;
        message: string;
      };
    };
  }
}

// Necessary if you have no imports/exports
export {};

----------------------------------------

TITLE: Implementing Basic Canvas with Rectangle Rendering in React
DESCRIPTION: Creates a canvas component that displays rectangles from the synchronized shapes state. It includes a Rectangle component for rendering individual shapes with their position and color attributes.

LANGUAGE: jsx
CODE:
import { useEffect } from "react";
import "./App.css";
import { useDispatch, useSelector } from "react-redux";
import { actions } from "@liveblocks/redux";

const roomId = "redux-whiteboard";

export default function App() {
  const shapes = useSelector((state) => state.shapes);
  const isLoading = useSelector((state) => state.liveblocks.isStorageLoading);
  const dispatch = useDispatch();

  useEffect(() => {
    dispatch(actions.enterRoom(roomId));

    return () => {
      dispatch(actions.leaveRoom());
    };
  }, [dispatch]);

  if (isLoading) {
    return <div className="loading">Loading</div>;
  }

  return (
    <div className="canvas">
      {Object.entries(shapes).map(([shapeId, shape]) => {
        return <Rectangle key={shapeId} shape={shape} />;
      })}
    </div>
  );
}

const Rectangle = ({ shape }) => {
  return (
    <div
      className="rectangle"
      style={{
        transform: `translate(${shape.x}px, ${shape.y}px)`,
        backgroundColor: shape.fill ? shape.fill : "#CCC",
      }}
    ></div>
  );
};

----------------------------------------

TITLE: Updating a LiveObject with Multiple Properties in TypeScript
DESCRIPTION: Demonstrates how to use the update method to add or update multiple properties of a LiveObject at once. This method will not apply nested changes to other Storage types.

LANGUAGE: typescript
CODE:
const object = new LiveObject({ firstName: "Grace" });
object.update({ lastName: "Hopper", job: "Computer Scientist" });

// { firstName: "Grace", lastName: "Hopper", job: "Computer Scientist" }
object.toImmutable();

----------------------------------------

TITLE: Subscribing to Room Connection Status in Liveblocks
DESCRIPTION: Shows how to subscribe to WebSocket connection status updates in a Liveblocks room. The callback is called whenever the connection status changes, with states like 'initial', 'connecting', 'connected', etc.

LANGUAGE: typescript
CODE:
const unsubscribe = room.subscribe("status", (status) => {
  // "connected"
  console.log(status);
});

----------------------------------------

TITLE: Configuring Room Permissions with Liveblocks.upsertRoom in TypeScript
DESCRIPTION: Sets detailed room permissions including default accesses, group permissions, user permissions, and custom metadata. Useful for creating rooms with granular access control.

LANGUAGE: typescript
CODE:
const room = await liveblocks.upsertRoom("my-room-id", {
  update: {
    // The default room permissions. `[]` for private, `["room:write"]` for public.
    defaultAccesses: [],

    // Optional, the room's group ID permissions
    groupsAccesses: {
      design: ["room:write"],
      engineering: ["room:presence:write", "room:read"],
    },

    // Optional, the room's user ID permissions
    usersAccesses: {
      "my-user-id": ["room:write"],
    },

    // Optional, custom metadata to attach to the room
    metadata: {
      myRoomType: "whiteboard",
    },
  },
});

----------------------------------------

TITLE: Clearing All Elements from LiveList in TypeScript
DESCRIPTION: Demonstrates how to remove all elements from a LiveList using the clear() method. This operation empties the list while maintaining the structure itself.

LANGUAGE: typescript
CODE:
const list = new LiveList(["adrien", "jonathan"]);
list.clear();

// []
list.toImmutable();

----------------------------------------

TITLE: Real-world User Resolution with API Integration
DESCRIPTION: Practical implementation of resolveUsers that fetches user data from a backend API. This pattern should be used in production applications to retrieve actual user information based on the provided IDs.

LANGUAGE: tsx
CODE:
<LiveblocksProvider
  resolveUsers={async ({ userIds }) => {
    // Get users from your back end
    const users = await __fetchUsers__(userIds);

    // Return a list of users
    return users;
  }}

  // ...
/>;

----------------------------------------

TITLE: Setting up Authentication Endpoint in Nuxt.js
DESCRIPTION: Creates a Nuxt.js API endpoint that handles authentication by implementing security logic and defining room access permissions. This code uses naming patterns with wildcards to grant different access levels to rooms based on organization and group membership.

LANGUAGE: typescript
CODE:
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export default defineEventHandler(async (event) => {
// Get the current user from your database
  const user = __getUserFromDB__(event);

  // Start an auth session inside your endpoint
  const session = liveblocks.prepareSession(
    user.id,
    { userInfo: user.metadata },  // Optional
  );

  // Use a naming pattern to allow access to rooms with wildcards
  // Giving the user read access on their org, and write access on their group
  session.allow(`${user.organization}:*`, session.READ_ACCESS);
  session.allow(`${user.organization}:${user.group}:*`, session.FULL_ACCESS);

  // Authorize the user and return the result
  const { status, body } = await session.authorize();
  return body;
})

----------------------------------------

TITLE: LiveblocksProvider Component Usage Example
DESCRIPTION: Example of using the LiveblocksProvider component with a public API key. This component needs to wrap any Liveblocks functionality in a React application.

LANGUAGE: tsx
CODE:
<LiveblocksProvider publicApiKey="pk_s9bs7fl...">

----------------------------------------

TITLE: Using invalidateUsers Resolver in TypeScript
DESCRIPTION: Shows how to invalidate cached user data using the invalidateUsers resolver. This can be used to refresh user data without requiring a page reload.

LANGUAGE: typescript
CODE:
// Invalidate all users
client.resolvers.invalidateUsers();

// Only invalidate "user-0" and "user-1"
client.resolvers.invalidateUsers(["user-0", "user-1"]);

----------------------------------------

TITLE: Using invalidateRoomsInfo Resolver in TypeScript
DESCRIPTION: Demonstrates how to invalidate cached room information using the invalidateRoomsInfo resolver. This can refresh room data without requiring a page reload.

LANGUAGE: typescript
CODE:
// Invalidate all rooms
client.resolvers.invalidateRoomsInfo();

// Only invalidate "room-0" and "room-1"
client.resolvers.invalidateRoomsInfo(["room-0", "room-1"]);

----------------------------------------

TITLE: Using Literal Types in Liveblocks Schema
DESCRIPTION: Example of using literal types to restrict values to specific options. Defines an Event type with a statusCode limited to 200 or 400, and a Storage with a theme restricted to light or dark.

LANGUAGE: typescript
CODE:
type Event {
  statusCode: 200 | 400
  info: string
}

type Storage {
  theme: "light" | "dark"
  history: LiveList<Event>
}

----------------------------------------

TITLE: Adding Custom User Information in resolveUsers Function
DESCRIPTION: Example of returning custom user information fields such as color from the resolveUsers function. This demonstrates how to extend the standard user object with application-specific properties that can be accessed throughout the application.

LANGUAGE: tsx
CODE:
import { LiveblocksProvider } from "@liveblocks/react/suspense";

function App() {
  return (
    <LiveblocksProvider
      resolveUsers={async ({ userIds }) => {
        // ["marc@example.com"];
        console.log(userIds);

        return [
          {
            name: "Marc",
            avatar: "https://example.com/marc.png",
            // +++
            color: "purple",
            // +++
          },
        ];
      }}

      // Other props
      // ...
    >
      {/* children */}
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Different selector patterns with useStorage in React
DESCRIPTION: Shows various ways to use useStorage selectors: selecting a direct child, a nested property, computing a value, and merging arrays with shallow comparison.

LANGUAGE: tsx
CODE:
const child = useStorage((root) => root.child);
const nested = useStorage((root) => root.child.nested);
const total = useStorage((root) => root.x + root.y);
const merged = useStorage((root) => [...root.items, ...root.more], shallow);

----------------------------------------

TITLE: Uploading Attachments with Room.uploadAttachment in TypeScript
DESCRIPTION: Demonstrates how to upload a local attachment to Liveblocks. The method requires a prepared attachment and returns the uploaded attachment. It also supports an optional AbortSignal for canceling uploads.

LANGUAGE: typescript
CODE:
const attachment = room.prepareAttachment(file);
await room.uploadAttachment(attachment);

----------------------------------------

TITLE: Implementing a Collaborative Text Input in React
DESCRIPTION: Creates a reactive input field that displays the current name value from storage and updates it in real-time when changed. This code should be added to Room.tsx.

LANGUAGE: tsx
CODE:
return (
  <input
    type="text"
    value={person.name}
    onChange={(e) => updateName(e.target.value)}
  />
);

----------------------------------------

TITLE: Setting up Authentication Endpoint in Next.js Pages Directory
DESCRIPTION: Alternative approach for creating an authentication endpoint using the older API routes format in Next.js pages directory. This performs the same function of identifying and authorizing users.

LANGUAGE: typescript
CODE:
import { Liveblocks } from "@liveblocks/node";
import type { NextApiRequest, NextApiResponse } from "next";

const API_KEY = "{{SECRET_KEY}}";

const liveblocks = new Liveblocks({
  secret: API_KEY!,
});

export default async function handler(request: NextApiRequest, response: NextApiResponse) {
  // Get the current user from your database
  const user = __getUserFromDB__(request);

  // Identify the user and return the result
  const { status, body } = await liveblocks.identifyUser(
    {
      userId: user.id,
      groupIds, // Optional
    },
    { userInfo: user.metadata },
  );

  // Authorize the user and return the result
  const { status, body } = await session.authorize();
  response.status(status).send(body);
}

----------------------------------------

TITLE: Verifying Liveblocks Webhook Requests with @liveblocks/node
DESCRIPTION: Implementation of webhook verification using the WebhookHandler from @liveblocks/node package. The code validates incoming requests by checking the signature using the webhook secret.

LANGUAGE: typescript
CODE:
import { WebhookHandler } from "@liveblocks/node";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // Update database
  // ...

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Setting up Broadcast Event Hook in Room Component
DESCRIPTION: Implements the useBroadcastEvent hook in the Room component to enable broadcasting events to other users. This hook provides a function that sends events to all users currently connected to the room.

LANGUAGE: tsx
CODE:
// Broadcast event hook
const broadcast = useBroadcastEvent();

----------------------------------------

TITLE: Listening for User Events in Liveblocks Room
DESCRIPTION: Shows how to handle different event types when listening to the 'others' event. Handles user enter/leave events, presence updates, and connection resets.

LANGUAGE: typescript
CODE:
const unsubscribe = room.subscribe("others", (others, event) => {
  if (event.type === "leave") {
    // A user has left the room
    // event.user;
  }

  if (event.type === "enter") {
    // A user has entered the room
    // event.user;
  }

  if (event.type === "update") {
    // A user has updated
    // event.user;
    // event.updates;
  }

  if (event.type === "reset") {
    // A disconnection has occurred and others has reset
  }
});

----------------------------------------

TITLE: Using useUpdateRoomNotificationSettings hook in React
DESCRIPTION: Demonstrates how to update notification settings for the current room. Provides the same update functionality as useRoomNotificationSettings but without retrieving the current settings.

LANGUAGE: tsx
CODE:
import { useUpdateRoomNotificationSettings } from "@liveblocks/react/suspense";

const updateRoomNotificationSettings = useUpdateRoomNotificationSettings();

// No longer receive thread notifications in this room
updateSettings({
  threads: "none",
});

----------------------------------------

TITLE: Resolving Room IDs to Room Information
DESCRIPTION: Configures the Liveblocks client with a function to resolve room IDs into meaningful room information for notifications. This helps display user-friendly room names instead of IDs in notification components.

LANGUAGE: tsx
CODE:
import { createClient } from "@liveblocks/client";

const client = createClient({
  resolveRoomsInfo: async ({ roomIds }) => {
    const documentsData = await __getDocumentsFromDB__(roomIds);

    return documentsData.map((documentData) => ({
      name: documentData.name,
      // url: documentData.url,
    }));
  },

  // Other options
  // ...
});

----------------------------------------

TITLE: Integrating Liveblocks Room in Next.js Page Component
DESCRIPTION: Example of how to incorporate the Liveblocks Room component into a Next.js page.tsx file. This setup wraps the collaborative application components inside the Room component.

LANGUAGE: tsx
CODE:
import { Room } from "./Room";
import { CollaborativeApp } from "./CollaborativeApp";

export default function Page() {
  return (
    <Room>
      <CollaborativeApp />
    </Room>
  );
}

----------------------------------------

TITLE: Updating a Room with Advanced Options
DESCRIPTION: Demonstrates how to update various properties on a room, including permissions and metadata. Only the properties being updated need to be specified, and setting a property to null will delete it.

LANGUAGE: typescript
CODE:
const room = await liveblocks.updateRoom("my-room-id", {
  // Optional, update the default room permissions. `[]` for private, `["room:write"]` for public.
  defaultAccesses: [],

  // Optional, update the room's group ID permissions
  groupsAccesses: {
    design: ["room:write"],
    engineering: ["room:presence:write", "room:read"],
  },

  // Optional, update the room's user ID permissions
  usersAccesses: {
    "my-user-id": ["room:write"],
  },

  // Optional, custom metadata to update on the room
  metadata: {
    myRoomType: "whiteboard",
  },
});

----------------------------------------

TITLE: Constructing a CommentBody for Liveblocks Comments
DESCRIPTION: Demonstrates how to create a properly formatted CommentBody object for use with createComment or editComment methods. The body consists of an array of paragraphs with text nodes that can include formatting.

LANGUAGE: tsx
CODE:
import { CommentBody } from "@liveblocks/node";

const body: CommentBody = {
  version: 1,
  content: [
    {
      type: "paragraph",
      children: [{ text: "Hello " }, { text: "world", bold: true }],
    },
  ],
};

const comment = await liveblocks.createComment({
  roomId: "my-room-id",
  threadId: "th_d75sF3...",

  data: {
    // The comment's body, uses the `CommentBody` type
    body,

    // ...
  },
});

----------------------------------------

TITLE: Using Suspense Hooks with ClientSideSuspense in React
DESCRIPTION: Shows how to use Liveblocks Suspense hooks with the ClientSideSuspense component to handle loading states. When used this way, components will only render once their hook contents have fully loaded.

LANGUAGE: tsx
CODE:
import { ClientSideSuspense, useStorage } from "@liveblocks/react/suspense";

function App() {
  <ClientSideSuspense fallback={<div>Loading…</div>}>
    <Component />
  </ClientSideSuspense>;
}

function Component() {
  // `animals` is always defined
  const animals = useStorage((root) => root.animals);

  // ...
}

----------------------------------------

TITLE: Advanced Comment Formatting with HTML and User Resolution in TypeScript
DESCRIPTION: Shows how to use stringifyCommentBody with options to maintain formatting by converting to HTML and replace user IDs with actual user names. This approach preserves text formatting like bold and properly displays user mentions.

LANGUAGE: typescript
CODE:
import { stringifyCommentBody } from "@liveblocks/node";

// Format comment text into an HTML string
const htmlComment = await stringifyCommentBody(comment.body, {
  // Transform into HTML
  format: "html",

  // Provider user information
  async resolveUsers({ userIds }) {
    // ["emil.joyce@example.com", ...]
    console.log(userIds);

    // Return each user's name
    [{ name: "Emil Joyce" } /*, ... */];
  },
});

// "<p>Thank you <b>so much</b> <span data-mention>@Emil Joyce</span>!</p>"
console.log(stringComment);

----------------------------------------

TITLE: Using Redo in Liveblocks History (TypeScript)
DESCRIPTION: Demonstrates how to use the redo function to restore the last undone operation. This only restores changes made by the current client and not operations made by other clients.

LANGUAGE: typescript
CODE:
const person = new LiveObject();
person.set("name", "Pierre");
person.set("name", "Jonathan");

room.history.undo();
room.history.redo();

// "Jonathan"
root.get("name");

----------------------------------------

TITLE: Setting Global Overrides with LiveblocksUIConfig in React
DESCRIPTION: Shows how to customize component strings and localization properties globally using the LiveblocksUIConfig component. This example demonstrates setting the locale to French and overriding the unknown user text.

LANGUAGE: tsx
CODE:
import { LiveblocksUIConfig } from "@liveblocks/react-ui";

export function App() {
  return (
    <LiveblocksUIConfig
      overrides={{ locale: "fr", USER_UNKNOWN: "Anonyme" /* ... */ }}
    >
      {/* ... */}
    </LiveblocksUIConfig>
  );
}

----------------------------------------

TITLE: Batching Changes for Unified History Management in Liveblocks (TypeScript)
DESCRIPTION: Shows how batching groups multiple changes into a single history state, allowing multiple modifications to be undone together as a single operation rather than individually.

LANGUAGE: typescript
CODE:
const { root } = await room.getStorage();
const pet = root.set("pet", new LiveObject({ name: "Fido", age: 5 }));

// ✅ Batch groups changes into one
room.batch(() => {
  pet.set("name", "Felix");
  pet.set("age", 10);
});

// { name: "Felix", age: 10 }
pet.toImmutable();

room.history.undo();

// { name: "Fido", age: 5 }
pet.toImmutable();

----------------------------------------

TITLE: Using Nested Data Structures in Liveblocks Storage
DESCRIPTION: Demonstrates how to initialize and work with nested data structures in Liveblocks Storage. This example adds a LiveList of pets within the scientist LiveObject.

LANGUAGE: typescript
CODE:
initialStorage={{
  scientist: new LiveObject({
    pets: new LiveList(["🐶", "🐱", "🐷"]),
    firstName: "Marie",
    lastName: "Curie",
  })
}}

----------------------------------------

TITLE: Using useMutation to Modify Storage LiveList
DESCRIPTION: Shows how to use the useMutation hook to modify a LiveList in storage, adding new items to the list and accessing the mutable storage object.

LANGUAGE: tsx
CODE:
import { useMutation } from "@liveblocks/react/suspense";

function App() {
  const addAnimal = useMutation(({ storage }) => {
    const animals = storage.get("animals");

    // LiveList<["Fido"]>
    console.log(animals);

    animals.push("Felix");

    // LiveList<["Fido", "Felix"]>
    console.log(animals);
  });

  return <button onClick={addAnimal}>Add animal</button>;
}

----------------------------------------

TITLE: Marking a Thread as Unresolved in TypeScript
DESCRIPTION: Example of using the room.markThreadAsUnresolved method to change a thread's status back to unresolved. This method takes a thread ID and returns nothing.

LANGUAGE: ts
CODE:
await room.markThreadAsUnresolved("th_xxx");

----------------------------------------

TITLE: Filtering Rooms with Liveblocks.iterRooms
DESCRIPTION: Demonstrates how to apply various filters when using iterRooms to iterate through rooms, including filtering by group IDs, user IDs, and using advanced query options.

LANGUAGE: typescript
CODE:
const roomsIterator = await liveblocks.iterRooms({
  // Optional, filter for rooms that allow entry to group ID(s) in `groupsAccesses`
  groupIds: ["engineering", "design"],

  // Optional, filter for rooms that allow entry to a user's ID in `usersAccesses`
  userId: "my-user-id",

  // Optional, use advanced filtering
  query: {
    // Optional, filter for rooms with an ID that starts with specific string
    roomId: {
      startsWith: "liveblocks:",
    },
    // Optional, filter for rooms with custom metadata in `metadata`
    metadata: {
      roomType: "whiteboard",
    },
  },
});

for await (const room of roomsIterator) {
  // { type: "room", id: "my-room-id", metadata: {...}, ... }
  console.log(room);
}

----------------------------------------

TITLE: Converting from createRoomContext to Global Type Definitions
DESCRIPTION: Example showing how to migrate from the old createRoomContext pattern to the new global Liveblocks type definitions approach.

LANGUAGE: tsx
CODE:
// ❌ Before
export const {
  ...
} = createRoomContext<MyPresence, MyStorage, MyUserMeta, MyRoomEvent, MyThreadMetadata>(client);

LANGUAGE: tsx
CODE:
// ✅ After
declare global {
  interface Liveblocks {
    Presence: MyPresence;
    Storage: MyStorage;
    UserMeta: MyUserMeta;
    RoomEvent: MyRoomEvent;
    ThreadMetadata: MyThreadMetadata;
  }
}

----------------------------------------

TITLE: Deploying Collaborative Whiteboard to Vercel
DESCRIPTION: Command to download the whiteboard example and deploy it to Vercel. This streamlines the process of both setting up the example and deploying it to a production environment.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-whiteboard --vercel

----------------------------------------

TITLE: Installing Liveblocks Packages with npm
DESCRIPTION: Installs the required Liveblocks packages (@liveblocks/client, @liveblocks/react, and @liveblocks/react-ui) for adding collaborative commenting functionality to a Next.js application.

LANGUAGE: bash
CODE:
npm install @liveblocks/client @liveblocks/react @liveblocks/react-ui

----------------------------------------

TITLE: Creating a Synchronization Status Badge with useSyncStatus
DESCRIPTION: Demonstrates how to create a synchronization status badge component using the useSyncStatus hook with the smooth option to prevent flickering during rapid status changes.

LANGUAGE: tsx
CODE:
import { useSyncStatus } from "@liveblocks/react/suspense";

function StorageStatusBadge() {
  const syncStatus = useSyncStatus({ smooth: true });

  return <div>{syncStatus === "synchronized" ? "✅ Saved" : "🔄 Saving"}</div>;
}

----------------------------------------

TITLE: Adding a LiveMap to Liveblocks Storage in TypeScript
DESCRIPTION: Demonstrates how to create a LiveMap and add it to the root LiveObject in Liveblocks Storage.

LANGUAGE: typescript
CODE:
import { LiveMap } from "@liveblocks/client";

const { root } = await room.getStorage();

const people = new LiveMap([
  ["vincent", "engineer"],
  ["marc", "designer"],
]);
root.set("people", people);

----------------------------------------

TITLE: Rendering To-Do Items with Real-time Updates in JavaScript
DESCRIPTION: Implementation of the rendering logic for to-do items and subscription to real-time updates from Liveblocks storage. When the todos LiveList changes, the UI is automatically re-rendered.

LANGUAGE: jsx
CODE:
import { createClient, LiveList } from "@liveblocks/client";

const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

async function run() {
  const { room, leave } = client.enterRoom("javascript-todo-app", {
    initialPresence: { isTyping: false },
    initialStorage: { todos: new LiveList() },
  });

  const whoIsHere = document.getElementById("who_is_here");
  const todoInput = document.getElementById("todo_input");
  const someoneIsTyping = document.getElementById("someone_is_typing");
  const todosContainer = document.getElementById("todos_container");

  const { root } = await room.getStorage();

  let todos = root.get("todos");

  room.subscribe("others", (others) => {
    /* ... */
  });

  todoInput.addEventListener("keydown", (e) => {
    /* ... */
  });

  todoInput.addEventListener("blur", () => {
    /* ... */
  });

  function renderTodos() {
    todosContainer.innerHTML = "";

    for (let i = 0; i < todos.length; i++) {
      const todo = todos.get(i);

      const todoContainer = document.createElement("div");
      todoContainer.classList.add("todo_container");

      const todoText = document.createElement("div");
      todoText.classList.add("todo");
      todoText.innerHTML = todo.text;
      todoContainer.appendChild(todoText);

      todosContainer.appendChild(todoContainer);
    }
  }

  room.subscribe(todos, () => {
    renderTodos();
  });

  renderTodos();
}

run();

----------------------------------------

TITLE: Using useStorage selector with automatic subscription in React
DESCRIPTION: This code demonstrates how to use the useStorage hook with a selector function to automatically subscribe a React component to changes in a specific part of Liveblocks storage. The component will only re-render when the selected value (animals array) actually changes.

LANGUAGE: tsx
CODE:
function Component() {
  const animals = useStorage((root) => root.animals);
}

----------------------------------------

TITLE: Typing Storage in Liveblocks
DESCRIPTION: Defines TypeScript types for Liveblocks Storage to enable type checking when working with LiveList structures.

LANGUAGE: typescript
CODE:
import { LiveList } from "@liveblocks/client";

declare global {
  interface Liveblocks {
    Storage: {
      animals: LiveList<{ name: string }>;
    };
  }
}

----------------------------------------

TITLE: Marking All Notifications as Read with Client.markAllInboxNotificationsAsRead in TypeScript
DESCRIPTION: Demonstrates how to mark all of the current user's inbox notifications as read. This method doesn't return any value and doesn't require any arguments.

LANGUAGE: typescript
CODE:
await client.markAllInboxNotificationsAsRead();

----------------------------------------

TITLE: Grouping AI Suggestions with Labels
DESCRIPTION: Shows how to organize AI suggestions into logical groups using SuggestionsLabel components to improve the user interface organization.

LANGUAGE: tsx
CODE:
import { AiToolbar } from "@liveblocks/react-tiptap";

<AiToolbar
  editor={editor}
  suggestions={
    <>
      // +++
      <AiToolbar.SuggestionsLabel>Translation</AiToolbar.SuggestionsLabel>
      // +++
      <AiToolbar.Suggestion>Translate in French</AiToolbar.Suggestion>
      <AiToolbar.Suggestion>Translate in English</AiToolbar.Suggestion>
    </>
  }
/>;

----------------------------------------

TITLE: Using clone Method with LiveList in TypeScript
DESCRIPTION: Shows how to create a deep copy of a LiveList that can be inserted elsewhere in the Storage tree using the clone method.

LANGUAGE: typescript
CODE:
const list = new LiveList(/* ... */);
root.set("a", list);
root.set("b", list.clone());

----------------------------------------

TITLE: Implementing Emoji Reactions with Liveblocks Hooks
DESCRIPTION: Example of creating clickable emoji reactions using Liveblocks hooks. This component displays existing reactions on a comment and allows users to add or remove their reactions.

LANGUAGE: tsx
CODE:
import { CommentData } from "@liveblocks/react-ui";
import {
  useAddReaction,
  useRemoveReaction,
  useSelf,
} from "@liveblocks/react/suspense";

export function MyEmojiReactions({ comment }: { comment: CommentData }) {
  const userId = useSelf().id;
  const addReaction = useAddReaction();
  const removeReaction = useRemoveReaction();

  return (
    <>
      {comment.reactions.map((reaction) => {
        const hasPicked = reaction.users.some((user) => user.id === userId);
        const reactionObject = {
          threadId: comment.threadId,
          commentId: comment.id,
          emoji: reaction.emoji,
        };

        return (
          <button
            key={reaction.emoji}
            onClick={() =>
              hasPicked
                ? removeReaction(reactionObject)
                : addReaction(reactionObject)
            }
            data-picked={hasPicked || undefined /* Use for CSS styling */}
          >
            {reaction.emoji} {reaction.users.length}
          </button>
        );
      })}
    </>
  );
}

----------------------------------------

TITLE: Adding Presence State to History in Liveblocks (TypeScript)
DESCRIPTION: Demonstrates how to add Presence state changes to the history stack, which by default only tracks Storage changes. This allows Presence changes to be undone and redone.

LANGUAGE: typescript
CODE:
room.updatePresence({ color: "blue" }, { addToHistory: true });

----------------------------------------

TITLE: Installing Next.js Application with create-next-app Command
DESCRIPTION: Command to create a new Next.js application with TypeScript support using create-next-app.

LANGUAGE: bash
CODE:
npx create-next-app@latest next-todo-list --typescript

----------------------------------------

TITLE: Deleting a Comment in Liveblocks using TypeScript
DESCRIPTION: Uses the liveblocks.deleteComment method to remove a specific comment from a thread. Requires roomId, threadId, and commentId parameters. If the deleted comment was the last one in the thread, the thread is also deleted.

LANGUAGE: typescript
CODE:
await liveblocks.deleteComment({
  roomId: "my-room-id",
  threadId: "th_d75sF3...",
  commentId: "cm_agH76a...",
});

----------------------------------------

TITLE: Global Type Declaration for Liveblocks in TypeScript
DESCRIPTION: A TypeScript declaration that defines global interfaces for Liveblocks to improve developer experience by allowing you to specify your types globally rather than passing them to each component.

LANGUAGE: typescript
CODE:
declare global {
  interface Liveblocks {
    Presence: Presence;
    Storage: Storage;
  }
}

----------------------------------------

TITLE: Get Storage Document in LSON Format with Liveblocks
DESCRIPTION: Retrieves the contents of a room's Storage tree in the LSON format, which preserves information about conflict-free data types. Returns a structured representation of the Storage data.

LANGUAGE: typescript
CODE:
// Retrieve LSON Storage data
const storage = await liveblocks.getStorageDocument("my-room-id", "plain-lson");

// If this were your Storage type...
declare global {
  interface Liveblocks {
    Storage: {
      names: LiveList<string>;
    };
  }
}

// {
//   liveblocksType: "LiveObject",
//   data: {
//     names: {
//       liveblocksType: "LiveList",
//       data: ["Olivier", "Nimesh"],
//     }
//   }
// }
console.log(storage);

----------------------------------------

TITLE: Installing Liveblocks and Lexical Dependencies
DESCRIPTION: Command to install all required packages for integrating Liveblocks with Lexical in a React application. All Liveblocks packages should use the same version.

LANGUAGE: bash
CODE:
npm install @liveblocks/client @liveblocks/react @liveblocks/react-ui @liveblocks/react-lexical lexical @lexical/react

----------------------------------------

TITLE: Cloning a LiveObject in TypeScript
DESCRIPTION: Shows how to create a deep copy of a LiveObject using the clone method. The cloned object can be inserted elsewhere in the Storage tree.

LANGUAGE: typescript
CODE:
const obj = new LiveObject(/* ... */);
root.set("a", obj);
root.set("b", obj.clone());

----------------------------------------

TITLE: Creating LiveList with Initial Data in TypeScript
DESCRIPTION: Shows how to initialize a LiveList with data upon creation. The example creates a list with two string values that will be immediately available to all connected clients.

LANGUAGE: typescript
CODE:
const list = new LiveList(["adrien", "jonathan"]);

----------------------------------------

TITLE: Using prepareThreadNotificationEmailAsReact with Liveblocks Webhook Events
DESCRIPTION: This code snippet demonstrates how to process a thread notification webhook event to generate React components for email notifications. It handles both unreadMention and unreadReplies notification types by formatting the comment data into React components.

LANGUAGE: tsx
CODE:
import { prepareThreadNotificationEmailAsReact } from "@liveblocks/emails";
import { isThreadNotificationEvent } from "@liveblocks/node";

// Get `liveblocks` and `event` (see "Setup" section)
// ...

if (isThreadNotificationEvent(event)) {
  // +++
  const emailData = await prepareThreadNotificationEmailAsReact(
    liveblocks,
    event
  );
  // +++
  let email;

  switch (emailData.type) {
    case "unreadMention": {
      email = (
        <div>
          <div>
            @{emailData.comment.author.id} at {emailData.comment.createdAt}
          </div>
          <div>{emailData.comment.body}</div>
        </div>
      );
      break;
    }

    case "unreadReplies": {
      email = (
        <div>
          {emailData.comments.map((comment) => (
            <div key={comment.id}>
              <div>
                @{comment.author.id} at {comment.createdAt}
              </div>
              <div>{comment.body}</div>
            </div>
          ))}
        </div>
      );
      break;
    }
  }
}

// Send your email
// ...

----------------------------------------

TITLE: Using lastIndexOf Method with LiveList in TypeScript
DESCRIPTION: Demonstrates how to use the lastIndexOf method to find the last index of an element in a LiveList. The list is searched backwards from the provided index or the end of the list.

LANGUAGE: typescript
CODE:
const list = new LiveList(["adrien", "jonathan", "adrien"]);

// 2
list.indexOf("adrien");

// undefined
list.indexOf("chris");

----------------------------------------

TITLE: Subscribing to Storage Changes in Liveblocks
DESCRIPTION: Shows how to subscribe to a LiveList in Storage to receive updates when the list changes. The subscription callback receives the updated list with proper typing.

LANGUAGE: typescript
CODE:
const { root } = await room.getStorage();
const animals = root.get("animals");

const unsubscribe = room.subscribe(animals, (updatedAnimals) => {
  // LiveList<[{ name: "Fido" }, { name: "Felix" }]>
  console.log(updatedAnimals);
});

----------------------------------------

TITLE: Getting Thread ID from a New Thread in Liveblocks (TypeScript)
DESCRIPTION: Demonstrates how to retrieve a thread ID from a newly created thread, and then use that ID to fetch the thread details later.

LANGUAGE: typescript
CODE:
const newThread = await room.createThread(/* ... */);

const { thread, inboxNotification } = await room.getThread(newThread.id);

----------------------------------------

TITLE: Batching Storage and Presence Modifications in Liveblocks (TypeScript)
DESCRIPTION: Shows how to batch multiple Storage and Presence modifications into a single operation. This ensures that changes are grouped together and sent as a single message to other clients, and will be undone/redone together.

LANGUAGE: typescript
CODE:
const { root } = await room.getStorage();

room.batch(() => {
  root.set("x", 0);
  room.updatePresence({ cursor: { x: 100, y: 100 } });
});

----------------------------------------

TITLE: Adding Editor to Next.js Page Component
DESCRIPTION: Integrates the collaborative editor component into a Next.js page by wrapping it with the Room component to provide Liveblocks context.

LANGUAGE: tsx
CODE:
import { Room } from "./Room";
import CollaborativeEditor from "@/components/Editor";

export default function Page() {
  return (
    <Room>
      <CollaborativeEditor />
    </Room>
  );
}

----------------------------------------

TITLE: Using useSelf Hook with TypeScript in Liveblocks React
DESCRIPTION: The useSelf hook returns the current user once connected to the room and automatically subscribes to updates to the current user. It can be used with an optional selector function to subscribe to specific parts of the user data.

LANGUAGE: typescript
CODE:
import { useSelf } from "@liveblocks/react/suspense";

const currentUser = useSelf();
// {
//   connectionId: 1,
//   presence: { cursor: { x: 27, y: -8 } },
// }

const currentUser = useSelf((me) => me.presence.cursor);
// { x: 27, y: -8 }

----------------------------------------

TITLE: Setting up Liveblocks Collaborative Code Editor with Next.js
DESCRIPTION: Command to initialize a new Liveblocks project using the Monaco code editor example with Next.js. This automatically downloads the example code and prompts for API key setup.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-yjs-monaco --api-key

----------------------------------------

TITLE: Accessing LiveList Data with useStorage
DESCRIPTION: Uses useStorage selector to retrieve the LiveList of people from root storage. This converts the conflict-free data structure into a regular JavaScript array that can be used in React components.

LANGUAGE: tsx
CODE:
const people = useStorage((root) => root.people);

----------------------------------------

TITLE: Getting Other Users with useOthers Hook in React
DESCRIPTION: Retrieves a list of other users currently online using the useOthers hook from Liveblocks. This hook provides information about other users including their presence data.

LANGUAGE: tsx
CODE:
// Get list of other users
const others = useOthers();

----------------------------------------

TITLE: Converting LiveMap to Immutable Map in TypeScript
DESCRIPTION: Demonstrates converting a LiveMap to an immutable ES6 Map using toImmutable(). Nested LiveObjects are also converted to their immutable equivalents, useful for creating snapshots of data.

LANGUAGE: typescript
CODE:
const map = new LiveMap([
  ["florent", new LiveObject({ role: "engineer" })],
  ["marc", new LiveObject({ role: "designer" })],
]);

// Map {
//   "florent" => { role: "engineer" },
//   "marc" => { role: "designer" },
// }
map.toImmutable();

----------------------------------------

TITLE: Implementing Threaded Comments with Liveblocks
DESCRIPTION: Creates a Threads component that displays and manages threaded comments in the collaborative text editor. Implements AnchoredThreads for desktop display, FloatingThreads for mobile, and FloatingComposer for creating new comment threads.

LANGUAGE: tsx
CODE:
import { useThreads } from "@liveblocks/react/suspense";
import {
  AnchoredThreads,
  FloatingComposer,
  FloatingThreads,
} from "@liveblocks/react-tiptap";
import { Editor } from "@tiptap/react";

export function Threads({ editor }: { editor: Editor | null }) {
  const { threads } = useThreads({ query: { resolved: false } });

  return (
    <>
      <div className="anchored-threads">
        <AnchoredThreads editor={editor} threads={threads} />
      </div>
      <FloatingThreads
        editor={editor}
        threads={threads}
        className="floating-threads"
      />
      <FloatingComposer editor={editor} className="floating-composer" />
    </>
  );
}

----------------------------------------

TITLE: Installing Liveblocks and Zustand Packages
DESCRIPTION: Command to install the necessary dependencies including Zustand, Liveblocks client, and Liveblocks Zustand middleware.

LANGUAGE: bash
CODE:
npm install zustand @liveblocks/client @liveblocks/zustand

----------------------------------------

TITLE: Using Toolbar.Button with Various Configurations
DESCRIPTION: This snippet demonstrates different ways to configure and use Toolbar.Button, including with a name, shortcut, custom icon, Liveblocks icon, children, and additional props that get passed to the inner button element.

LANGUAGE: tsx
CODE:
import { Toolbar } from "@liveblocks/react-tiptap";
import { Icon } from "@liveblocks/react-ui";

// Button says "Question"
<Toolbar.Toggle name="Question" onClick={/* ... */} />

// Tooltip says "Question [⌘+Q]"
<Toolbar.Button name="Question" shortcut="CMD+Q" onClick={/* ... */} />

// Custom icon, replaces the name in the button
<Toolbar.Button name="Question" icon={<div>?</div>} onClick={/* ... */} />

// Using a Liveblocks icon, replaces the name in the button
<Toolbar.Button name="Question" icon={<Icon.QuestionMark />} onClick={/* ... */} />

// Passing children visually replaces the `name` and `icon`
<Toolbar.Button name="Question" onClick={/* ... */}>
  ? Ask a question
</Toolbar.Button>

// Props are passed to the inner `button`
<Toolbar.Button
  name="Question"
  style={{ marginLeft: 10 }}
  className="custom-button"
  onMouseOver={() => console.log("Hovered")}
/>

----------------------------------------

TITLE: Implementing Pagination for Inbox Notifications in TypeScript
DESCRIPTION: Shows how to implement pagination when retrieving inbox notifications, storing pages of results and using a cursor to fetch subsequent pages of notifications.

LANGUAGE: typescript
CODE:
import { InboxNotificationData } from "@liveblocks/node";

// An array of pages, each containing a list of retrieved inbox notifications
const pages: InboxNotificationData[][] = [];

// Holds the pagination cursor for the next set of inbox notifications
let startingAfter;

// Call to get the next page of inbox notifications
async function getNextPage() {
  const { data, nextCursor } = await liveblocks.getInboxNotifications({
    startingAfter,
  });
  pages.push(data);
  startingAfter = nextCursor;
}

----------------------------------------

TITLE: Creating Empty LiveList in TypeScript
DESCRIPTION: Demonstrates how to create an empty LiveList with no initial values. This creates a synchronized, ordered collection that can be populated later.

LANGUAGE: typescript
CODE:
const list = new LiveList();

----------------------------------------

TITLE: Handling YDocUpdated Webhook Events for Database Synchronization
DESCRIPTION: Complete implementation of a webhook handler that verifies requests and specifically handles the ydocUpdated event type. This event triggers when Yjs document data changes, allowing you to update your database with the latest document state.

LANGUAGE: typescript
CODE:
import { WebhookHandler } from "@liveblocks/node";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When Yjs document data has been updated
  if (event.type === "ydocUpdated") {
    const { roomId } = event.data;

    // Update database
    // ...
  }

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Fetching Threads from a Liveblocks Room (TypeScript)
DESCRIPTION: Retrieves threads and their associated inbox notifications from the current room. Returns threads, inbox notifications, and a timestamp that can be used for subsequent polling.

LANGUAGE: typescript
CODE:
const { threads, inboxNotifications, requestedAt } = await room.getThreads();

// [{ id: "th_s436g8...", type: "thread" }, ...]
console.log(threads);

// [{ id: "in_fwh3d4...", kind: "thread", }, ...]
console.log(inboxNotifications);

----------------------------------------

TITLE: Handling YDocUpdated Webhook Events for Database Synchronization
DESCRIPTION: Complete implementation of a webhook handler that verifies requests and specifically handles the ydocUpdated event type. This event triggers when Yjs document data changes, allowing you to update your database with the latest document state.

LANGUAGE: typescript
CODE:
import { WebhookHandler } from "@liveblocks/node";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When Yjs document data has been updated
  if (event.type === "ydocUpdated") {
    const { roomId } = event.data;

    // Update database
    // ...
  }

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Rendering a Basic Comment Body with Comment Primitive in React
DESCRIPTION: Demonstrates how to use the Comment.Body primitive to render a comment's body content, transforming it into readable text with links and mentions.

LANGUAGE: tsx
CODE:
import { CommentData } from "@liveblocks/client";
import { Comment } from "@liveblocks/react-ui/primitives";

// Render a custom comment body
function MyComment({ comment }: { comment: CommentData }) {
  return <Comment.Body body={comment.body} />;
}

----------------------------------------

TITLE: Accessing User Information in the Client
DESCRIPTION: Shows how to access the authenticated user's ID and information in a JavaScript application using the room.getSelf() method or useSelf() hook in React.

LANGUAGE: typescript
CODE:
const self = room.getSelf(); // or useSelf() in React
console.log(self.id);
console.log(self.info);

----------------------------------------

TITLE: Creating a Liveblocks Room Provider Component
DESCRIPTION: React component that sets up a Liveblocks room context for collaboration. It uses LiveblocksProvider and RoomProvider components to connect to a specific room and handle authentication.

LANGUAGE: tsx
CODE:
"use client";

import { ReactNode } from "react";
import {
  LiveblocksProvider,
  RoomProvider,
  ClientSideSuspense,
} from "@liveblocks/react/suspense";

export function Room({ children }: { children: ReactNode }) {
  return (
    <LiveblocksProvider authEndpoint="/api/liveblocks-auth">
      <RoomProvider id="my-room">
        <ClientSideSuspense fallback={<div>Loading…</div>}>
          {children}
        </ClientSideSuspense>
      </RoomProvider>
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Deep Subscription for Nested Storage Changes in Liveblocks
DESCRIPTION: Uses the isDeep option to subscribe to a Storage item and all of its children, receiving detailed updates about the structure that changed and the type of change.

LANGUAGE: typescript
CODE:
const { root } = await room.getStorage();

const unsubscribe = room.subscribe(
  root,
  (storageUpdates) => {
    for (const update of storageUpdates) {
      const {
        type, // "LiveObject", "LiveList", or "LiveMap"
        node,
        updates,
      } = update;
      switch (type) {
        case "LiveObject": {
          // updates["property"]?.type; is "update" or "delete"
          // update.node is the LiveObject that has been updated/deleted
          break;
        }
        case "LiveMap": {
          // updates["key"]?.type; is "update" or "delete"
          // update.node is the LiveMap that has been updated/deleted
          break;
        }
        case "LiveList": {
          // updates[0]?.type; is "delete", "insert", "move", or "set"
          // update.node is the LiveList that has been updated, deleted, or modified
          break;
        }
      }
    }
  },
  { isDeep: true }
);

----------------------------------------

TITLE: Using forEach on a LiveMap in TypeScript
DESCRIPTION: Shows how to execute a provided function once for each key-value pair in a LiveMap using the forEach method.

LANGUAGE: typescript
CODE:
const map = new LiveMap([
  ["nimesh", "developer"],
  ["pierre", "designer"],
]);

// "developer", "designer"
map.forEach((value, key, liveMap) => console.log(value));

----------------------------------------

TITLE: Filtering Threads by Resolved Status in Liveblocks (TypeScript)
DESCRIPTION: Shows how to filter threads by their resolved status when fetching them from a room. This example filters for threads that are unresolved by setting resolved to false.

LANGUAGE: typescript
CODE:
// Filtering for threads that are unresolved
const threads = await room.getThreads({
  query: {
    // +++
    resolved: false,
    // +++
  },
});

----------------------------------------

TITLE: CSS Styling for To-Do List Application
DESCRIPTION: CSS styling rules for the to-do list application, including styles for the container, input fields, to-do items, and presence indicators.

LANGUAGE: css
CODE:
body {
  background-color: rgb(243, 243, 243);
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen",
    "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue",
    sans-serif;
  -webkit-font-smoothing: antialiased;
}

.container {
  display: flex;
  flex-direction: column;
  width: 100%;
  margin-left: auto;
  margin-right: auto;
  margin-top: 3rem;
  max-width: 28rem;
}

input {
  box-sizing: border-box;
  padding: 0.5rem 0.875rem;
  margin: 0.5rem 0;
  width: 100%;
  background-color: white;
  box-shadow:
    0 0 #000,
    0 0 #000,
    0 0 #000,
    0 0 #000,
    0 1px 2px 0 rgba(0, 0, 0, 0.05);
  border-radius: 0.5rem;
  color: black;
  border: 0 solid;
  font-size: 16px;
}

input:hover {
  box-shadow:
    0 0 #000,
    0 0 #000,
    0 0 #000,
    0 0 #000,
    0 1px 3px 0 rgba(0, 0, 0, 0.1),
    0 1px 2px 0 rgba(0, 0, 0, 0.06);
}

input:focus {
  outline: none;
}

.todo_container {
  display: flex;
  padding: 0.5rem 0.875rem;
  align-items: center;
  justify-content: space-between;
}

.todo {
  flex-grow: 1;
}

.delete_button {
  padding: 0;
  margin: 0;
  font-size: 16px;
  border: 0 solid;
  appearance: button;
  background-color: transparent;
}

.delete_button:focus {
  outline: none;
}

.who_is_here {
  align-self: flex-end;
  font-size: 11px;
  color: #aaa;
}

.someone_is_typing {
  position: absolute;
  font-size: 11px;
  color: #aaa;
}

----------------------------------------

TITLE: Editing Thread Metadata with Liveblocks API
DESCRIPTION: Updates the metadata of a thread within a room. Takes the room ID, thread ID, and metadata changes. Returns the updated metadata object.

LANGUAGE: typescript
CODE:
const editedMetadata = await liveblocks.editThreadMetadata({
  roomId: "my-room-id",
  threadId: "th_d75sF3...",

  data: {
    metadata: {
      color: "yellow",
    },
    userId: "marc@example.com",
    updatedAt: new Date(), // Optional
  },
});

// { color: "yellow", page: 3, pinned: true }
console.log(editedMetadata);

----------------------------------------

TITLE: Implementing Collaborative Quill Editor with Yjs
DESCRIPTION: Complete implementation of a collaborative text editor using Quill, Yjs, and Liveblocks. Includes setup of QuillBinding to sync document changes and cursor positions across users.

LANGUAGE: tsx
CODE:
"use client";

import Quill from "quill";
import ReactQuill from "react-quill";
import QuillCursors from "quill-cursors";
import { QuillBinding } from "y-quill";
import * as Y from "yjs";
import { getYjsProviderForRoom } from "@liveblocks/yjs";
import { useRoom } from "@/liveblocks.config";
import { useCallback, useEffect, useRef, useState } from "react";

Quill.register("modules/cursors", QuillCursors);

// Collaborative text editor with simple rich text, live cursors, and live avatars
export function CollaborativeEditor() {
  const room = useRoom();
  const yProvider = getYjsProviderForRoom(room);
  const yDoc = yProvider.getYDoc();
  const yText = yDoc.getText("quill");

  return <QuillEditor yText={yText} provider={provider} />;
}

type EditorProps = {
  yText: Y.Text;
  provider: any;
};

function QuillEditor({ yText, provider }: EditorProps) {
  const reactQuillRef = useRef<ReactQuill>(null);

  // Set up Yjs and Quill
  useEffect(() => {
    let quill;
    let binding: QuillBinding;

    if (!reactQuillRef.current) {
      return;
    }

    quill = reactQuillRef.current.getEditor();
    binding = new QuillBinding(yText, quill, provider.awareness);
    return () => {
      binding?.destroy?.();
    };
  }, [yText, provider]);

  return (
    <ReactQuill
      placeholder="Start typing here…"
      ref={reactQuillRef}
      theme="snow"
      modules={{
        cursors: true,
        history: {
          // Local undo shouldn't undo changes from remote users
          userOnly: true,
        },
      }}
    />
  );
}

----------------------------------------

TITLE: Demonstrating toObject Method Limitations with Nested Live Structures
DESCRIPTION: Illustrates a limitation of the toObject method, showing that it won't recursively convert nested Live structures to JavaScript objects.

LANGUAGE: typescript
CODE:
const liveObject = new LiveObject({
  animals: new LiveList(["🦁", "🦊", "🐵"]),
});
liveObject.toObject();
// { animals: <LiveList instance> } // ❗️

----------------------------------------

TITLE: Using push Method with LiveList in TypeScript
DESCRIPTION: Demonstrates how to add one element to the end of a LiveList using the push method.

LANGUAGE: typescript
CODE:
const list = new LiveList(["adrien", "jonathan"]);

list.push("chris");

// ["adrien", "jonathan", "chris"]
list.toImmutable();

----------------------------------------

TITLE: TypeScript Typing with client.getRoom for Liveblocks
DESCRIPTION: Example showing how to add type definitions when using client.getRoom. This provides type safety for room operations in Liveblocks.

LANGUAGE: typescript
CODE:
const { room, leave } = client.getRoom<Presence, Storage, UserMeta, RoomEvent>(
  "my-room-id"
);

----------------------------------------

TITLE: Batching Multiple Deletions in Liveblocks Storage (TypeScript)
DESCRIPTION: Demonstrates how to batch multiple deletions from a LiveMap for efficiency. This example shows a 'Delete all' operation that removes multiple notes at once, sending a single update instead of multiple separate ones.

LANGUAGE: typescript
CODE:
const { root } = await room.getStorage();
const notes = root.get("notes");

// ✅ Batch simultaneous changes together
room.batch(() => {
  for (const noteId of notes.keys()) {
    notes.delete(noteId);
  }
});

----------------------------------------

TITLE: Creating a Thread in Liveblocks Room (TypeScript)
DESCRIPTION: Shows how to create a new thread with an initial comment in a Liveblocks room. The comment body consists of an array of paragraphs with text content.

LANGUAGE: typescript
CODE:
const thread = await room.createThread({
  body: {
    version: 1,
    content: [{ type: "paragraph", children: [{ text: "Hello" }] }],
  },
});

----------------------------------------

TITLE: Broadcasting and Subscribing to Events in Liveblocks
DESCRIPTION: Demonstrates how to broadcast events from one user and subscribe to them from another, receiving the event details along with user information.

LANGUAGE: typescript
CODE:
// User 1
room.broadcastEvent({ type: "REACTION", emoji: "🔥" });

// +++
// User 2
const unsubscribe = room.subscribe("event", ({ event, user, connectionId }) => {
  //                                                  ^^^^ Will be User 1
  if (event.type === "REACTION") {
    // Do something
  }
});
// +++

----------------------------------------

TITLE: Deploying Liveblocks Canvas Comments to Vercel
DESCRIPTION: Command to both download the example project and initiate Vercel deployment process, providing a seamless setup for both local development and cloud hosting.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-comments-canvas --vercel

----------------------------------------

TITLE: Updating Liveblocks Storage with useMutation Hook
DESCRIPTION: Shows how to create and use a mutation to update the storage. The updateName function uses storage.get to access a mutable version of the scientist object, then uses set to update properties.

LANGUAGE: typescript
CODE:
// Define mutation
const updateName = useMutation(({ storage }, nameType, newName) => {
  const mutableScientist = storage.get("scientist");
  mutableScientist.set(nameType, newName);
}, []);

----------------------------------------

TITLE: Setting Initial Storage with RoomProvider in Liveblocks
DESCRIPTION: Demonstration of configuring initial Storage values for a room when it's first created. Storage persists permanent data like shapes on a whiteboard or document content using conflict-free data structures like LiveList, LiveObject, and LiveMap.

LANGUAGE: tsx
CODE:
import { LiveList, LiveObject, LiveMap } from "@liveblocks/client";
import { RoomProvider } from "@liveblocks/react/suspense";

function App() {
  return (
    <RoomProvider
      id="my-room"
      initialPresence={}
      // +++
      initialStorage={{
        title: "Untitled",
        names: new LiveList(["Steven", "Guillaume"]),
        shapes: new LiveMap([
          ["g9shu0", new LiveObject({ type: "rectangle", color: "red" })],
          ["djs3g5", new LiveObject({ type: "circle", color: "yellow" })],
        ]),
      }}
      // +++
    >
      {/* children */}
    </RoomProvider>
  );
}

----------------------------------------

TITLE: Enabling experimental offline support in BlockNote with Liveblocks
DESCRIPTION: Example showing how to enable the experimental offline support feature, which saves documents locally and loads them instantly before remote synchronization.

LANGUAGE: tsx
CODE:
import { useCreateBlockNoteWithLiveblocks } from "@liveblocks/react-blocknote";

function TextEditor() {
  const editor = useCreateBlockNoteWithLiveblocks(
    {},
    {
      // +++
      offlineSupport_experimental: true,
      // +++
    }
  );

  // ...
}

----------------------------------------

TITLE: Getting a Liveblocks Room Instance
DESCRIPTION: Shows how to retrieve a previously entered room by its ID using the client.getRoom method. Returns null if client.enterRoom has not been called previously for that room ID.

LANGUAGE: ts
CODE:
const room = client.getRoom("my-room");

----------------------------------------

TITLE: Broadcasting Events to Other Users in Liveblocks Room
DESCRIPTION: Sends a custom event to all other users in the room. The event payload must be JSON-serializable and can be listened to using Room.subscribe("event").

LANGUAGE: typescript
CODE:
room.broadcastEvent({ type: "REACTION", emoji: "🔥" });

----------------------------------------

TITLE: CommentReactionRemovedEvent Schema in TypeScript
DESCRIPTION: TypeScript schema and example for the CommentReactionRemovedEvent webhook. This event is triggered when a user removes their reaction emoji from a comment.

LANGUAGE: typescript
CODE:
// Schema
type CommentReactionRemovedEvent = {
  type: "commentReactionRemoved";
  data: {
    projectId: string;
    roomId: string;
    threadId: string;
    commentId: string;
    emoji: string;
    removedAt: string;
    removedBy: string;
  };
};

// Example
const commentReactionRemovedEvent = {
  type: "commentReactionRemoved",
  data: {
    projectId: "my-project-id",
    roomId: "my-room-id",
    threadId: "my-thread-id",
    commentId: "my-comment-id",
    emoji: "👍",
    removedAt: "2021-10-06T01:45:56.558Z",
    removedBy: "my-user-id",
  },
};

----------------------------------------

TITLE: Creating Thread with Advanced Options in Liveblocks
DESCRIPTION: Creates a thread with additional options including custom metadata and creation date for the comment. Shows how to add string, number, and boolean metadata properties.

LANGUAGE: typescript
CODE:
const thread = await liveblocks.createThread({
  roomId: "my-room-id",

  data: {
    // Optional, custom metadata properties
    metadata: {
      color: "blue",
      page: 3,
      pinned: true,
    },

    // Data for the first comment in the thread
    comment: {
      // The ID of the user that created the comment
      userId: "florent@example.com",

      // Optional, when the comment was created.
      createdAt: new Date(),

      // The comment's body, uses the `CommentBody` type
      body: {
        version: 1,
        content: [
          /* The comment's body text goes here, see above */
        ],
      },
    },
  },
});

// { type: "thread", id: "th_d75sF3...", ... }
console.log(thread);

----------------------------------------

TITLE: Using useOther Hook in Liveblocks React
DESCRIPTION: The useOther hook extracts data for a specific user in the room using a selector. It subscribes to changes in the selected data for the specified user, enabling efficient rerendering for high-frequency updates.

LANGUAGE: tsx
CODE:
// ✅ Rerenders when this specific user's isTyping changes (but not when their cursor changes)
const isTyping = useOther(
  3, // User with connectionId 3
  (user) => user.presence.isTyping
);

----------------------------------------

TITLE: Comparing Deprecated and Current Room Exit Methods
DESCRIPTION: Demonstrates the deprecated client.leave method compared to the leave function returned by client.enterRoom. The newer approach provides a more intuitive API by returning the leave function when entering a room.

LANGUAGE: typescript
CODE:
// ❌ This API was recommended before 1.5
client.leave("my-room");

// ✅ Prefer this instead
const { room, leave } = client.enterRoom("my-room" /* options */);
leave();

----------------------------------------

TITLE: Creating a Next.js Webhook Handler for Liveblocks Email Notifications
DESCRIPTION: A Next.js route handler that processes Liveblocks webhooks and uses @liveblocks/emails to create styled emails for thread notifications. This snippet shows the full implementation including webhook verification and email preparation.

LANGUAGE: tsx
CODE:
import { isThreadNotificationEvent, WebhookHandler } from "@liveblocks/node";
import { Liveblocks } from "@liveblocks/node";
// +++
import { prepareThreadNotificationEmailAsReact } from "@liveblocks/emails";
// +++

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

const webhookHandler = new WebhookHandler(
  process.env.LIVEBLOCKS_WEBHOOK_SECRET_KEY as string
);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // +++
  // Using `@liveblocks/emails` to create an email
  if (isThreadNotificationEvent(event)) {
    const emailData = await prepareThreadNotificationEmailAsReact(
      liveblocks,
      event
    );

    if (emailData.type === "unreadMention") {
      const email = (
        <div>
          <div>
            @{emailData.comment.author.id} at {emailData.comment.createdAt}
          </div>
          <div>{emailData.comment.body}</div>
        </div>
      );

      // Send unread mention email
      // ...
    }
  }
  // +++

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Converting LiveObject to Immutable JavaScript Object in TypeScript
DESCRIPTION: Demonstrates how to convert a LiveObject and its nested structures to an immutable JavaScript object using toImmutable method.

LANGUAGE: typescript
CODE:
const liveObject = new LiveObject({
  firstName: "Grace",
  lastName: "Hopper",
  hobbies: new LiveList(["reading", "piano"]),
});

// {
//   firstName: "Grace",
//   lastName: "Hopper",
//   hobbies: ["reading", "piano"]
// }
liveObject.toImmutable();

----------------------------------------

TITLE: Cloning a LiveMap in TypeScript
DESCRIPTION: Shows how to create a deep copy of a LiveMap using the clone() method. This allows inserting the same structure in multiple locations in the storage tree without referencing the same instance.

LANGUAGE: typescript
CODE:
const map = new LiveMap(/* ... */);
root.set("a", map);
root.set("b", map.clone());

----------------------------------------

TITLE: Setting Throttle Values for Different Frame Rates
DESCRIPTION: Examples of different throttle values and their corresponding frames per second (FPS) for Liveblocks client. These settings help control the frequency of WebSocket updates for optimal animation performance.

LANGUAGE: typescript
CODE:
throttle:  16, // 60 FPS
throttle:  32, // 30 FPS
throttle: 200, //  5 FPS

----------------------------------------

TITLE: Running localtunnel for Webhook Testing
DESCRIPTION: Command to expose your local development server via localtunnel, allowing Liveblocks to send webhook events to your locally running application during development.

LANGUAGE: bash
CODE:
npx localtunnel --port 3000

----------------------------------------

TITLE: Creating a Tiptap Editor Binary Update for Yjs in Liveblocks
DESCRIPTION: Demonstrates how to create a Yjs binary update for the Tiptap editor, using Y.XmlElement and Y.XmlText to construct document content before encoding it as an update.

LANGUAGE: typescript
CODE:
import * as Y from "yjs";
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export async function POST() {
  // Create a Yjs document
  const yDoc = new Y.Doc();

  // Create Tiptap Yjs state
  const yXmlElement = new Y.XmlElement("paragraph");
  yXmlElement.insert(0, [new Y.XmlText("Hello world")]);

  // Create your data structures and make your update
  const yXmlFragment = yDoc.getXmlFragment("default");
  yXmlFragment.insert(0, [yXmlElement]);

  // Encode the document state as an update message
  const yUpdate = Y.encodeStateAsUpdate(yDoc);

  // Initialize the Yjs document with the update
  await liveblocks.sendYjsBinaryUpdate("my-room-id", {
    update: yUpdate,
  });
}

----------------------------------------

TITLE: Using LiveblocksProvider with Public API Key in React
DESCRIPTION: Example showing how to configure LiveblocksProvider with a public API key. This approach is recommended only for prototyping or public landing pages, as it allows end users to access any room's data.

LANGUAGE: tsx
CODE:
import { LiveblocksProvider } from "@liveblocks/react/suspense";

function App() {
  return (
    <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>
      {/* children */}
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Adding Reactions to Comments with useAddReaction
DESCRIPTION: Example of using the useAddReaction hook to add emoji reactions to comments. This component creates a button that adds a star emoji reaction to a specified comment when clicked.

LANGUAGE: tsx
CODE:
import { CommentData } from "@liveblocks/client";
import { useAddReaction } from "../liveblocks.config.ts";

// A button that adds a "⭐" reaction to a comment
function Component({ comment }: { CommentData }) {
  const addReaction = useAddReaction();

  function handleClick() {
    addReaction({
      threadId: comment.threadId,
      commentId: comment.commentId,
      emoji: "⭐",
    });
  }

  return <button onClick={handleClick}>Star ⭐</button>;
}

----------------------------------------

TITLE: Initializing Liveblocks Configuration File
DESCRIPTION: Command to create the liveblocks.config.ts file which can be used later to define types for the application.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --init --framework react

----------------------------------------

TITLE: HTML Structure for To-Do List Application
DESCRIPTION: HTML markup defining the structure of the to-do list application, including the container for showing who is currently in the room.

LANGUAGE: html
CODE:
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Liveblocks - Todo list</title>
    <link rel="stylesheet" href="index.css" />
  </head>
  <body>
    <div class="container">
      <div id="who_is_here" class="who_is_here"></div>
    </div>
    <script src="app.js"></script>
  </body>
</html>

----------------------------------------

TITLE: Rendering Multiple Live Cursors from Other Users
DESCRIPTION: Renders the UI with live cursors for all other online users. It filters out users whose cursors are null (off-screen) and maps through the remaining users to render a Cursor component for each one.

LANGUAGE: tsx
CODE:
return (
  <div
    style={{ width: "100vw", height: "100vh" }}
    onPointerMove={handlePointerMove}
    onPointerLeave={handlePointerLeave}
  >
    Cursor: {JSON.stringify(myPresence.cursor)}
    {others
      .filter((other) => other.presence.cursor !== null)
      .map(({ connectionId, presence }) => (
        <Cursor
          key={connectionId}
          x={presence.cursor.x}
          y={presence.cursor.y}
        />
      ))}
  </div>
);

----------------------------------------

TITLE: Accessing History Methods in Liveblocks Room (TypeScript)
DESCRIPTION: Shows how to access the history methods in a Liveblocks room, which provide undo, redo, pause, and resume functionality. Each user has a separate history stored in memory.

LANGUAGE: typescript
CODE:
const { undo, redo, pause, resume /*, ... */ } = room.history;

----------------------------------------

TITLE: Broadcasting Events from Server in Liveblocks
DESCRIPTION: Shows how to broadcast events from the server side using @liveblocks/node, which will be received by clients with null user and -1 connectionId.

LANGUAGE: typescript
CODE:
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export async function POST() {
  await liveblocks.broadcastEvent({ type: "REACTION", emoji: "🔥" });
}

----------------------------------------

TITLE: Finding First Matching Element in LiveList in TypeScript
DESCRIPTION: Demonstrates how to find the first element that satisfies a condition using the find() method. Returns the first matching element or undefined if no elements match.

LANGUAGE: typescript
CODE:
const list = new LiveList(["apple", "lemon", "tomato"]);

// "lemon"
list.find((value, index) => value.startsWith("l"));

----------------------------------------

TITLE: Attaching a Schema to a Room via REST API in TypeScript
DESCRIPTION: Example demonstrating how to attach a schema to a room using the Liveblocks REST API. This enables validation of all operations against the specified schema version to ensure data integrity.

LANGUAGE: typescript
CODE:
fetch("https://api.liveblocks.io/v2/rooms/{roomId}/schema", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    schema: "todo-list@1",
  }),
});

----------------------------------------

TITLE: Deleting Room Notification Settings in Liveblocks
DESCRIPTION: Uses the liveblocks.deleteRoomNotificationSettings method to remove a user's notification preferences for a specific room. Requires roomId and userId parameters. This resets the settings to their default values.

LANGUAGE: typescript
CODE:
await liveblocks.deleteRoomNotificationSettings({
  roomId: "my-room-id",
  userId: "steven@example.com",
});

----------------------------------------

TITLE: Using useRoomNotificationSettings hook in React
DESCRIPTION: Shows how to retrieve and update notification settings for the current user in the current room. These settings control which inbox notifications the user receives.

LANGUAGE: tsx
CODE:
import { useRoomNotificationSettings } from "@liveblocks/react/suspense";

const [{ settings }, updateSettings] = useRoomNotificationSettings();

// { threads: "replies_and_mentions" }
console.log(settings);

// No longer receive thread notifications in this room
updateSettings({
  threads: "none",
});

----------------------------------------

TITLE: Creating a Custom Toolbar with Children
DESCRIPTION: Shows how to create a fully custom toolbar by passing elements as children to the Toolbar component. This allows for complete control over the toolbar's content and appearance.

LANGUAGE: tsx
CODE:
import { Toolbar } from "@liveblocks/react-lexical";

function CustomToolbar() {
  return (
    <Toolbar>
      Hello <strong>world</strong>
    </Toolbar>
  );
}

----------------------------------------

TITLE: Deleting Properties from a LiveObject
DESCRIPTION: Demonstrates how to delete a property from a LiveObject using the delete method. Changes are synchronized across all clients connected to the same room.

LANGUAGE: typescript
CODE:
const object = new LiveObject({ firstName: "Ada", lastName: "Lovelace" });
object.delete("lastName");

// { firstName: "Ada" }
object.toImmutable();

----------------------------------------

TITLE: Using useNotificationSettings hook in React
DESCRIPTION: Shows how to retrieve and update project-level notification settings for the current user. This controls which notification webhook events are sent for the user across all rooms.

LANGUAGE: tsx
CODE:
import { useNotificationSettings } from "@liveblocks/react";

const [{ isLoading, error, settings }, updateSettings] =
  useNotificationSettings();

// Current user receives thread notifications on the email channel
// { email: { thread: true, ... }, ... }
console.log(settings);

// Disabling thread notifications on the email channel
updateSettings({
  email: {
    thread: false,
  },
});

----------------------------------------

TITLE: Implementing LiveblocksProvider with Custom Auth Endpoint Callback in React
DESCRIPTION: Example of using LiveblocksProvider with a custom authentication endpoint callback. The callback function receives a room parameter and should return an object with a token property containing the authentication token.

LANGUAGE: tsx
CODE:
import { LiveblocksProvider } from "@liveblocks/react/suspense";

function App() {
  return (
    <LiveblocksProvider
      authEndpoint={async (room) => {
        // Fetch your authentication endpoint and retrieve your access or ID token
        // ...

        return { token: "..." };
      }}
    >
      {/* children */}
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Creating Comment Content with Links and Mentions in TypeScript
DESCRIPTION: Example of creating a comment with advanced formatting including user mentions and hyperlinks. This shows how to reference users and create clickable links in comment content.

LANGUAGE: ts
CODE:
const body: CommentBody = {
  version: 1,
  content: [
    // +++
    {
      type: "paragraph",
      children: [
        { type: "mention", id: "jody.hekla" },
        { text: " the " },
        { text: "Liveblocks", type: "link", url: "https://liveblocks.io" },
        { text: " website is cool!" },
      ],
    },
    // +++
  ],
};

----------------------------------------

TITLE: Creating a Liveblocks Client with Custom Auth Callback in TypeScript
DESCRIPTION: Example demonstrating how to use a custom authentication callback function with createClient. This approach allows adding custom headers or implementing custom authorization logic.

LANGUAGE: ts
CODE:
import { createClient } from "@liveblocks/client";

const client = createClient({
  authEndpoint: async (room) => {
    // Fetch your authentication endpoint and retrieve your access or ID token
    // ...

    return { token: "..." };
  },
});

----------------------------------------

TITLE: Using useOthersConnectionIds Hook in Liveblocks React
DESCRIPTION: The useOthersConnectionIds hook returns an array of connection IDs and rerenders when users join or leave. It's useful in combination with the useOther hook for implementing high-frequency rerendering components.

LANGUAGE: tsx
CODE:
useOthersConnectionIds(); // [2, 4, 7]

----------------------------------------

TITLE: Mutate Storage with Synchronous Callback in TypeScript
DESCRIPTION: Modifies Storage contents from the server using a synchronous callback function. This allows server-side modifications to Storage without showing presence information.

LANGUAGE: typescript
CODE:
// Mutate a single room
await liveblocks.mutateStorage(
  "my-room-id",

  ({ root }) => {
    root.get("list").push("item3");
  }
);

----------------------------------------

TITLE: Getting User Presence in Liveblocks
DESCRIPTION: Demonstrates how to retrieve the current user's presence data using room.getPresence(). Presence stores temporary user data like cursor position that exists until the user disconnects.

LANGUAGE: ts
CODE:
const presence = room.getPresence();

// { cursor: { x: 363, y: 723 } }
console.log(presence);

----------------------------------------

TITLE: Upgrading Liveblocks to version 2.9 using npx
DESCRIPTION: Command to upgrade all Liveblocks packages to the latest version using create-liveblocks-app.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --upgrade

----------------------------------------

TITLE: Accessing Room Instance with useRoom Hook in Liveblocks
DESCRIPTION: Example of using the useRoom hook to access the Room instance from a RoomProvider. This provides direct access to the room's methods and properties for advanced usage.

LANGUAGE: ts
CODE:
import { useRoom } from "@liveblocks/react/suspense";

const room = useRoom();

----------------------------------------

TITLE: Configuring WebSocket Throttle in Liveblocks
DESCRIPTION: Sets up a Liveblocks client with custom throttling for WebSocket messages. Throttle values can be set between 16 and 1000 milliseconds, affecting the updates per second and animations smoothness.

LANGUAGE: typescript
CODE:
import { createClient } from "@liveblocks/client";

const client = createClient({
  throttle: 16,

  // Other options
  // ...
});

----------------------------------------

TITLE: Preventing Users from Losing Unsaved Changes with preventUnsavedChanges
DESCRIPTION: Shows how to use the preventUnsavedChanges option with LiveblocksProvider to warn users before closing tabs with unsaved changes, protecting data during slow connections or sudden tab closures.

LANGUAGE: tsx
CODE:
function Page() {
  return (
    <LiveblocksProvider
      // highlight-next-line
      preventUnsavedChanges

      // Other options
      // ...
    >
      ...
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Updating Room Notification Settings with Room.updateNotificationSettings in TypeScript
DESCRIPTION: Shows how to update the current user's notification settings for the current room. Allows configuring which notifications the user receives from threads in the room.

LANGUAGE: typescript
CODE:
const settings = await room.updateNotificationSettings({
  threads: "replies_and_mentions",
});

----------------------------------------

TITLE: Error and Loading State Handling with Regular Hooks in React
DESCRIPTION: Demonstrates how to manually handle error and loading states with regular Liveblocks hooks like useThreads, checking for error and isLoading before using the data.

LANGUAGE: tsx
CODE:
import { useThreads } from "@liveblocks/react";

function Component() {
  // Check for `error` and `isLoading` before `threads` is defined
  const { threads, error, isLoading } = useThreads();

  if (error) {
    return <div>Error</div>;
  }

  if (isLoading) {
    return <div>Loading…</div>;
  }

  // ...
}

----------------------------------------

TITLE: Configuring Source IP Addresses for Svix
DESCRIPTION: List of IP addresses that need to be whitelisted if your webhook endpoint is behind a firewall or NAT. These are the source IP addresses used by Svix to deliver webhook events.

LANGUAGE: text
CODE:
44.228.126.217
50.112.21.217
52.24.126.164
54.148.139.208
2600:1f24:64:8000::/52

----------------------------------------

TITLE: Initialize Storage Document with Manual LSON Creation
DESCRIPTION: Creates a room and initializes its Storage by manually constructing LSON data. This approach gives direct control over the LSON structure without using helper functions.

LANGUAGE: typescript
CODE:
// Create a new room
const room = await liveblocks.createRoom("my-room-id", {
  defaultAccesses: ["room:write"],
});

// If this were your Storage type...
declare global {
  interface Liveblocks {
    Storage: {
      names: LiveList<string>;
    };
  }
}

// Create this Storage and add names to the LiveList
const storage = await liveblocks.initializeStorageDocument("my-room-id", {
  liveblocksType: "LiveObject",
  data: {
    names: {
      liveblocksType: "LiveList",
      data: ["Olivier", "Nimesh"],
    },
  },
});

----------------------------------------

TITLE: Adding Reactions with useAddReaction in Liveblocks
DESCRIPTION: Shows how to use useAddReaction hook to add an emoji reaction to a comment.

LANGUAGE: tsx
CODE:
import { useAddReaction } from "@liveblocks/react/suspense";

const addReaction = useAddReaction();
addReaction({ threadId: "th_xxx", commentId: "cm_xxx", emoji: "👍" });

----------------------------------------

TITLE: Testing All Elements in LiveList with every() in TypeScript
DESCRIPTION: Demonstrates how to check if all elements in a LiveList satisfy a condition using the every() method. Returns true only if the callback returns a truthy value for every element.

LANGUAGE: typescript
CODE:
const list = new LiveList([0, 2, 4]);

// true
list.every((i) => i % 2 === 0);

list.push(5);

// false
list.every((i) => i % 2 === 0);

----------------------------------------

TITLE: Creating a Supabase Postgres Database Table for Yjs Documents
DESCRIPTION: This SQL query creates a 'documents' table in Supabase with two columns: 'roomId' as the primary key and 'yDocData' to store the JSON Yjs document data as text. This schema is designed to store and track Yjs document updates from Liveblocks.

LANGUAGE: sql
CODE:
CREATE TABLE documents ( roomId VARCHAR(255) PRIMARY KEY, yDocData TEXT NOT NULL );

----------------------------------------

TITLE: Updating Name Mutation for LiveList Items
DESCRIPTION: Uses useMutation to create an updateName function that takes an index parameter to target specific items in the LiveList. The function gets the person at the specified index and updates their name property.

LANGUAGE: tsx
CODE:
// Update name mutation
const updateName = useMutation(
  ({ storage }, newName: string, index: number) => {
    const person = storage.get("people").get(index);
    person.set("name", newName);
  },
  []
);

----------------------------------------

TITLE: Using Union Types in Liveblocks Schema
DESCRIPTION: Shows how to use union types to model choices between different types. Demonstrates various applications of unions with primitive types and Liveblocks constructs.

LANGUAGE: typescript
CODE:
type Storage {
  ids: (string | number)[]
  selectedId: string | null
  person: LiveObject<Person> | null
  people: LiveList<LiveObject<Person>> | null
}

----------------------------------------

TITLE: Installing Liveblocks, Yjs, and Monaco Dependencies with npm
DESCRIPTION: Command to install all the necessary packages for building a collaborative code editor with Liveblocks, Yjs, and Monaco Editor.

LANGUAGE: bash
CODE:
npm install @liveblocks/client @liveblocks/react @liveblocks/yjs yjs @monaco-editor/react y-monaco y-protocols

----------------------------------------

TITLE: Implementing Access Token Authentication in Next.js Route Handler
DESCRIPTION: A complete example showing how to implement access token-based authentication in a Next.js route handler, including user validation and room access control.

LANGUAGE: typescript
CODE:
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export async function POST(request: Request) {
  /**
   * Implement your own security here.
   *
   * It's your responsibility to ensure that the caller of this endpoint
   * is a valid user by validating the cookies or authentication headers
   * and that it has access to the requested room.
   */

  // Get the current user from your database
  const user = __getUserFromDB__(request);

  // Start an auth session inside your endpoint
  const session = liveblocks.prepareSession(
    user.id,
    { userInfo: user.metadata } // Optional
  );

  // Implement your own security, and give the user access to the room
  const { room } = await request.json();
  if (room && __shouldUserHaveAccess__(user, room)) {
    session.allow(room, session.FULL_ACCESS);
  }

  // Retrieve a token from the Liveblocks servers and pass it to the
  // requesting client
  const { body, status } = await session.authorize();
  return new Response(body, { status });
}

----------------------------------------

TITLE: Setting up Authentication Endpoint in SvelteKit
DESCRIPTION: Implementation of an authentication endpoint in SvelteKit. This endpoint identifies users and applies security rules to determine access to specific rooms.

LANGUAGE: typescript
CODE:
import { type RequestEvent } from "@sveltejs/kit";
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export async function POST({ request }: RequestEvent) {
  // Get the current user from your database
  const user = __getUserFromDB__(request);

  // Identify the user and return the result
  const { status, body } = await liveblocks.identifyUser(
    {
      userId: user.id,
      groupIds, // Optional
    },
    { userInfo: user.metadata },
  );

  return new Response(body, { status });
}

----------------------------------------

TITLE: Retrieving User Info with useUser Hook in React
DESCRIPTION: Shows how to use the useUser hook to retrieve information about a user by their ID. Requires setting up a resolver function in createClient.

LANGUAGE: tsx
CODE:
import { useUser } from "@liveblocks/react/suspense";

const { user, error, isLoading } = useUser("user-id");

----------------------------------------

TITLE: Configuring resolveRoomsInfo for LiveblocksProvider in React
DESCRIPTION: Example of setting up the resolveRoomsInfo function to replace room IDs with document names for notifications in the Liveblocks provider.

LANGUAGE: tsx
CODE:
import { LiveblocksProvider } from "@liveblocks/react/suspense";

function App() {
  return (
    <LiveblocksProvider
      resolveRoomsInfo={async ({ roomIds }) => {
        const documentsData = await __getDocumentsFromDB__(roomIds);

        return documentsData.map((documentData) => ({
          name: documentData.name,
          // url: documentData.url,
        }));
      }}

      // Other props
      // ...
    >
      {/* children */}
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Using insert Method with LiveList in TypeScript
DESCRIPTION: Demonstrates how to insert an element at a specified index in a LiveList. The method throws an Error if the index is out of bounds.

LANGUAGE: typescript
CODE:
const list = new LiveList(["adrien", "jonathan"]);

list.insert("chris", 1);

// ["adrien", "chris", "jonathan"]
list.toImmutable();

----------------------------------------

TITLE: Setting up a collaborative Quill text editor in Vue.js
DESCRIPTION: A complete Vue component that implements a collaborative text editor with Quill, Yjs, and Liveblocks. The component handles initialization, room connection, and proper cleanup on unmount.

LANGUAGE: html
CODE:
<script setup>
import { ref, onMounted, onUnmounted } from "vue";
import { createClient } from "@liveblocks/client";
import { getYjsProviderForRoom } from "@liveblocks/yjs";
import * as Y from "yjs";
import Quill from "quill";
import { QuillBinding } from "y-quill";
import QuillCursors from "quill-cursors";

const element = ref(null);
const binding = ref(null);
const leave = ref(null);

// Set up Liveblocks client
const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

// Enter a multiplayer room
const info = client.enterRoom("my-room");
const room = info.room;
leave.value = info.leave;

// Set up Yjs document, shared text, and Liveblocks Yjs provider
const yText = yDoc.getText("quill");
const yProvider = getYjsProviderForRoom(room);
const yDoc = yProvider.getYDoc();

// Attach cursors plugin
Quill.register("modules/cursors", QuillCursors);

onMounted(() => {
  // Set up Quill editor and modules
  const quill = new Quill(element.value, {
    placeholder: "Start collaborating…",
    theme: "snow",
    modules: {
      cursors: true,
      toolbar: [
        [{ header: [1, 2, false] }],
        ["bold", "italic", "underline"],
        ["code-block"],
      ],
      history: {
        // Local undo shouldn't undo changes made by other users
        userOnly: true,
      },
    },
  });

  // Attach Yjs to Quill
  binding.value = new QuillBinding(yText, quill, yProvider.awareness);
});

onUnmounted(() => {
  binding?.destroy?.();
  leave?.();
});
</script>

<template>
  <div ref="element" />
</template>

----------------------------------------

TITLE: Defining Thread Metadata in TypeScript
DESCRIPTION: Example of attaching custom metadata to a thread when creating it. Metadata can include string, number, and boolean properties that provide additional context to the thread.

LANGUAGE: ts
CODE:
import { ThreadMetadata } from "@liveblocks/client";

const metadata: ThreadMetadata = {
  color: "blue",
  page: 3,
  pinned: true,
};

const thread = await room.createThread({ body, metadata });

----------------------------------------

TITLE: Retrieving Project Notification Settings with Client.getNotificationSettings in TypeScript
DESCRIPTION: Demonstrates how to fetch the user's notification settings for the entire project. Shows which notification webhook events will be sent for the current user across all rooms in the project.

LANGUAGE: typescript
CODE:
const settings = await client.getNotificationSettings();

// { email: { thread: true, ... }, slack: { thread: false, ... }, ... }
console.log(settings);

----------------------------------------

TITLE: Initializing Liveblocks Configuration File
DESCRIPTION: Command to create a Liveblocks configuration file that can be used for defining types for the application.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --init --framework react

----------------------------------------

TITLE: Advanced Filtering for Mass Storage Mutation in Liveblocks
DESCRIPTION: Demonstrates massMutateStorage with filtering options to target specific rooms based on group IDs, user access, room IDs, or metadata. Also shows how to control concurrency and add abort signals for cancellation.

LANGUAGE: typescript
CODE:
// Mutate a number of rooms
await liveblocks.massMutateStorage(
  {
    // +++
    // Optional, filter for rooms that allow entry to group ID(s) in `groupsAccesses`
    groupIds: ["engineering", "design"],

    // Optional, filter for rooms that allow entry to a user's ID in `usersAccesses`
    userId: "my-user-id",

    // Optional, use advanced filtering
    query: {
      // Optional, filter for rooms with an ID that starts with specific string
      roomId: {
        startsWith: "liveblocks:",
      },
      // Optional, filter for rooms with custom metadata in `metadata`
      metadata: {
        roomType: "whiteboard",
      },
    },
    // +++
  },

  ({ room, root }) => {
    // { type: "room", id: "my-room-id", metadata: {...}, ... }
    console.log(room);

    root.get("animals").push("🦍");
  },

  // Optional
  // +++
  {
    concurrency: 10, // Optional, process at most 10 rooms simultaneously
    signal, // Optional, provide an abort signal to cancel mutations mid-way
  }
  // +++
);

----------------------------------------

TITLE: Editing a Comment with Additional Options in Liveblocks
DESCRIPTION: Shows the complete set of options available when editing a comment with liveblocks.editComment, including specifying the updated comment body, the user ID who edited it, and an optional edit timestamp.

LANGUAGE: typescript
CODE:
const editedComment = await liveblocks.editComment({
  roomId: "my-room-id",
  threadId: "th_d75sF3...",
  commentId: "cm_agH76a...",

  data: {
    // The comment's body, uses the `CommentBody` type
    body: {
      version: 1,
      content: [
        /* The comment's body text goes here, see above */
      ],
    },

    // The ID of the user that edited the comment
    userId: "alicia@example.com",

    // Optional, the time the comment was edited
    editedAt: new Date(),
  },
});

// { type: "comment", threadId: "th_d75sF3...", ... }
console.log(editedComment);

----------------------------------------

TITLE: Cursor Component Implementation with useOther in Liveblocks React
DESCRIPTION: This component renders an individual cursor using the useOther hook to subscribe to cursor position changes for a specific user, allowing efficient high-frequency updates.

LANGUAGE: tsx
CODE:
function Cursor({ connectionId }) {
  // +++
  const { x, y } = useOther(connectionId, (other) => other.presence.cursor); // (4)
  // +++
  return <Cursor x={x} y={y} />;
}

----------------------------------------

TITLE: Pausing and Resuming History in Liveblocks for Drag Operations
DESCRIPTION: This snippet demonstrates how to pause and resume history tracking during drag operations to prevent intermediate states from being added to the undo/redo history. This is useful for operations like dragging elements in a design tool.

LANGUAGE: TSX
CODE:
import { useHistory } from "@liveblocks/react/suspense";

function App() {
  const { resume, pause } = useHistory();

  return <Rectangle onDragStart={() => pause()} onDragEnd={() => resume()} />;
}

----------------------------------------

TITLE: Clearing History in Liveblocks Room (TypeScript)
DESCRIPTION: Demonstrates how to clear the undo and redo stacks for the current client using the clear method. This resets the ability to undo beyond the current document state without affecting other clients' histories.

LANGUAGE: typescript
CODE:
const person = new LiveObject();
person.set("name", "Pierre");

// true
room.history.canUndo();

room.history.clear();

// false
room.history.canUndo();

----------------------------------------

TITLE: Subscribing to Storage Item Updates in Liveblocks Room
DESCRIPTION: Subscribes to updates on a particular storage item like a LiveObject, LiveMap, or LiveList. The callback is called whenever the storage item is updated.

LANGUAGE: typescript
CODE:
const { root } = await room.getStorage();

const unsubscribe = room.subscribe(root, (updatedRoot) => {
  // Do something
});

----------------------------------------

TITLE: Using useSyncStatus Hook with Suspense
DESCRIPTION: Shows the Suspense version of the useSyncStatus hook, which provides the same synchronization status tracking but with Suspense compatibility.

LANGUAGE: ts
CODE:
import { useSyncStatus } from "@liveblocks/react/suspense";

const syncStatus = useSyncStatus();
// "synchronizing" | "synchronized"

----------------------------------------

TITLE: Complete Webhook Handler for Comments with Liveblocks
DESCRIPTION: Full implementation of a webhook handler that verifies requests and processes a 'threadCreated' event. It uses the Liveblocks SDK to fetch the newly created thread data for further processing.

LANGUAGE: typescript
CODE:
import { WebhookHandler } from "@liveblocks/node";
import { Liveblocks } from "@liveblocks/node";

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";
const liveblocks = new Liveblocks({ secret: API_SECRET });

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When a new thread has been created
  if (event.type === "threadCreated") {
    const { roomId, threadId } = event.data;

    // Fetch new thread
    const thread = await liveblocks.getThread({ roomId, threadId });

    // Use thread
    // ...
  }

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Using useThreadSubscription in Liveblocks React
DESCRIPTION: Shows how to use useThreadSubscription hook to get the subscription status of a thread. Returns status and unreadSince information.

LANGUAGE: tsx
CODE:
import { useThreadSubscription } from "@liveblocks/react/suspense";

const { status, unreadSince } = useThreadSubscription("th_xxx");

----------------------------------------

TITLE: Setting Room Permissions with Liveblocks Node
DESCRIPTION: Example of creating a room with specific access permissions using liveblocks.createRoom. This demonstrates how to set default, group, and user-specific access levels for a room.

LANGUAGE: typescript
CODE:
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

const room = await liveblocks.createRoom("my-room-id", {
  defaultAccesses: ["room:read", "room:presence:write"],
  groupsAccesses: {
    "my-group-id": ["room:write"],
  },
  usersAccesses: {
    "my-user-id": ["room:write"],
  },
});

----------------------------------------

TITLE: Configuring Liveblocks Storage with Zustand Store
DESCRIPTION: This code demonstrates how to set up a Zustand store with Liveblocks integration. It defines a store with state properties for firstName, lastName, and discoveries that are mapped to Liveblocks storage through the storageMapping configuration, allowing these properties to be synchronized across clients.

LANGUAGE: typescript
CODE:
/* ...client setup */

const useStore = create<WithLiveblocks<State>>()(  
  liveblocks(
    (set) => ({
      firstName: "Marie",
      lastName: "Curie",
      discoveries: ["Polonium", "Radium"],

      setFirstName: (firstName) => set({ firstName }),
      setLastName: (lastName) => set({ lastName }),
      addDiscovery: (discovery) =>
        set((state) => ({
          discoveries: state.discoveries.concat([discovery]),
        })),
    }),
    {
      client,
      storageMapping: {
        firstName: true,
        lastName: true,
        discoveries: true,
      },
    }
  )
);

----------------------------------------

TITLE: Setting up Liveblocks Client with Room Provider in React
DESCRIPTION: Basic setup for the Liveblocks client with LiveblocksProvider and RoomProvider components to create a collaborative environment in a React application.

LANGUAGE: tsx
CODE:
"use client";

import {
  LiveblocksProvider,
  RoomProvider,
} from "@liveblocks/react/suspense";
import { Editor } from "./Editor";

export default function App() {
  return (
    <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>      <RoomProvider id="my-room">
        {/* ... */}
      </RoomProvider>
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Deleting Notification Settings with deleteNotificationSettings in TypeScript
DESCRIPTION: Shows how to delete a user's notification settings, resetting them to the default values configured in the project's notification dashboard.

LANGUAGE: typescript
CODE:
await liveblocks.deleteNotificationSettings({
  userId: "adri@example.com",
});

----------------------------------------

TITLE: Examples of Notification Settings Updates in JavaScript
DESCRIPTION: Shows different ways to update notification settings including enabling custom notifications, partial updates, and configuring complex settings across multiple channels.

LANGUAGE: javascript
CODE:
// You only need to pass partials
await client.updateNotificationSettings({
  email: { thread: true },
});

// Enabling a custom notification on the slack channel
await client.updateNotificationSettings({
  slack: { $myCustomNotification: true },
});

// Setting complex settings
await client.updateNotificationSettings({
  email: {
    thread: true,
    textMention: false,
    $newDocument: true,
  },
    slack: {
    thread: false,
    $fileUpload: false,
  },
    teams: {
    thread: true,
  },
});

----------------------------------------

TITLE: Examples of Notification Settings Updates in JavaScript
DESCRIPTION: Shows different ways to update notification settings including enabling custom notifications, partial updates, and configuring complex settings across multiple channels.

LANGUAGE: javascript
CODE:
// You only need to pass partials
await client.updateNotificationSettings({
  email: { thread: true },
});

// Enabling a custom notification on the slack channel
await client.updateNotificationSettings({
  slack: { $myCustomNotification: true },
});

// Setting complex settings
await client.updateNotificationSettings({
  email: {
    thread: true,
    textMention: false,
    $newDocument: true,
  },
    slack: {
    thread: false,
    $fileUpload: false,
  },
    teams: {
    thread: true,
  },
});

----------------------------------------

TITLE: Using Undo in Liveblocks History (TypeScript)
DESCRIPTION: Shows how to use the undo function to revert the last operation on the current client. This only affects changes made by the current client and not operations made by other clients.

LANGUAGE: typescript
CODE:
const person = new LiveObject();
person.set("name", "Pierre");
person.set("name", "Jonathan");

room.history.undo();

// "Pierre"
root.get("name");

----------------------------------------

TITLE: Using Asynchronous Iteration with Liveblocks.iterRooms
DESCRIPTION: Shows how to use the iterRooms method to automatically paginate through all rooms in your project using an asynchronous iterator, eliminating the need for manual pagination.

LANGUAGE: typescript
CODE:
const roomsIterator = liveblocks.iterRooms();

for await (const room of roomsIterator) {
  // { type: "room", id: "my-room-id", metadata: {...}, ... }
  console.log(room);
}

----------------------------------------

TITLE: Complete Implementation of FloatingToolbar with Comments in React-Lexical
DESCRIPTION: Demonstrates a complete setup for FloatingToolbar with commenting functionality, including the necessary components like FloatingComposer and FloatingThreads. Shows how to integrate everything within the LexicalComposer.

LANGUAGE: tsx
CODE:
import { LexicalComposer } from "@lexical/react/LexicalComposer";
import { RichTextPlugin } from "@lexical/react/LexicalRichTextPlugin";
import { ContentEditable } from "@lexical/react/LexicalContentEditable";
import { LexicalErrorBoundary } from "@lexical/react/LexicalErrorBoundary";
import { useThreads } from "@liveblocks/react/suspense";
import {
  liveblocksConfig,
  LiveblocksPlugin,
  FloatingComposer,
  // +++
  FloatingToolbar,
  //+++
} from "@liveblocks/react-lexical";

const initialConfig = liveblocksConfig({
  namespace: "MyEditor",
  theme: {},
  nodes: [],
  onError: (err) => console.error(err),
});

function Editor() {
  const { threads } = useThreads();

  return (
    <LexicalComposer initialConfig={initialConfig}>
      <LiveblocksPlugin>
        // +++
        <FloatingToolbar />
        // +++
        <FloatingComposer style={{ width: "350px" }} />
        <FloatingThreads threads={threads} style={{ width: "350px" }} />
      </LiveblocksPlugin>
      <RichTextPlugin
        contentEditable={<ContentEditable />}
        placeholder={<div>Enter some text...</div>}
        ErrorBoundary={LexicalErrorBoundary}
      />
    </LexicalComposer>
  );
}

----------------------------------------

TITLE: Verifying Webhook Request with verifyRequest
DESCRIPTION: The verifyRequest method checks the validity of a webhook request using the provided headers and raw body, and returns the event if the verification is successful.

LANGUAGE: javascript
CODE:
const event = webhookHandler.verifyRequest({
  headers: req.headers,
  rawBody: req.body,
});

----------------------------------------

TITLE: Delete Room with Liveblocks in TypeScript
DESCRIPTION: Deletes a room by ID. If the room doesn't exist or has already been deleted, no error will be thrown. This method returns no response.

LANGUAGE: typescript
CODE:
await liveblocks.deleteRoom("my-room-id");

----------------------------------------

TITLE: Removing Reactions with useRemoveReaction in Liveblocks
DESCRIPTION: Shows how to use useRemoveReaction hook to remove an emoji reaction from a comment.

LANGUAGE: tsx
CODE:
import { useRemoveReaction } from "@liveblocks/react/suspense";

const removeReaction = useRemoveReaction();
removeReaction({ threadId: "th_xxx", commentId: "cm_xxx", emoji: "👍" });

----------------------------------------

TITLE: Counting Unread Notifications with Client.getUnreadInboxNotificationsCount in TypeScript
DESCRIPTION: Shows how to get the number of unread inbox notifications for the current user. Returns a simple numeric count that can be used for UI indicators.

LANGUAGE: typescript
CODE:
const count = await client.getUnreadInboxNotificationsCount();

----------------------------------------

TITLE: Using move Method with LiveList in TypeScript
DESCRIPTION: Shows how to move an element from one index to another in a LiveList. The method rearranges the elements in the list.

LANGUAGE: typescript
CODE:
const list = new LiveList(["adrien", "chris", "jonathan"]);

list.move(2, 0);

// ["jonathan", "adrien", "chris"]
list.toImmutable();

----------------------------------------

TITLE: Error Handling with useNotificationSettings Hook in React
DESCRIPTION: Shows how to handle errors when using the useNotificationSettings hook. The example demonstrates checking the error field and displaying an appropriate error message to the user.

LANGUAGE: tsx
CODE:
import { useNotificationSettings } from "@liveblocks/react";

const [{ isLoading, error, settings }, updateSettings] =
  useNotificationSettings();

if (error) {
  return (
    <div>
      <p>Error loading user notification settings: {error.message}</p>
    </div>
  );
}

----------------------------------------

TITLE: Adding Delete Functionality to To-Do Items using LiveList.delete in JavaScript
DESCRIPTION: Enhancement to the to-do list implementation that adds delete buttons to each to-do item and implements the deletion functionality using LiveList.delete method. This allows any user to remove items from the shared list.

LANGUAGE: jsx
CODE:
import { createClient, LiveList } from "@liveblocks/client";

const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

async function run() {
  const { room, leave } = client.enterRoom("javascript-todo-app", {
    initialPresence: { isTyping: false },
    initialStorage: { todos: new LiveList() },
  });

  const whoIsHere = document.getElementById("who_is_here");
  const todoInput = document.getElementById("todo_input");
  const someoneIsTyping = document.getElementById("someone_is_typing");
  const todosContainer = document.getElementById("todos_container");

  const { root } = await room.getStorage();

  let todos = root.get("todos");

  room.subscribe("others", (others) => {
    /* ... */
  });

  todoInput.addEventListener("keydown", (e) => {
    /* ... */
  });

  todoInput.addEventListener("blur", () => {
    /* ... */
  });

  function renderTodos() {
    todosContainer.innerHTML = "";

    for (let i = 0; i < todos.length; i++) {
      const todo = todos.get(i);

      const todoContainer = document.createElement("div");
      todoContainer.classList.add("todo_container");

      const todoText = document.createElement("div");
      todoText.classList.add("todo");
      todoText.innerHTML = todo.text;
      todoContainer.appendChild(todoText);

      const deleteButton = document.createElement("button");
      deleteButton.classList.add("delete_button");
      deleteButton.innerHTML = "✕";
      deleteButton.addEventListener("click", () => {
        todos.delete(i);
      });
      todoContainer.appendChild(deleteButton);

      todosContainer.appendChild(todoContainer);
    }
  }

  room.subscribe(todos, () => {
    renderTodos();
  });

  renderTodos();
}

run();

----------------------------------------

TITLE: Creating a Comment with Additional Options in Liveblocks
DESCRIPTION: Shows the complete set of options available when creating a comment with liveblocks.createComment, including specifying the comment body, the user ID, and an optional creation timestamp.

LANGUAGE: typescript
CODE:
const comment = await liveblocks.createComment({
  roomId: "my-room-id",
  threadId: "th_d75sF3...",

  data: {
    // The comment's body, uses the `CommentBody` type
    body: {
      version: 1,
      content: [
        /* The comment's body text goes here, see above */
      ],
    },

    // The ID of the user that created the comment
    userId: "adrien@example.com",

    // The time the comment was created
    createdAt: new Date(),
  },
});

----------------------------------------

TITLE: Subscribing to Others' Presence in Liveblocks
DESCRIPTION: Shows how to subscribe to and access other users' presence data in a Liveblocks room. The callback provides typed access to presence information of other users in the room.

LANGUAGE: typescript
CODE:
const unsubscribe = room.subscribe("others", (others, event) => {
  // { status: "typing", cursor: { x: 45, y: 67 }
  console.log(others[0].presence);
});

----------------------------------------

TITLE: Handling Lost Connections in Liveblocks
DESCRIPTION: Demonstrates how to use the lost-connection event to handle network outages. This event fires when a previously connected client loses connection and cannot recover quickly.

LANGUAGE: typescript
CODE:
const unsubscribe = room.subscribe("lost-connection", (event) => {
  // "lost"
  console.log(event);
});

----------------------------------------

TITLE: Implementing pagination with useInboxNotifications in React
DESCRIPTION: Example showing how to implement a 'Load More' button using the pagination functionality provided by useInboxNotifications hook.

LANGUAGE: tsx
CODE:
import { InboxNotification } from "@liveblocks/react-ui";
import { useInboxNotifications } from "@liveblocks/react/suspense";

function Inbox() {
  const { inboxNotifications, hasFetchedAll, fetchMore, isFetchingMore } =
    useInboxNotifications();

  return (
    <div>
      {inboxNotifications.map((notification) => (
        <InboxNotification key={notification.id}>...</InboxNotification>
      ))}
      // +++
      {hasFetchedAll ? (
        <div>🎉 You're all caught up!</div>
      ) : (
        <button disabled={isFetchingMore} onClick={fetchMore}>
          Load more
        </button>
      )}
      // +++
    </div>
  );
}

----------------------------------------

TITLE: Implementing an Emoji Picker with Frimousse and Liveblocks
DESCRIPTION: Example of implementing an emoji picker using Frimousse alongside Liveblocks hooks to add emoji reactions to comments. This code shows how to set up the picker and handle emoji selection events.

LANGUAGE: tsx
CODE:
import { EmojiPicker } from "frimousse";
import { useAddReaction } from "@liveblocks/react/suspense";
import { CommentData } from "@liveblocks/react-ui";

export function MyEmojiPicker({ comment }: { comment: CommentData }) {
  const addReaction = useAddReaction();

  return (
    <EmojiPicker.Root
      onEmojiSelect={({ emoji }) => {
        addReaction({
          threadId: comment.threadId,
          commentId: comment.id,
          emoji,
        });
      }}
    >
      <EmojiPicker.Search />
      <EmojiPicker.Viewport>
        <EmojiPicker.Loading>Loading…</EmojiPicker.Loading>
        <EmojiPicker.Empty>No emoji found.</EmojiPicker.Empty>
        <EmojiPicker.List />
      </EmojiPicker.Viewport>
    </EmojiPicker.Root>
  );
}

----------------------------------------

TITLE: Resolving User and Room Data for Thread Notification Emails in Liveblocks
DESCRIPTION: Example of how to prepare thread notification emails as HTML by resolving user IDs into names and avatar URLs, and resolving room information for embedding in the email. This enables more personalized email notifications with user details and room links.

LANGUAGE: tsx
CODE:
const emailData = await prepareThreadNotificationEmailAsHtml(
  liveblocks,
  webhookEvent,
  {
    // +++
    resolveUsers: async ({ userIds }) => {
      const usersData = await __getUsersFromDB__(userIds);

      return usersData.map((userData) => ({
        name: userData.name, // "Nimesh"
        avatar: userData.avatar.src, // "https://..."
      }));
    },
    resolveRoomInfo({ roomId }) {
      return {
        name: roomId, // "my-room-name"
        url: `https://example.com/${roomId}`,
      };
    },
    // +++
  }
);

// { type: "unreadMention", comment: { ... }, ... }
console.log(emailData);

// { name: "Nimesh", avatar: "https://..." }
console.log(emailData.comment.author.info);

// { name: "my-room-name", url: "https://example.com/my-room-name" }
console.log(emailData.roomInfo);

----------------------------------------

TITLE: Using invalidateMentionSuggestions Resolver in TypeScript
DESCRIPTION: Shows how to invalidate all mention suggestions that were previously cached by the resolveMentionSuggestions function. Useful when updating a room's list of users.

LANGUAGE: typescript
CODE:
// Invalidate all mention suggestions
client.resolvers.invalidateMentionSuggestions();

----------------------------------------

TITLE: Updating Notification Settings with Client API in TypeScript
DESCRIPTION: Demonstrates how to update a user's notification settings across different channels like email and Slack. This modifies the current user's settings in every room and returns the updated settings.

LANGUAGE: typescript
CODE:
const settings = await client.updateNotificationSettings({
  email: { thread: false },
  slack: { textMention: true },
});

// { email: { thread: false, ... }, slack: { textMention: true, ... }, ... }
console.log(settings);

----------------------------------------

TITLE: Creating Documents Using Server Actions in Node.js API Endpoints
DESCRIPTION: Example of using the createDocument server action from a Next.js API endpoint to create a new document with specified properties.

LANGUAGE: typescript
CODE:
import { createDocument } from "@/lib/actions";

export async function POST() {
  // Create a new document
  const { data, error } = await createDocument({
    name: "My document",
    type: "whiteboard",
    userId: "charlie.layne@example.com",
  });

  // ...
}

----------------------------------------

TITLE: Error Handling with useThreads in Liveblocks React
DESCRIPTION: Demonstrates error handling for initial loading and subsequent fetch operations when using useThreads. Shows how to display appropriate error messages and implement retry mechanisms.

LANGUAGE: tsx
CODE:
import { useThreads } from "@liveblocks/react";

const { threads, error, fetchMore, fetchMoreError } = useThreads();

// Handle error if the initial load failed.
// The `error` field is not returned by the Suspense hook as the error is thrown to nearest ErrorBoundary
if (error) {
  return (
    <div>
      <p>Error loading threads: {error.message}</p>
    </div>
  );
}

return (
  <div>
    {threads.map((thread) => (
      <Thread key={thread.id}>...</Thread>
    ))}

    {fetchMoreError && (
      <div>
        <p>Error loading more threads: {fetchMoreError.message}</p>
        <button onClick={fetchMore}>Retry</button>
      </div>
    )}
  </div>
);

----------------------------------------

TITLE: Marking a Thread as Resolved in TypeScript
DESCRIPTION: Example of using the room.markThreadAsResolved method to change a thread's status to resolved. This method takes a thread ID and returns nothing.

LANGUAGE: ts
CODE:
await room.markThreadAsResolved("th_xxx");

----------------------------------------

TITLE: Constructing a Toolbar with Default Sections for Tiptap
DESCRIPTION: This code shows how to construct a custom toolbar using the default toolbar section components provided by Liveblocks, such as BlockSelector, SectionInline, and SectionCollaboration.

LANGUAGE: tsx
CODE:
import { Toolbar } from "@liveblocks/react-tiptap";
import { Editor } from "@tiptap/react";

function CustomToolbar({ editor }: { editor: Editor | null }) {
  return (
    <Toolbar editor={editor}>
      // +++
      <Toolbar.BlockSelector />
      <Toolbar.SectionInline />
      <Toolbar.Separator />
      <Toolbar.SectionCollaboration />
      // +++
    </Toolbar>
  );
}

----------------------------------------

TITLE: Typing Custom Notifications in TypeScript Configuration
DESCRIPTION: Shows how to type custom notifications by extending the ActivitiesData type in the Liveblocks config file, allowing for type-safe use of custom notification kinds.

LANGUAGE: typescript
CODE:
declare global {
  interface Liveblocks {
    // Custom activities data for custom notification kinds
    ActivitiesData: {
      // Example, a custom $alert kind
      $alert: {
        title: string;
        message: string;
      };
    };

    // Other kinds
    // ...
  }
}

----------------------------------------

TITLE: Retrieving Storage Document Data via Liveblocks REST API
DESCRIPTION: This code sets up a webhook handler to verify incoming webhook requests and retrieve the current room's Storage document data from the Liveblocks REST API when a storage update event is triggered.

LANGUAGE: typescript
CODE:
import { WebhookHandler } from "@liveblocks/node";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When Storage document data has been updated
  if (event.type === "storageUpdated") {
    const { roomId } = event.data;

    // Get Storage data from Liveblocks REST API
    const url = `https://api.liveblocks.io/v2/rooms/${roomId}/storage`;
    const response = await fetch(url, {
      headers: { Authorization: `Bearer ${API_SECRET}` },
    });

    if (!response.ok) {
      return new Response("Problem accessing Liveblocks REST APIs", {
        status: 500,
      });
    }

    // Your JSON Storage document data as a string
    const storageData = await response.text();

    // Update database
    // ...
  }

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Implementing Custom Submission Behavior with Composer Component
DESCRIPTION: Advanced example showing how to customize the submission behavior of the Composer by using event.preventDefault() and manually handling mutations. This example edits a comment and adds a reaction.

LANGUAGE: tsx
CODE:
import { Composer } from "@liveblocks/react-ui";
import { useEditComment, useAddReaction } from "@liveblocks/react/suspense";

// Custom submission behavior (edits a comment and adds a reaction)
function Component({ threadId, commentId }) {
  const editComment = useEditComment();
  const addReaction = useAddReaction();

  return (
    <Composer
      onComposerSubmit={({ body, attachments }, event) => {
        event.preventDefault();

        // Example mutations
        editComment({ threadId, commentId, body, attachments });
        addReaction({ threadId, commentId, emoji: "✅" });

        // Other custom behavior
        // ...
      }}
    />
  );
}

----------------------------------------

TITLE: Updating a Room with Liveblocks.updateRoom
DESCRIPTION: Shows how to update properties on an existing room. This method throws an error if the room isn't found in the project.

LANGUAGE: typescript
CODE:
const room = await liveblocks.updateRoom("my-room-id", {
  // The metadata or permissions you're updating
  // ...
});

// { type: "room", id: "my-room-id", metadata: {...}, ... }
console.log(room);

----------------------------------------

TITLE: Using useUpdateNotificationSettings Hook in React
DESCRIPTION: Shows how to use the useUpdateNotificationSettings hook to update a user's notification settings across all rooms in a project. The example demonstrates disabling thread notifications on the email channel.

LANGUAGE: tsx
CODE:
import { useUpdateNotificationSettings } from "@liveblocks/react";

const updateSettings = useUpdateNotificationSettings();

// Disabling thread notifications on the email channel
updateSettings({
  email: { thread: false },
});

----------------------------------------

TITLE: Implementing a Next.js API Route for Individual Room Access in Liveblocks
DESCRIPTION: A Next.js API route implementation that grants access to individual rooms by checking the room ID from the request body. The example includes authentication logic to verify if a user should have access to a specific room.

LANGUAGE: tsx
CODE:
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "sk_prod_xxxxxxxxxxxxxxxxxxxxxxxx",
});

export async function POST(request: Request) {
  // Get the current user from your database
  const user = __getUserFromDB__(request);

  // Start an auth session inside your endpoint
  const session = liveblocks.prepareSession(
    user.id,
    { userInfo: user.metadata } // Optional
  );

  const { room } = request.body;

  if (room && __shouldUserHaveAccess__(user, room)) {
    session.allow(room, session.FULL_ACCESS);
  }

  // Authorize the user and return the result
  const { status, body } = await session.authorize();
  return new Response(body, { status });
}

----------------------------------------

TITLE: Accessing other users in a Liveblocks room
DESCRIPTION: Getting the list of other users currently in the same room from the liveblocks state. Returns an empty array when no room is synced.

LANGUAGE: javascript
CODE:
const {
  liveblocks: { others },
} = useStore();

----------------------------------------

TITLE: Identifying a User with Group Access in Liveblocks
DESCRIPTION: This snippet demonstrates how to identify a user with group access using liveblocks.identifyUser(), assigning them to the 'engineering' group.

LANGUAGE: javascript
CODE:
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export async function POST(request: Request) {
  const { status, body } = await liveblocks.identifyUser({
    userId: "marie@example.com",
    groupIds: ["engineering"]
  });

  return new Response(body, { status });
}

----------------------------------------

TITLE: Setting up Yjs Provider with JavaScript
DESCRIPTION: Shows how to initialize a Yjs provider in a vanilla JavaScript application using the client.enterRoom method and getYjsProviderForRoom function from the @liveblocks/yjs package.

LANGUAGE: tsx
CODE:
import { createClient } from "@liveblocks/client";
import { getYjsProviderForRoom } from "@liveblocks/yjs";

const client = createClient({
  // Options
  // ...
});

const { room, leave } = client.enterRoom("my-room-id", {
  // Options
  // ...
});

const yProvider = getYjsProviderForRoom(room);
const yDoc = yProvider.getYDoc();

----------------------------------------

TITLE: Deleting Schema with Liveblocks API
DESCRIPTION: Deletes a schema using its ID (name@version format). This operation is only allowed if the schema is not attached to any room. Returns no response.

LANGUAGE: typescript
CODE:
await liveblocks.deleteSchema("my-schema-name@1");

----------------------------------------

TITLE: Creating a Synchronized Custom State Hook with Liveblocks and useState in TypeScript
DESCRIPTION: This snippet creates a custom React hook that extends useState with Liveblocks' real-time capabilities. The hook broadcasts state changes to all connected users using Liveblocks' event system and listens for changes from other users to keep the state synchronized across clients.

LANGUAGE: typescript
CODE:
import { useState } from "react";
import { useBroadcastEvent, useEventListener } from "./liveblocks.config";

function useCustomState() {
  const [state, setState] = useState();
  const broadcast = useBroadcastEvent();

  // Update useState and broadcast an event
  const setStateAndBroadcast = (newValue) => {
    setState(newValue);
    broadcast({ type: "STATE_UPDATE", data: newValue });
  };

  // Listen for the broadcast event
  useEventListener(({ event }) => {
    if (event.type === "STATE_UPDATE") {
      setState(event.data);
    }
  });

  return [state, setStateAndBroadcast];
}

----------------------------------------

TITLE: Typing Presence in Liveblocks
DESCRIPTION: Defines TypeScript types for Presence to enable type checking when working with presence data like status and cursor position.

LANGUAGE: typescript
CODE:
declare global {
  interface Liveblocks {
    Presence: {
      status: string;
      cursor: { x: number; y: number };
    };
  }
}

----------------------------------------

TITLE: Iterating Over LiveMap Entries in TypeScript
DESCRIPTION: Demonstrates how to use the entries method to iterate over key-value pairs in a LiveMap using a for...of loop.

LANGUAGE: typescript
CODE:
for (const [key, value] of map.entries()) {
  // Iterate over all the keys and values of the map
}

----------------------------------------

TITLE: Retrieving Thread Participants with Liveblocks API
DESCRIPTION: Fetches the list of participants from a thread. A participant is a user who has commented or been mentioned in the thread. Returns an array of participant IDs.

LANGUAGE: typescript
CODE:
const { participantIds } = await liveblocks.getThreadParticipants({
  roomId: "my-room-id",
  threadId: "th_d75sF3...",
});

// ["chris@example.com", "nimesh@example.com", ...]
console.log(participantIds);

----------------------------------------

TITLE: Get Active Users with Liveblocks in TypeScript
DESCRIPTION: Retrieves a list of users currently present in a room. Throws an error if the room isn't found. Returns an object containing user data.

LANGUAGE: typescript
CODE:
const activeUsers = await liveblocks.getActiveUsers("my-room-id");

// { data: [{ type: "user", id: "my-user-id", ... }, ...] }
console.log(activeUsers);

----------------------------------------

TITLE: Retrieving Room Info with useRoomInfo Hook in React
DESCRIPTION: Shows how to use the useRoomInfo hook to retrieve information about a room by its ID. Requires setting up a resolver function in createClient.

LANGUAGE: tsx
CODE:
import { useRoomInfo } from "@liveblocks/react/suspense";

const { info, error, isLoading } = useRoomInfo("room-id");

----------------------------------------

TITLE: Configuring WebSocket Throttle in LiveblocksProvider
DESCRIPTION: Example of setting the WebSocket throttle option in LiveblocksProvider to control the frequency of message updates. The throttle value is specified in milliseconds and can be set between 16 and 1000 ms to optimize performance and framerate.

LANGUAGE: tsx
CODE:
import { LiveblocksProvider } from "@liveblocks/react/suspense";

function App() {
  return (
    <LiveblocksProvider
      throttle={16}

      // Other options
      // ...
    >
      {/* children */}
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Handling Room ID Changes with Error Listener in React
DESCRIPTION: Implements an error listener to detect room ID changes and redirect users to the new room. This helps maintain user connection when a room's ID is updated.

LANGUAGE: tsx
CODE:
import { useErrorListener } from "@liveblocks/react/suspense";

function App() {
  useErrorListener((error) => {
    if (error.code === 4006) {
      // Room ID has been changed, get the new ID and redirect
      const newRoomId = error.message;
      __redirect__(`https://example.com/document/${newRoomId}}`);
    }
  });
}

----------------------------------------

TITLE: Triggering Custom Inbox Notifications with triggerInboxNotification in TypeScript
DESCRIPTION: Demonstrates how to trigger a custom inbox notification for a user, including setting a custom kind (prefixed with $), providing a subject ID, and including custom activity data.

LANGUAGE: typescript
CODE:
await liveblocks.triggerInboxNotification({
  // The ID of the user that will receive the inbox notification
  userId: "steven@example.com",

  // The custom notification kind, must start with a $
  kind: "$fileUploaded",

  // Custom ID for this specific notification
  subjectId: "my-file",

  // Custom data related to the activity that you need to render the inbox notification
  activityData: {
    // Data can be a string, number, or boolean
    file: "https://example.com/my-file.zip",
    size: 256,
    success: true,
  },

  // Optional, define the room ID the notification was sent from
  roomId: "my-room-id",
});

----------------------------------------

TITLE: Creating a Custom Toolbar with TypeScript
DESCRIPTION: This snippet demonstrates how to create a custom toolbar by composing various pre-built toolbar sections. It uses components like BlockSelector, SectionInline, and SectionCollaboration to build a customized toolbar experience.

LANGUAGE: tsx
CODE:
function CustomToolbar() {
  return (
    <Toolbar>
      // +++
      <Toolbar.BlockSelector />
      <Toolbar.SectionInline />
      <Toolbar.Separator />
      <Toolbar.SectionCollaboration />
      // +++
    </Toolbar>
  );
}

----------------------------------------

TITLE: Updating a Room to Make it Private in Liveblocks
DESCRIPTION: This snippet demonstrates how to modify an existing room to make it private by using liveblocks.updateRoom() and setting defaultAccesses to an empty array.

LANGUAGE: typescript
CODE:
const room = await liveblocks.updateRoom("a32wQXid4A9", {
  defaultAccesses: [],
});

----------------------------------------

TITLE: Handling Server-Broadcast Events in React
DESCRIPTION: Shows how to listen for custom events sent from the server using the Liveblocks React SDK. When receiving events from the server, user will be null and connectionId will be -1.

LANGUAGE: tsx
CODE:
import { useEventListener } from "@liveblocks/react/suspense";

// When receiving an event sent from `@liveblocks/node`
useEventListener(({ event, user, connectionId }) => {
  // `null`
  console.log(user);

  // `-1`
  console.log(connectionId);
});

----------------------------------------

TITLE: Using toImmutable Method with LiveList in TypeScript
DESCRIPTION: Demonstrates how to convert a LiveList into an immutable JavaScript array using the toImmutable method. Nested Live structures are also converted to immutable values.

LANGUAGE: typescript
CODE:
const list = new LiveList([
  new LiveObject({ name: "Olivier" }),
  new LiveObject({ name: "Vincent" }),
]);

// [
//   { name: "Olivier" },
//   { name: "Vincent" },
// ]
list.toImmutable();

----------------------------------------

TITLE: Using Document Functions in Client-Side Components with React
DESCRIPTION: Example of using createDocument server action in a client-side React component to handle document creation on button click.

LANGUAGE: tsx
CODE:
import { createDocument } from "@/lib/actions";

export function CreateDocumentButton() {
  async function handleCreateDocument() {
    // Create a new document
    const { data, error } = await createDocument({
      name: "My document",
      type: "whiteboard",
      userId: "charlie.layne@example.com",
    });
  }

  return <button onClick={handleCreateDocument}>New document</button>;
}

----------------------------------------

TITLE: Accessing length Property of LiveList in TypeScript
DESCRIPTION: Shows how to get the number of elements in a LiveList using the length property.

LANGUAGE: typescript
CODE:
const list = new LiveList(["adrien", "jonathan"]);

// 3
list.length; // equals

----------------------------------------

TITLE: Using getMentionedIdsFromCommentBody with getComment API
DESCRIPTION: An example showing how to retrieve a comment using the Liveblocks API and then extract mentioned user IDs from the comment body. The function returns an array of user IDs that were mentioned in the comment.

LANGUAGE: typescript
CODE:
import { Liveblocks, getMentionedIdsFromCommentBody } from "@liveblocks/node";

// Create a node client
const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

// Retrieve a comment
const comment = await liveblocks.getComment({
  roomId: "my-room-id",
  threadId: "my-thread-id",
  commentId: "my-comment-id",
});

// Get the mentions inside the comment's body
const mentionedIds = getMentionedIdsFromCommentBody(comment.body);

// ["marc@example.com", "vincent@example.com", ...]
console.log(mentionedIds);

----------------------------------------

TITLE: Installing the base-64 polyfill for React Native
DESCRIPTION: Command to install the base-64 library needed for the atob polyfill in React Native.

LANGUAGE: bash
CODE:
npm install base-64

----------------------------------------

TITLE: Setting a Single Field in Local User's Awareness State
DESCRIPTION: Shows how to update a single property in the user's awareness state using setLocalStateField.

LANGUAGE: typescript
CODE:
// Set a single property on the current user's awareness
awareness.setLocalStateField("user", { name: "Jonathan" });

----------------------------------------

TITLE: Example of User Resolution with Custom Properties
DESCRIPTION: Demonstrates how to implement the resolveUsers function with custom user properties. The example shows returning standard user information (name, avatar) plus a custom color property for each user.

LANGUAGE: typescript
CODE:
resolveUsers: async ({ userIds }) => {
  // ["marc@example.com"];
  console.log(userIds);

  return [
    {
      name: "Marc",
      avatar: "https://example.com/marc.png",
      // +++
      color: "purple",
      // +++
    },
  ];
};

----------------------------------------

TITLE: Using useBatch to Group Storage Modifications
DESCRIPTION: Shows how to use the useBatch hook to batch multiple storage modifications together as a single operation, though this method is now deprecated in favor of useMutation.

LANGUAGE: tsx
CODE:
import { useBatch } from "@liveblocks/react/suspense";

const batch = useBatch();
batch(() => {
  // All modifications made in this callback are batched
});

----------------------------------------

TITLE: Adding Presence to History in Liveblocks Room
DESCRIPTION: Demonstrates how to add presence values to the history stack using the addToHistory option, enabling undo/redo functionality for presence changes.

LANGUAGE: typescript
CODE:
room.updatePresence({ color: "blue" }, { addToHistory: true });
room.updatePresence({ color: "red" }, { addToHistory: true });
room.history.undo();

// { color: "blue" }
const presence = room.getPresence();

----------------------------------------

TITLE: Implementing Typing Indicator with Presence State
DESCRIPTION: Adding functionality to update the user's presence when typing and display a notification when other users are typing using useUpdateMyPresence hook.

LANGUAGE: tsx
CODE:
import {
  LiveblocksProvider,
  RoomProvider,
  ClientSideSuspense,
  useOthers,
  useUpdateMyPresence,
} from "@liveblocks/react/suspense";
import { useState } from "react";

/* WhoIsHere */

function TodoList() {
  const [draft, setDraft] = useState("");
  const updateMyPresence = useUpdateMyPresence();

  return (
    <div className="container">
      <WhoIsHere />
      <input
        type="text"
        placeholder="What needs to be done?"
        value={draft}
        onChange={(e) => {
          setDraft(e.target.value);
          updateMyPresence({ isTyping: true });
        }}
        onKeyDown={(e) => {
          if (e.key === "Enter") {
            updateMyPresence({ isTyping: false });
            setDraft("");
          }
        }}
        onBlur={() => updateMyPresence({ isTyping: false })}
      />
    </div>
  );
}

/* Page */

----------------------------------------

TITLE: Deleting an Inbox Notification with deleteInboxNotification in TypeScript
DESCRIPTION: Shows how to delete a specific inbox notification for a user by providing both the userId and inboxNotificationId.

LANGUAGE: typescript
CODE:
await liveblocks.deleteInboxNotification({
  userId: "steven@example.com",
  inboxNotificationId: "in_3dH7sF3...",
});

----------------------------------------

TITLE: Typing Presence in Liveblocks
DESCRIPTION: Shows how to add TypeScript type definitions for Presence data by extending the global Liveblocks interface. This example types the cursor property with x and y coordinates.

LANGUAGE: ts
CODE:
declare global {
  interface Liveblocks {
    Presence: {
      cursor: { x: number; y: number };
    };
  }
}

----------------------------------------

TITLE: Handling storageUpdated Webhook Events
DESCRIPTION: Extended webhook handler that checks for the storageUpdated event type and extracts the roomId for database update operations. This is the core logic that enables synchronizing Liveblocks Storage changes to your database.

LANGUAGE: typescript
CODE:
import { WebhookHandler } from "@liveblocks/node";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When Storage document data has been updated
  if (event.type === "storageUpdated") {
    const { roomId } = event.data;

    // Update database
    // ...
  }

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Using Custom Nodes with Lexical Documents
DESCRIPTION: Demonstrates how to work with custom Lexical nodes by passing them to the withLexicalDocument function. This is required when your document contains custom node types.

LANGUAGE: typescript
CODE:
import { CodeNode } from "@lexical/code";

await withLexicalDocument(
  { roomId: "my-room-id", client: liveblocks, nodes: [CodeNode] },
  async (doc) => {
    // Modify your Lexical `doc`
    // ...
  }
);

----------------------------------------

TITLE: Attaching Schema to Room with Liveblocks API
DESCRIPTION: Attaches a schema to a room using room ID and schema ID. This enables runtime schema validation in the room. Returns the schema details or throws an error if the room's storage doesn't match the schema.

LANGUAGE: typescript
CODE:
const schema = await liveblocks.attachSchemaToRoom(
  "my-room-id",
  "my-schema-name@1"
);

// { id: "my-schema-name@1", name: "my-schema-name", version: 1, ... }
console.log(schema);

----------------------------------------

TITLE: Accessing immutable data with useStorage selector
DESCRIPTION: Demonstrates how useStorage provides an immutable, read-only representation of the storage tree, making data consumption easier with normal JavaScript data structures.

LANGUAGE: tsx
CODE:
function Component() {
  useStorage((root) => ...);
  //          ^^^^
  //          Read-only. No mutable Live structures in here.
  //
  //          {
  //            animals: ["🦁", "🦊", "🐵"],
  //            mathematician: { firstName: "Ada", lastName: "Lovelace" },
  //            fruitsByName: new Map([
  //              ["apple", "🍎"],
  //              ["banana", "🍌"],
  //              ["cherry", "🍒"],
  //            ])
  //          }
  //
}

----------------------------------------

TITLE: Adding Live Cursors to the Collaborative Editor
DESCRIPTION: Enhanced version of the Editor component that adds support for live cursors. Uses the useSelf hook to access user information and passes color and username to the CollaborationPlugin.

LANGUAGE: tsx
CODE:
import { useSelf } from "../liveblocks.config";
// ...

export default function Editor() {
  // Get Liveblocks room, and user info from Liveblocks authentication endpoint
  const room = useRoom();
  const userInfo = useSelf((me) => me.info);

  return (
    <div className={styles.container}>
      <LexicalComposer initialConfig={initialConfig}>
        <div className={styles.editorContainer}>
          <RichTextPlugin
            contentEditable={<ContentEditable className={styles.editor} />}
            placeholder={
              <p className={styles.placeholder}>Start typing here…</p>
            }
            ErrorBoundary={LexicalErrorBoundary}
          />
          <CollaborationPlugin
            id="yjs-plugin"
            cursorColor={userInfo.color}
            username={userInfo.name}
            providerFactory={(id, yjsDocMap) => {
              // Set up Liveblocks Yjs provider
              const doc = new Y.Doc();
              yjsDocMap.set(id, doc);
              const provider = new LiveblocksYjsProvider(room, doc) as Provider;
              return provider;
            }}
            initialEditorState={initialEditorState}
            shouldBootstrap={true}
          />
        </div>
      </LexicalComposer>
    </div>
  );
}

----------------------------------------

TITLE: Implementing HistoryVersionPreview Component
DESCRIPTION: Shows how to use the HistoryVersionPreview component to display a specific version of editor content with restore functionality. This component must be used within the LiveblocksPlugin context.

LANGUAGE: tsx
CODE:
import { HistoryVersionPreview } from "@liveblocks/react-tiptap";

function VersionPreview({ selectedVersion, onVersionRestore }) {
  return (
    <HistoryVersionPreview
      version={selectedVersion}
      onVersionRestore={onVersionRestore}
    />
  );
}

----------------------------------------

TITLE: HistoryVersionPreview Component Implementation
DESCRIPTION: Example showing how to implement the HistoryVersionPreview component to display and restore specific versions of BlockNote editor content.

LANGUAGE: tsx
CODE:
import { HistoryVersionPreview } from "@liveblocks/react-blocknote";

function VersionPreview({ selectedVersion, onVersionRestore }) {
  return (
    <HistoryVersionPreview
      version={selectedVersion}
      onVersionRestore={onVersionRestore}
    />
  );
}

----------------------------------------

TITLE: Typing Custom Events in Liveblocks
DESCRIPTION: Defines TypeScript types for custom room events using a union type to support multiple event types with different structures.

LANGUAGE: typescript
CODE:
declare global {
  interface Liveblocks {
    RoomEvent:
      | { type: "REACTION"; emoji: string }
      | { type: "ACTION"; action: string };
  }
}

----------------------------------------

TITLE: Checking for ThreadNotificationEvent with Type Guard
DESCRIPTION: The isThreadNotificationEvent function is a type guard that checks if a webhook event is a ThreadNotificationEvent from Comments, useful for creating thread notification emails.

LANGUAGE: javascript
CODE:
import { isThreadNotificationEvent } from "@liveblocks/node";

const event = webhookHandler.verifyRequest({
  headers: req.headers,
  rawBody: req.body,
});

// +++
if (isThreadNotificationEvent(event)) {
  // Handle `ThreadNotificationEvent`
}
// +++

----------------------------------------

TITLE: Implementing useMyPresence Hook in React Component
DESCRIPTION: React component using the useMyPresence hook from Liveblocks to access and display the current user's presence data, specifically cursor information.

LANGUAGE: tsx
CODE:
import { useMyPresence } from "@liveblocks/react/suspense";

export function Room() {
  const [myPresence, updateMyPresence] = useMyPresence();

  return <div>Cursor: {JSON.stringify(myPresence.cursor)}</div>;
}

----------------------------------------

TITLE: Resolving User IDs to User Objects
DESCRIPTION: Implements a resolver function for Comments feature to convert user IDs into user objects containing display information. This function asynchronously fetches user data from a database and returns name and avatar information.

LANGUAGE: tsx
CODE:
import { createClient } from "@liveblocks/client";

const client = createClient({
  resolveUsers: async ({ userIds }) => {
    const usersData = await __getUsersFromDB__(userIds);

    return usersData.map((userData) => ({
      name: userData.name,
      avatar: userData.avatar.src,
    }));
  },

  // Other options
  // ...
});

----------------------------------------

TITLE: Broadcasting Events When Disconnected in Liveblocks Room
DESCRIPTION: Demonstrates how to queue up events to be sent when the connection is (re)established by using the shouldQueueEventIfNotReady option in broadcastEvent.

LANGUAGE: typescript
CODE:
room.broadcastEvent(
  { type: "REACTION", emoji: "🔥" },
  {
    // +++
    shouldQueueEventIfNotReady: true,
    // +++
  }
);

----------------------------------------

TITLE: Updating Notification Settings with updateNotificationSettings in TypeScript
DESCRIPTION: Demonstrates how to update a user's notification settings, which controls which notification webhook events will be sent for the user.

LANGUAGE: typescript
CODE:
const updatedSettings = await liveblocks.updateNotificationSettings({
  userId: "steven@example.com",
  data: {
    email: { thread: false },
    slack: { textMention: true },
  },
});

// { email: { thread: false, ... }, slack: { textMention: true, ... }, ... }
console.log(updatedSettings);

----------------------------------------

TITLE: Installing Liveblocks and Tiptap Dependencies
DESCRIPTION: Command to install all necessary packages for implementing Liveblocks with Tiptap in a React application. Ensures all Liveblocks packages use the same version.

LANGUAGE: bash
CODE:
npm install @liveblocks/client @liveblocks/react @liveblocks/react-ui @liveblocks/react-tiptap @tiptap/react @tiptap/starter-kit

----------------------------------------

TITLE: Using getMentionedIdsFromCommentBody with Custom CommentBody
DESCRIPTION: Shows how to use getMentionedIdsFromCommentBody with a manually created CommentBody object. This example demonstrates the structure of a CommentBody and how mentions are represented within it.

LANGUAGE: typescript
CODE:
import { CommentBody, getMentionedIdsFromCommentBody } from "@liveblocks/node";

// Create a custom `CommentBody`
const commentBody: CommentBody = {
  version: 1,
  content: [
    {
      type: "paragraph",
      children: [
        { text: "Hello " },
        { type: "mention", id: "chris@example.com" },
      ],
    },
  ],
};

// Get the mentions inside the comment's body
const mentionedIds = getMentionedIdsFromCommentBody(commentBody);

// ["chris@example.com"]
console.log(mentionedIds);

----------------------------------------

TITLE: Accessing Awareness from Room Presence
DESCRIPTION: Demonstrates how to access the Yjs awareness object through the room's presence using getPresence method.

LANGUAGE: typescript
CODE:
// Yjs awareness
const awareness = room.getPresence().__yjs;

----------------------------------------

TITLE: Retrieving Threads from Room with Liveblocks API
DESCRIPTION: Fetches a list of threads from a specific room. Returns an array of thread objects or throws an error if the room is not found.

LANGUAGE: typescript
CODE:
const { data: threads } = await liveblocks.getThreads({
  roomId: "my-room-id",
});

// [{ type: "thread", id: "th_d75sF3...", ... }, ...]
console.log(threads);

----------------------------------------

TITLE: Setting Background Keep-Alive Timeout
DESCRIPTION: Configures the Liveblocks client to automatically disconnect inactive background tabs after a specified timeout period. When the tab is refocused, the client will immediately reconnect and synchronize.

LANGUAGE: typescript
CODE:
import { createClient } from "@liveblocks/client";

const client = createClient({
  // Disconnect users after 15 minutes of inactivity
  backgroundKeepAliveTimeout: 15 * 60 * 1000,

  // Other options
  // ...
});

----------------------------------------

TITLE: Broadcast Custom Event with Liveblocks in TypeScript
DESCRIPTION: Sends a custom event to all users in a room. Throws an error if the room isn't found. This can be used to notify clients of server-side events.

LANGUAGE: typescript
CODE:
const customEvent = {
  type: "EMOJI",
  emoji: "🔥",
};

await liveblocks.broadcastEvent("my-room-id", customEvent);

----------------------------------------

TITLE: Implementing resolveMentionSuggestions for Comments in LiveblocksProvider
DESCRIPTION: Example showing how to set up the resolveMentionSuggestions function to enable mentions in Comments within the Liveblocks provider.

LANGUAGE: tsx
CODE:
import { LiveblocksProvider } from "@liveblocks/react/suspense";

function App() {
  return (
    <LiveblocksProvider
      resolveMentionSuggestions={async ({ text, roomId }) => {
        const workspaceUsers = await __getWorkspaceUsersFromDB__(roomId);

        if (!text) {
          // Show all workspace users by default
          return __getUserIds__(workspaceUsers);
        } else {
          const matchingUsers = __findUsers__(workspaceUsers, text);
          return __getUserIds__(matchingUsers);
        }
      }}

      // Other props
      // ...
    >
      {/* children */}
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Using Generic Presence Type with Zustand Middleware
DESCRIPTION: Example showing how to type the 'others' presence when using Liveblocks with Zustand. This demonstrates how to define a Presence type and use it with the middleware's generic parameter for proper type checking.

LANGUAGE: ts
CODE:
type Presence = {
  isTyping: true;
}

const useStore = create(
  middleware<State, Presence>(/* ... */, {
    client,
    presenceMapping: { isTyping: true },
    storageMapping: { todos: true }
  })
);

// In your component
useStore(state => state.liveblocks.others[0].presence?.isTyping)

----------------------------------------

TITLE: Replacing room.subscribe() with useStorage Selectors
DESCRIPTION: Shows how to replace low-level room.subscribe() calls with useStorage and appropriate selector functions to automatically handle subscriptions to nested or computed data.

LANGUAGE: tsx
CODE:
// ✅ Automatically rerenders if pets changes (but not more often)
const nested = useStorage((root) => root.scientist.pets);

LANGUAGE: tsx
CODE:
// ✅ Automatically rerenders if computed value changes
const sum = useStorage((root) => root.a + root.b);

----------------------------------------

TITLE: Converting LiveObject to JavaScript Object with toObject Method
DESCRIPTION: Shows how to transform a LiveObject into a normal JavaScript object using the toObject method. Note that this method will be deprecated in the future.

LANGUAGE: typescript
CODE:
const liveObject = new LiveObject({ firstName: "Grace", lastName: "Hopper" });
liveObject.toObject();
// { firstName: "Grace", lastName: "Hopper" }

----------------------------------------

TITLE: Creating a Basic Toolbar for Monaco Editor
DESCRIPTION: A simple toolbar component with undo and redo buttons for Monaco Editor. Uses the Monaco editor API to trigger standard undo/redo commands through button clicks.

LANGUAGE: tsx
CODE:
import styles from "./Toolbar.module.css";
import { editor } from "monaco-editor";

type Props = {
  editor: editor.IStandaloneCodeEditor;
};

export function Toolbar({ editor }: Props) {
  return (
    <div className={styles.toolbar}>
      <button
        className={styles.button}
        onClick={() => editor.trigger("", "undo", null)}
      >
        Undo
      </button>
      <button
        className={styles.button}
        onClick={() => editor.trigger("", "redo", null)}
      >
        Redo
      </button>
    </div>
  );
}

----------------------------------------

TITLE: Using Primitive Components with asChild Composition Pattern
DESCRIPTION: Example of how to use LiveBlocks primitives with the asChild composition pattern. This allows replacing the default elements with custom components while merging props and behavior.

LANGUAGE: tsx
CODE:
import { Button } from "@/my-design-system";

// Use the default <button> element
<Composer.Submit disabled>Send</Composer.Submit>;

// Use an existing custom <Button> component
<Composer.Submit disabled asChild>
  <Button variant="primary">Send</Button>
</Composer.Submit>;

----------------------------------------

TITLE: Typing Multiple Custom Events in Liveblocks Room
DESCRIPTION: Shows how to define TypeScript types for multiple different custom events using a union type in the RoomEvent interface, providing proper type hints in the application.

LANGUAGE: typescript
CODE:
declare global {
  interface Liveblocks {
    RoomEvent:
      | { type: "REACTION"; emoji: string }
      | { type: "ACTION"; action: string };
  }
}

LANGUAGE: typescript
CODE:
room.subscribe("event", ({ event, user, connectionId }) => {
  if (event.type === "REACTION") {
    // Do something
  }
  if (event.type === "ACTION") {
    // Do something else
  }
});

----------------------------------------

TITLE: Adding Canvas Event Handlers for Shape Movement
DESCRIPTION: Updates the App component to handle pointer movement and pointer up events on the canvas. These event handlers dispatch actions to update shape positions during drag operations and reset the dragging state when finished.

LANGUAGE: jsx
CODE:
import { useEffect } from "react";
import "./App.css";
import { useDispatch, useSelector } from "react-redux";
import { actions } from "@liveblocks/redux";

import {
  insertRectangle,
  onShapePointerDown,
  deleteShape,
  onCanvasPointerUp,
  onCanvasPointerMove,
} from "./store";

const roomId = "redux-whiteboard";

export default function App() {
  const shapes = useSelector((state) => state.shapes);
  const isLoading = useSelector((state) => state.liveblocks.isStorageLoading);
  const selectedShape = useSelector((state) => state.selectedShape);
  const others = useSelector((state) => state.liveblocks.others);

  const dispatch = useDispatch();

  /* ... */

  return (
    <>
      <div
        className="canvas"
        onPointerMove={(e) => {
          e.preventDefault();
          dispatch(onCanvasPointerMove({ x: e.clientX, y: e.clientY }));
        }}
        onPointerUp={() => {
          dispatch(onCanvasPointerUp());
        }}
      >
        {/* ... */}
      </div>
      <div className="toolbar">{/* ... */}</div>
    </>
  );
}

/* ... */

----------------------------------------

TITLE: Creating a Custom Mention Component for Composer.Editor
DESCRIPTION: Demonstrates how to implement a custom Mention component that displays userIds with an @ prefix for use within the Composer.Editor.

LANGUAGE: tsx
CODE:
<Composer.Editor
  components={{
    Mention: ({ userId, isSelected }) => (
      <Composer.Mention>@{userId}</Composer.Mention>
    ),
  }}
/>

----------------------------------------

TITLE: Fetching User Information with useUser Hook in React
DESCRIPTION: This snippet shows how to use the useUser hook to fetch user information from a user ID, allowing access to custom user data like name and avatar.

LANGUAGE: tsx
CODE:
import { useUser } from "../liveblocks.config";

function Component() {
  const { user } = useUser("olivier@example.com");

  // { name: "Olivier", avatar: "https://...", color: "red" }
  console.log(user);

  return <img src={user.avatar} alt={user.name} />;
}

----------------------------------------

TITLE: Setting Up Authentication Endpoint in Next.js App Router
DESCRIPTION: Implementation of the authentication endpoint in Next.js app directory. This code creates a secure API route that grants users permission to access rooms based on organizational patterns using wildcards.

LANGUAGE: typescript
CODE:
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export async function POST(request: Request) {
  // Get the current user from your database
  const user = __getUserFromDB__(request);

  // Start an auth session inside your endpoint
  const session = liveblocks.prepareSession(
    user.id,
    { userInfo: user.metadata } // Optional
  );

  // Use a naming pattern to allow access to rooms with wildcards
  // Giving the user read access on their org, and write access on their group
  session.allow(`${user.organization}:*`, session.READ_ACCESS);
  session.allow(`${user.organization}:${user.group}:*`, session.FULL_ACCESS);

  // Authorize the user and return the result
  const { status, body } = await session.authorize();
  return new Response(body, { status });
}

----------------------------------------

TITLE: Implementing HistoryVersionPreview Component
DESCRIPTION: Implementation of the HistoryVersionPreview component for displaying a preview of a specific version of the Lexical editor's content, including version restoration functionality through a callback.

LANGUAGE: tsx
CODE:
import { HistoryVersionPreview } from "@liveblocks/react-lexical";

function VersionPreview({ selectedVersion, onVersionRestore }) {
  return (
    <HistoryVersionPreview
      version={selectedVersion}
      onVersionRestore={onVersionRestore}
    />
  );
}

----------------------------------------

TITLE: WebSocket Throttle Values and Corresponding FPS
DESCRIPTION: Common throttle values and their approximate frames per second (FPS). These settings can be used to fine-tune the real-time performance of Liveblocks applications based on the required responsiveness.

LANGUAGE: ts
CODE:
throttle:  16, // 60 FPS
throttle:  32, // 30 FPS
throttle: 200, //  5 FPS

----------------------------------------

TITLE: Styling for Live Avatars Component
DESCRIPTION: CSS module for styling the avatars component. It includes styles for avatar display, tooltip functionality, and responsive layout to show multiple users in a compact format.

LANGUAGE: css
CODE:
.avatars {
  display: flex;
  padding: 0 0.75rem;
}

.avatar {
  display: flex;
  place-content: center;
  position: relative;
  border: 4px solid #fff;
  border-radius: 9999px;
  width: 42px;
  height: 42px;
  background-color: #9ca3af;
  margin-left: -0.75rem;
}

.avatar:before {
  content: attr(data-tooltip);
  position: absolute;
  top: 100%;
  opacity: 0;
  transition: opacity 0.15s ease;
  padding: 5px 10px;
  color: white;
  font-size: 0.75rem;
  border-radius: 8px;
  margin-top: 10px;
  z-index: 1;
  background: black;
  white-space: nowrap;
}

.avatar:hover:before {
  opacity: 1;
}

.avatar_picture {
  width: 100%;
  height: 100%;
  border-radius: 9999px;
}

----------------------------------------

TITLE: Creating an Empty LiveMap in TypeScript
DESCRIPTION: Demonstrates how to create a new empty LiveMap instance using the constructor without arguments.

LANGUAGE: typescript
CODE:
const map = new LiveMap();

----------------------------------------

TITLE: Updating Room Permissions to Read-Only in Liveblocks
DESCRIPTION: This snippet demonstrates how to update an existing room to have read-only access by default using the liveblocks.updateRoom method. This allows users to view the room and update their presence, but not modify room storage.

LANGUAGE: typescript
CODE:
const room = await liveblocks.updateRoom("Vu78Rt:design:9Hdu73", {
  defaultAccesses: ["room:read", "room:presence:write"],
});

----------------------------------------

TITLE: Preventing Users from Losing Unsaved Changes
DESCRIPTION: Configures the Liveblocks client to warn users when closing a tab with unsaved changes. This option triggers a dialog using the beforeunload event when there are pending synchronizations or offline changes.

LANGUAGE: tsx
CODE:
import { createClient } from "@liveblocks/client";

const client = createClient({
  preventUnsavedChanges: true,

  // Other options
  // ...
});

----------------------------------------

TITLE: Pausing History Changes in Liveblocks Room (TypeScript)
DESCRIPTION: Demonstrates how to use room.history.pause() to merge multiple modifications into a single history item. When used with resume(), all changes made between pause and resume can be undone in a single undo operation.

LANGUAGE: typescript
CODE:
const info = new LiveObject({ time: "one" });

room.history.pause();
info.set("time", "two");
info.set("time", "three");
room.history.resume();

room.history.undo();

// "one"
room.get("time");

----------------------------------------

TITLE: Constructing Comment Body for Liveblocks Thread
DESCRIPTION: Shows how to construct a properly formatted comment body using the CommentBody type with rich text formatting. Includes an example with bold text formatting.

LANGUAGE: typescript
CODE:
import { CommentBody } from "@liveblocks/node";

const body: CommentBody = {
  version: 1,
  content: [
    {
      type: "paragraph",
      children: [{ text: "Hello " }, { text: "world", bold: true }],
    },
  ],
};

const thread = await liveblocks.createThread({
  roomId: "my-room-id",

  data: {
    // ...
    comment: {
      // The comment's body, uses the `CommentBody` type
      body,

      // ...
    },
  },
});

----------------------------------------

TITLE: Implementing a Custom Thread Creation Composer with LiveBlocks
DESCRIPTION: A complete example showing how to use the Composer component with useCreateThread hook from LiveBlocks to create a new thread, including custom components for mentions, mention suggestions, and links.

LANGUAGE: tsx
CODE:
import {
  Composer,
  CommentBodyLinkProps,
  CommentBodyMentionProps,
  ComposerEditorMentionSuggestionsProps,
  ComposerSubmitComment,
} from "@liveblocks/react-ui/primitives";
import { useCreateThread, useUser } from "@liveblocks/react/suspense";
import { FormEvent } from "react";

// Render a custom composer that creates a thread on submit
function MyComposer() {
  // +++
  const createThread = useCreateThread();
  // +++

  function handleComposerSubmit(
    { body, attachments }: ComposerSubmitComment,
    event: FormEvent<HTMLFormElement>
  ) {
    event.preventdefault();

    // Create a new thread
    // +++
    const thread = createThread({
      body,
      attachments,
      metadata: {},
    });
    //+++
  }

  return (
    // +++
    <Composer.Form onComposerSubmit={handleComposerSubmit}>
      <Composer.Editor
        components={{
          Mention,
          MentionSuggestions,
          Link,
        }}
      />
      <Composer.Submit>Create thread</Composer.Submit>
    </Composer.Form>
    // +++
  );
}

// Render a mention in the composer's editor, e.g. "@Emil Joyce"
function Mention({ userId }: CommentBodyMentionProps) {
  return <Comment.Mention>@{userId}</Comment.Mention>;
}

// Render a list of mention suggestions, used after typing "@" in the editor
function MentionSuggestions({
  userIds,
  selectedUserId,
}: ComposerEditorMentionSuggestionsProps) {
  return (
    <Composer.Suggestions>
      <Composer.SuggestionsList>
        {userIds.map((userId) => (
          <MentionSuggestion key={userId} userId={userId} />
        ))}
      </Composer.SuggestionsList>
    </Composer.Suggestions>
  );
}

// Render a single mention suggestion from a `userId`
function MentionSuggestion({ userId }: { userId: string }) {
  const { user } = useUser(userId);

  return (
    <Composer.SuggestionsListItem value={user.id}>
      <img src={user.avatar} alt={user.name} />
      {user.name}
    </Composer.SuggestionsListItem>
  );
}

// Render a link in the composer's editor, e.g. "https://liveblocks.io"
function Link({ href, children }: CommentBodyLinkProps) {
  return <Comment.Link href={href}>{children}</Comment.Link>;
}

----------------------------------------

TITLE: Emitting Destroyed Event from Awareness
DESCRIPTION: Demonstrates how to manually trigger the destroyed event on the awareness object.

LANGUAGE: typescript
CODE:
// Call each listener and pass `true` as an argument
awareness.emit("destroy", true);

----------------------------------------

TITLE: Accessing Headless Lexical Editor
DESCRIPTION: Demonstrates retrieving a headless Lexical editor instance using getLexicalEditor method. This provides access to the underlying editor functionality for advanced operations.

LANGUAGE: typescript
CODE:
const headlessEditor = await withLexicalDocument(
  { roomId: "my-room-id", client: liveblocks },
  async (doc) => {
    return doc.getLexicalEditor();
  }
);

----------------------------------------

TITLE: Basic Implementation of FloatingComposer in React-Lexical
DESCRIPTION: Shows the basic implementation of FloatingComposer, which displays a comment composer near the current text selection. It must be nested inside the LiveblocksPlugin.

LANGUAGE: tsx
CODE:
<LexicalComposer initialConfig={initialConfig}>
  <LiveblocksPlugin>
    <FloatingComposer />
  </LiveblocksPlugin>
</LexicalComposer>

----------------------------------------

TITLE: Styling Liveblocks Components with Data Attributes
DESCRIPTION: Demonstrates how to target specific variants or states of Liveblocks components using data attributes, allowing for conditional styling based on component context.

LANGUAGE: css
CODE:
.lb-button[data-variant="primary"] {
  /* Customise primary buttons */
}

.lb-avatar[data-loading] {
  /* Customise avatar loading state */
}

----------------------------------------

TITLE: Deleting a Room's Storage Document in Liveblocks
DESCRIPTION: Uses deleteStorageDocument to remove a room's Storage data, which disconnects all active users from the room. This method throws an error if the room doesn't exist.

LANGUAGE: typescript
CODE:
await liveblocks.deleteStorageDocument("my-room-id");

----------------------------------------

TITLE: Using Timestamp Primitive for Friendly Date Formatting in React
DESCRIPTION: Shows how to use the Timestamp primitive to convert dates or timestamps into user-friendly formats like '5 minutes ago' for recent comments or formatted dates for older content.

LANGUAGE: tsx
CODE:
import { Timestamp } from "@liveblocks/react-ui";
import { useThreads } from "../liveblocks.config";

// Render threads with friendly datetime messages above
function Component() {
  const { threads } = useThreads();

  return (
    <>
      {threads.map((thread) => (
        <div key={thread.id}>
          Thread posted at: <Timestamp date={thread.createdAt} />
          {/* Render `thread` ... */}
        </div>
      ))}
    </>
  );
}

----------------------------------------

TITLE: Using Liveblocks Hooks for User Presence in Next.js
DESCRIPTION: Implementation of a collaborative React component using the useOthers hook from Liveblocks. This hook provides information about other users connected to the same room.

LANGUAGE: tsx
CODE:
"use client";

import { useOthers } from "@liveblocks/react/suspense";

export function CollaborativeApp() {
  const others = useOthers();
  const userCount = others.length;
  return <div>There are {userCount} other user(s) online</div>;
}

----------------------------------------

TITLE: Retrieving a Single Room with Liveblocks.getRoom
DESCRIPTION: Shows how to retrieve a specific room by its ID. This method throws an error if the room isn't found in the project.

LANGUAGE: typescript
CODE:
const room = await liveblocks.getRoom("my-room-id");

// { type: "room", id: "my-room-id", metadata: {...}, ... }
console.log(room);

----------------------------------------

TITLE: Using useDeleteInboxNotification hook in React
DESCRIPTION: Demonstrates how to delete a specific inbox notification for the current user using its ID.

LANGUAGE: tsx
CODE:
import { useDeleteInboxNotification } from "@liveblocks/react/suspense";

const deleteInboxNotification = useDeleteInboxNotification();
deleteInboxNotification("in_xxx");

----------------------------------------

TITLE: Joining a Liveblocks Room with ClientSideSuspense
DESCRIPTION: React component implementing ClientSideSuspense to provide a loading state while connecting to a Liveblocks room.

LANGUAGE: tsx
CODE:
"use client";

import {
  LiveblocksProvider,
  RoomProvider,
  ClientSideSuspense,
} from "@liveblocks/react/suspense";
import { Room } from "./Room";

export default function App() {
  return (
    <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"} >
      <RoomProvider id="my-room">
        <ClientSideSuspense fallback={<div>Loading…</div>}>
          <Room />
        </ClientSideSuspense>
      </RoomProvider>
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Updating Notification Settings with updateSettings in React
DESCRIPTION: Demonstrates how to use the updateSettings function to update a user's notification settings for all rooms in a project. Shows examples of passing partials, enabling custom notifications, and setting complex settings across different channels.

LANGUAGE: tsx
CODE:
// You only need to pass partials
updateSettings({
  email: { thread: true },
});

// Enabling a custom notification on the slack channel
updateSettings({
  slack: { $myCustomNotification: true },
});

// Setting complex settings
updateSettings({
  email: {
    thread: true,
    textMention: false,
    $newDocument: true,
  },
  slack: {
    thread: false,
    $fileUpload: false,
  },
  teams: {
    thread: true,
  },
});

----------------------------------------

TITLE: Retrieving Size of LiveMap in TypeScript
DESCRIPTION: Shows how to get the number of elements in a LiveMap using the size property. The example creates a new LiveMap with two key-value pairs and returns the count of entries.

LANGUAGE: typescript
CODE:
const map = new LiveMap([
  ["nimesh", "developer"],
  ["pierre", "designer"],
]);

// 2
map.size;

----------------------------------------

TITLE: Eliminating Manual Conversions from Live Structures
DESCRIPTION: Shows how useStorage returns normal JavaScript data structures directly, eliminating the need for manual conversion methods like toObject() and toArray().

LANGUAGE: tsx
CODE:
// ❌
obj.toObject();
list.toArray();

LANGUAGE: tsx
CODE:
// ✅
obj; // Already a normal JS object
list; // Already a normal JS array

----------------------------------------

TITLE: Basic Implementation of FloatingToolbar in React-Lexical
DESCRIPTION: Shows the basic implementation of FloatingToolbar, which displays a contextual toolbar near the current Lexical text selection for formatting. It should be nested inside the LiveblocksPlugin component.

LANGUAGE: tsx
CODE:
<LexicalComposer initialConfig={initialConfig}>
  <LiveblocksPlugin>
    // +++
    <FloatingToolbar />
    // +++
  </LiveblocksPlugin>
</LexicalComposer>

----------------------------------------

TITLE: Get Storage Document in JSON Format with Liveblocks
DESCRIPTION: Retrieves the contents of a room's Storage tree in JSON format, which simplifies the data structure by removing LSON type information. This is useful for data processing outside of Liveblocks.

LANGUAGE: typescript
CODE:
// Retrieve JSON Storage data
const storage = await liveblocks.getStorageDocument("my-room-id", "json");

// If this were your Storage type...
declare global {
  interface Liveblocks {
    Storage: {
      names: LiveList<string>;
    };
  }
}

// {
//   names: ["Olivier", "Nimesh"]
// }
console.log(storage);

----------------------------------------

TITLE: Creating a Room with Liveblocks.createRoom
DESCRIPTION: Shows how to programmatically create a new room with a specified ID and default access permissions. Setting defaultAccesses to ["room:write"] creates a public room, while [] creates a private room.

LANGUAGE: typescript
CODE:
const room = await liveblocks.createRoom("my-room-id", {
  defaultAccesses: ["room:write"],
});

// { type: "room", id: "my-room-id", metadata: {...}, ... }
console.log(room);

----------------------------------------

TITLE: Synchronizing Yjs Document Data with Vercel Postgres Database
DESCRIPTION: This code extends the webhook handler to store Yjs document data in a Vercel Postgres database. When a 'ydocUpdated' event is received, it fetches the latest Yjs data, creates a 'documents' table if it doesn't exist, and inserts or updates the document data using an UPSERT operation.

LANGUAGE: typescript
CODE:
import { WebhookHandler } from "@liveblocks/node";
import { sql } from "@vercel/postgres";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When Yjs document data has been updated
  if (event.type === "ydocUpdated") {
    const { roomId } = event.data;

    // Get Yjs data from Liveblocks REST API
    const url = `https://api.liveblocks.io/v2/rooms/${roomId}/ydoc`;
    const response = await fetch(url, {
      headers: { Authorization: `Bearer ${API_SECRET}` },
    });

    if (!response.ok) {
      return new Response("Problem accessing Liveblocks REST APIs", {
        status: 500,
      });
    }

    // Your JSON Yjs document data as a string
    const yDocData = await response.text();

    // Update database
    try {
      await sql`
        CREATE TABLE IF NOT EXISTS documents (
          roomId VARCHAR(255) PRIMARY KEY,
          yDocData TEXT NOT NULL
        );
      `;
      await sql`
        INSERT INTO documents (roomId, yDocData)
        VALUES (${roomId}, ${yDocData})
        ON CONFLICT (roomId)
        DO UPDATE SET
          yDocData = EXCLUDED.yDocData
      `;
    } catch (err) {
      return new Response("Problem inserting data into database", {
        status: 500,
      });
    }
  }

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Typing a LiveMap with TypeScript
DESCRIPTION: Shows how to define a type for a LiveMap that stores LiveObjects with a specific structure, using string keys.

LANGUAGE: typescript
CODE:
type Shapes = LiveMap<string, LiveObject<{ name: string }>>;

----------------------------------------

TITLE: Retrieving ProseMirror document content using withProsemirrorDocument
DESCRIPTION: This code demonstrates how to get the text content of a ProseMirror document from a Liveblocks room on the server. It uses withProsemirrorDocument and api.getText() to retrieve the document's text content.

LANGUAGE: typescript
CODE:
import { Liveblocks } from "@liveblocks/node";
import { withProsemirrorDocument } from "@liveblocks/node-prosemirror";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

// +++
const textContent = await withProsemirrorDocument(
  { roomId: "your-room-id", client: liveblocks, field: "prosemirror" },
  async (api) => {
    return api.getText();
  }
);
// +++

// "My content"
console.log(textContent);

----------------------------------------

TITLE: Creating an Undo/Redo Toolbar for Yjs with React
DESCRIPTION: Implementation of a simple toolbar component with undo and redo buttons that interact with Yjs UndoManager. This provides basic version control functionality for the collaborative editor.

LANGUAGE: tsx
CODE:
import * as Y from "yjs";
import styles from "./Toolbar.module.css";

type Props = {
  yUndoManager: Y.UndoManager;
};

export function Toolbar({ yUndoManager }: Props) {
  return (
    <div className={styles.toolbar}>
      <button className={styles.button} onClick={() => yUndoManager.undo()}>
        Undo
      </button>
      <button className={styles.button} onClick={() => yUndoManager.redo()}>
        Redo
      </button>
    </div>
  );
}

----------------------------------------

TITLE: Retrieving a Comment from Liveblocks using TypeScript
DESCRIPTION: Uses the liveblocks.getComment method to fetch a specific comment by its ID. Requires roomId, threadId, and commentId parameters and returns the comment object if found.

LANGUAGE: typescript
CODE:
const comment = await liveblocks.getComment({
  roomId: "my-room-id",
  threadId: "th_d75sF3...",
  commentId: "cm_agH76a...",
});

// { type: "comment", threadId: "th_d75sF3...", ... }
console.log(comment);

----------------------------------------

TITLE: Creating a Custom Floating Toolbar in React-TipTap
DESCRIPTION: Shows how to create a fully custom floating toolbar by passing elements as children to the FloatingToolbar component. This allows for complete control over the toolbar's content.

LANGUAGE: tsx
CODE:
import { FloatingToolbar } from "@liveblocks/react-tiptap";
import { Editor } from "@tiptap/react";

function CustomToolbar({ editor }: { editor: Editor | null }) {
  return (
    <FloatingToolbar editor={editor}>
      Hello <strong>world</strong>
    </FloatingToolbar>
  );
}

----------------------------------------

TITLE: Removing Aliased Sync Event Listeners
DESCRIPTION: Demonstrates that 'sync' and 'synced' event names can be used interchangeably when removing event listeners for synchronization events.

LANGUAGE: typescript
CODE:
// "sync" and "synced" both listen to the same event
yProvider.off("sync", (sync: boolean) => /* ... */);
yProvider.off("synced", (sync: boolean) => /* ... */);

----------------------------------------

TITLE: Named Object Types in Liveblocks Schema
DESCRIPTION: Shows how to define and use named object types in a schema. Creates a Scientist type that is referenced within the Storage type.

LANGUAGE: typescript
CODE:
type Scientist {
  name: string
  age: number
}

type Storage {
  scientist: Scientist
}

----------------------------------------

TITLE: Extending FloatingToolbar with Custom Content in React-Lexical
DESCRIPTION: Demonstrates how to extend the default FloatingToolbar by adding custom content before and after the default buttons. This example shows adding text at the start and a custom help button at the end.

LANGUAGE: tsx
CODE:
import { FloatingToolbar } from "@liveblocks/react-lexical";
import { Icon } from "@liveblocks/react-ui";

<FloatingToolbar
  // +++
  before={<>I'm at the start</>}
  after={
    <Toolbar.Button
      name="Help"
      icon={<Icon.QuestionMark />}
      shortcut="CMD-H"
      onClick={() => console.log("help")}
    />
  }
  // +++
/>;

----------------------------------------

TITLE: Using FloatingThreads and AnchoredThreads with responsive design
DESCRIPTION: Implementation that combines FloatingThreads and AnchoredThreads with Tailwind classes for responsive display, filtering out resolved threads with the useThreads query option.

LANGUAGE: tsx
CODE:
import { useThreads } from "@liveblocks/react/suspense";
import { AnchoredThreads, FloatingThreads } from "@liveblocks/react-blocknote";
import { BlockNoteEditor } from "@blocknote/core";

function ThreadOverlay({ editor }: { editor: BlockNoteEditor | null }) {
  const { threads } = useThreads({ query: { resolved: false } });

  return (
    <>
      <FloatingThreads
        editor={editor}
        threads={threads}
        className="w-[350px] block md:hidden"
      />
      <AnchoredThreads
        editor={editor}
        threads={threads}
        className="w-[350px] hidden sm:block"
      />
    </>
  );
}

----------------------------------------

TITLE: Deleting Element at Specific Index from LiveList in TypeScript
DESCRIPTION: Shows how to remove a single element at a specified index from a LiveList using the delete() method. If the index doesn't exist, an Error is thrown.

LANGUAGE: typescript
CODE:
const list = new LiveList(["adrien", "jonathan"]);
list.delete(1);

// ["adrien"]
list.toImmutable();

----------------------------------------

TITLE: Creating a Basic Webhook Endpoint in TypeScript
DESCRIPTION: A basic API endpoint structure to receive webhook events from Liveblocks. This endpoint retrieves the request headers and body which is necessary for webhook processing.

LANGUAGE: typescript
CODE:
export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Handle webhooks
  // ...

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Marking a Thread as Unresolved in Liveblocks using TypeScript
DESCRIPTION: Uses the liveblocks.markThreadAsUnresolved method to mark a thread as unresolved (setting the resolved property to false). Requires roomId, threadId, and userId parameters and returns the updated thread object.

LANGUAGE: typescript
CODE:
const thread = await liveblocks.markThreadAsUnresolved({
  roomId: "my-room-id",
  threadId: "th_d75sF3...",
  data: {
    userId: "steven@example.com",
  },
});

// { type: "thread", id: "th_d75sF3...", ... }
console.log(thread);

----------------------------------------

TITLE: Listening for Sync Events with LiveblocksYjsProvider
DESCRIPTION: Shows how to add an event listener for sync events on a LiveblocksYjsProvider instance, which indicates when the Yjs document has synchronized with the server.

LANGUAGE: typescript
CODE:
// Listen for the sync event
yProvider.on("sync", (isSynced: boolean) => {
  if (isSynced === true) {
    // Yjs content is synchronized and ready
  } else {
    // Yjs content is not synchronized
  }
});

----------------------------------------

TITLE: Creating Text Format Toggle Buttons with Liveblocks Lexical
DESCRIPTION: This snippet shows how to create a toggle button for text formatting using isTextFormatActive with Toolbar.Toggle. It demonstrates integration between Lexical's formatting commands and Liveblocks UI components.

LANGUAGE: tsx
CODE:
import { FORMAT_TEXT_COMMAND } from "lexical";
import { useLexicalComposerContext } from "@lexical/react/LexicalComposerContext";
// +++
import { isTextFormatActive, Toolbar } from "@liveblocks/react-lexical";
// +++

function CustomToggleButton() {
  const [editor] = useLexicalComposerContext();

  return (
    <Toolbar.Toggle
      name="Bold"
      icon={<strong>B️</strong>}
      // +++
      active={isTextFormatActive(editor, "bold")}
      // +++
      onClick={() => editor.dispatchCommand(FORMAT_TEXT_COMMAND, "bold")}
    />
  );
}

----------------------------------------

TITLE: Implementing FloatingThreads with useThreads in React-TipTap
DESCRIPTION: Demonstrates how to implement FloatingThreads to display comment threads attached to text highlights. The example shows integration with useThreads hook to fetch thread data, and proper initialization of the component with styling.

LANGUAGE: tsx
CODE:
// +++
import { useThreads } from "@liveblocks/react/suspense";
// +++
import {
  useLiveblocksExtension,
  FloatingComposer,
  // +++
  FloatingThreads,
  // +++
} from "@liveblocks/react-tiptap";
import { useEditor, EditorContent } from "@tiptap/react";

function TextEditor() {
  const liveblocks = useLiveblocksExtension();

  const editor = useEditor({
    extensions: [
      liveblocks,
      // ...
    ],
  });

  // +++
  const { threads } = useThreads();
  // +++

  return (
    <div>
      <EditorContent editor={editor} />
      <FloatingComposer editor={editor} style={{ width: "350px" }} />
      // +++
      <FloatingThreads
        editor={editor}
        threads={threads}
        style={{ width: "350px" }}
      />
      // +++
    </div>
  );
}

----------------------------------------

TITLE: LiveList Updates with Validation
DESCRIPTION: Demonstrates valid and invalid updates to LiveList fields. Shows the requirement to use the LiveList constructor when setting values.

LANGUAGE: typescript
CODE:
// ✅
root.set("animals", new LiveList(["🦁", "🦊", "🐵"]));

// ❌ Should be a LiveList
root.set("animals", ["🦁", "🦊", "🐵"]);

----------------------------------------

TITLE: Using Aliased Sync Event Names
DESCRIPTION: Demonstrates that 'sync' and 'synced' event names are aliased and can be used interchangeably when listening for synchronization events.

LANGUAGE: typescript
CODE:
// "sync" and "synced" both listen to the same event
yProvider.on("sync", (sync: boolean) => /* ... */);
yProvider.on("synced", (sync: boolean) => /* ... */);

----------------------------------------

TITLE: Advanced Options for Retrieving Yjs Documents in Liveblocks
DESCRIPTION: Demonstrates advanced options for getYjsDocument including returning text formatting, targeting a specific key within the document, and overriding the inferred type.

LANGUAGE: typescript
CODE:
const yjsDocument = await liveblocks.getYjsDocument("my-room-id", {
  // Optional, if true, `yText` values will return formatting
  format: true,

  // Optional, return a single key's value, e.g. `yDoc.get("my-key-id").toJson()`
  key: "my-key-id",

  // Optional, override the inferred `key` type, e.g. "ymap" for `doc.get(key, Y.Map)`
  type: "ymap",
});

----------------------------------------

TITLE: Accessing Awareness from LiveblocksYjsProvider in TypeScript
DESCRIPTION: Shows how to create and access the awareness property from a LiveblocksYjsProvider instance, which is powered by Liveblocks Presence.

LANGUAGE: typescript
CODE:
const yDoc = new Y.Doc();
const yProvider = new LiveblocksYjsProvider(room, yDoc);

// Yjs awareness
const awareness = yProvider.awareness;

----------------------------------------

TITLE: Setting Up Liveblocks Client with LiveblocksProvider and RoomProvider
DESCRIPTION: Initial React component setup that configures the Liveblocks client and connects to a room for collaboration. This establishes the foundation for real-time collaboration.

LANGUAGE: tsx
CODE:
"use client";

import {
  LiveblocksProvider,
  RoomProvider,
} from "@liveblocks/react/suspense";
import { Editor } from "./Editor";

export default function App() {
  return (
    // +++
    <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>
      <RoomProvider id="my-room">
        {/* ... */}
      </RoomProvider>
    </LiveblocksProvider>
    // +++
  );
}

----------------------------------------

TITLE: Adding Custom Metadata to a New Thread with Composer
DESCRIPTION: This example shows how to attach custom metadata to a newly created thread using the metadata prop. Custom metadata can include properties like colors or coordinates.

LANGUAGE: tsx
CODE:
import { Composer } from "@liveblocks/react-ui";

// Creates a new thread with custom metadata
function Component() {
  return (
    <Composer
      metadata={{
        // Custom metadata here, e.g. colors, coordinates
        color: "purple",
        x: 80,
        y: 120,
      }}
    />
  );
}

----------------------------------------

TITLE: Using shallow comparison with useStorage selector in React
DESCRIPTION: Demonstrates how to use the shallow comparison function as the second argument to useStorage when filtering shapes by color. This loosens the equality check for the returned array.

LANGUAGE: tsx
CODE:
const redShapes = useStorage(
  (root) => root.shapes.filter((shape) => shape.color === "red"),
  shallow // 👈 here
);

----------------------------------------

TITLE: Using Toolbar.Separator for visual separation
DESCRIPTION: Shows how to add a visual separator between toolbar sections for better organization of controls.

LANGUAGE: tsx
CODE:
import { Toolbar } from "@liveblocks/react-tiptap";

<Toolbar editor={editor}>
  // +++
  <Toolbar.SectionHistory />
  // +++
</Toolbar>;

----------------------------------------

TITLE: Defining Thread Metadata Types in TypeScript
DESCRIPTION: Example of how to set metadata types in the Liveblocks configuration file to ensure proper TypeScript typing for thread metadata.

LANGUAGE: ts
CODE:
declare global {
  interface Liveblocks {
    // +++
    ThreadMetadata: {
      priority: string;
      pinned: boolean;
      timestamp: number;
    };
    // +++

    // ...
  }
}

----------------------------------------

TITLE: Configuring Suspense-Enabled Hooks in liveblocks.config.ts
DESCRIPTION: Importing Suspense-enabled versions of Liveblocks hooks from the createRoomContext function to use with React Suspense.

LANGUAGE: tsx
CODE:
export const {
  suspense: {
    RoomProvider,
    useStorage,
    /* etc. */
  },
} = createRoomContext(client);

----------------------------------------

TITLE: Customizing Toolbar.BlockSelector Item Styles with Labels
DESCRIPTION: Shows how to customize the appearance of BlockSelector dropdown items by using the label property to override default styles. The example adds a code block with custom styling.

LANGUAGE: tsx
CODE:
import { isBlockNodeActive, Toolbar } from "@liveblocks/react-lexical";
import { $setBlocksType } from "@lexical/selection";
import { $isCodeNode } from "@lexical/code";
import { $getSelection } from "lexical";

<Toolbar>
  <Toolbar.BlockSelector
    items={(defaultItems) => [
      ...defaultItems,
      {
        name: "Code block",
        // +++
        label: <div className="font-mono">Code</div>, // Optional, overwrites `icon` + `name`
        // +++
        isActive: (editor) => isBlockNodeActive(editor, $isCodeNode),
        setActive: (editor) =>
          $setBlocksType($getSelection(), () => $createCodeNode()),
      },
    ]}
  />
</Toolbar>;

----------------------------------------

TITLE: Opening FloatingComposer Programmatically in React-Lexical
DESCRIPTION: Shows how to programmatically open the FloatingComposer using Lexical commands. This example demonstrates triggering the composer from a custom button in a toolbar.

LANGUAGE: tsx
CODE:
import { useLexicalComposerContext } from "@lexical/react/LexicalComposerContext";
import { OPEN_FLOATING_COMPOSER_COMMAND } from "@liveblocks/react-lexical";

function Toolbar() {
  const [editor] = useLexicalComposerContext();

  return (
    <button
      onClick={() => {
        editor.dispatchCommand(OPEN_FLOATING_COMPOSER_COMMAND, undefined);
      }}
    >
      💬 New comment
    </button>
  );
}

----------------------------------------

TITLE: Running the Development Server
DESCRIPTION: Command to start the Next.js development server after setup, making the collaborative code editor accessible at localhost:3000.

LANGUAGE: bash
CODE:
npm run dev

----------------------------------------

TITLE: Updating User Presence in Liveblocks Room
DESCRIPTION: Updates the current user's presence by merging provided properties with existing presence data. The method supports adding presence updates to the history stack for undo/redo functionality.

LANGUAGE: typescript
CODE:
room.updatePresence({ typing: true });
room.updatePresence({ status: "Online" });

// { typing: true, status: "Online" }
const presence = room.getPresence();

----------------------------------------

TITLE: Modifying Tiptap Document State with Transactions in TypeScript
DESCRIPTION: This snippet shows how to modify a Tiptap document's state using withProsemirrorDocument and api.update. It demonstrates creating a transaction that inserts text into the document. The example uses ProseMirror's transaction system to make changes to the document.

LANGUAGE: typescript
CODE:
import { Liveblocks } from "@liveblocks/node";
import { withProsemirrorDocument } from "@liveblocks/node-prosemirror";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

await withProsemirrorDocument(
  { roomId: "your-room-id", client: liveblocks },
  // +++
  async (api) => {
    await api.update((_, tr) => {
      // Transaction example
      return tr.insertText("Hello world");
    });
  }
  // +++
);

----------------------------------------

TITLE: Opening AI Toolbar with Predefined Prompt
DESCRIPTION: Shows how to open the AiToolbar with a specific prompt already set, allowing for direct AI operations without additional user input.

LANGUAGE: tsx
CODE:
<button
  onClick={() => {
    // +++
    editor.chain().focus().askAi("Add emojis to the text").run();
    // +++
  }}
>
  😃 Emojify
</button>

----------------------------------------

TITLE: Customizing AI Response Generation in Liveblocks TipTap
DESCRIPTION: This example demonstrates how to customize AI toolbar responses by implementing the ai.resolveContextualPrompt option. This allows using custom backend endpoints to generate AI responses instead of the default Liveblocks service.

LANGUAGE: tsx
CODE:
import { useLiveblocksExtension } from "@liveblocks/react-tiptap";
import { useEditor } from "@tiptap/react";

function TextEditor() {
  const liveblocks = useLiveblocksExtension({
    ai: {
      // +++
      resolveContextualPrompt: async ({ prompt, context, signal }) => {
        const response = await fetch("/api/contextual-prompt", {
          method: "POST",
          body: JSON.stringify({ prompt, context }),
          signal,
        });

        return response.json();
      },
      // +++
    },
  });

  const editor = useEditor({
    extensions: [
      liveblocks,
      // ...
    ],
  });

  // ...
}

----------------------------------------

TITLE: Implementing Custom Inbox Notifications with Liveblocks UI
DESCRIPTION: Example of creating a custom notification kind with Liveblocks. This demonstrates how to define custom notification content and styling with the InboxNotification.Custom component.

LANGUAGE: tsx
CODE:
<InboxNotification
  inboxNotification={inboxNotification}
  kinds={{
    $myCustomNotificationKind: (props) => {
      const activityData = props.inboxNotification.activities[0].data;

      return (
        <InboxNotification.Custom
          title={
            <>
              User <strong>{activityData.file}</strong>
            </>
          }
          aside={<InboxNotification.Icon>❌</InboxNotification.Icon>}
          {...props}
        >
          {activityData.errorDescription}
        </InboxNotification.Custom>
      );
    },
  }}
/>

----------------------------------------

TITLE: Advanced Options for stringifyCommentBody
DESCRIPTION: Shows the various configuration options available for stringifyCommentBody, including format selection (plain, markdown, HTML), custom separators, element overrides, and user resolution for mentions.

LANGUAGE: typescript
CODE:
import { stringifyCommentBody } from "@liveblocks/node";

const stringComment = await stringifyCommentBody(comment.body, {
  // Optional, convert to specific format, "plain" (default) | "markdown" | "html"
  format: "markdown",

  // Optional, supply a separator to be used between paragraphs
  separator: `\n\n`,

  // Optional, override any elements in the CommentBody with a custom string
  elements: {
    // Optional, override the `paragraph` element
    paragraph: ({ element, children }) => `<p>${children}</p>`,

    // Optional, override the `text` element
    text: ({ element }) =>
      element.bold ? `<strong>${element.text}</strong>` : `${element.text}`,

    // Optional, override the `link` element
    link: ({ element, href }) =>
      `<a href="${href}" target="_blank">${element.url}</a>`,

    // Optional, override the `mention` element. `user` available if `resolveUsers` supplied
    mention: ({ element, user }) =>
      `<a href="${user.profileUrl}">${element.id}</a>`,
  },

  // Optional, get your user's names and info from their ID to be displayed in mentions
  async resolveUsers({ userIds }) {
    const usersData = await __getUsersFromDB__(userIds);

    return usersData.map((userData) => ({
      // Name is inserted into the output instead of a user's ID
      name: userData.name,

      // Custom formatting in `elements.mention` allows custom properties to be used
      profileUrl: userData.profileUrl,
    }));
  },
});

----------------------------------------

TITLE: Using set Method with LiveList in TypeScript
DESCRIPTION: Shows how to replace an element at a specified index in a LiveList using the set method.

LANGUAGE: typescript
CODE:
const list = new LiveList(["adrien", "jonathan"]);

list.set(1, "chris");

// equals ["adrien", "chris"]
list.toImmutable();

----------------------------------------

TITLE: Deploying the Collaborative Flowchart on Vercel
DESCRIPTION: Command to set up the collaborative flowchart example and deploy it on Vercel. This downloads the example code and guides you through the Vercel deployment process.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example zustand-flowchart --vercel

----------------------------------------

TITLE: Legacy TypeScript Configuration with createRoomContext
DESCRIPTION: Shows how to use createRoomContext with TypeScript to define types for Liveblocks in the pre-2.0 approach. This method is still useful when you need different room types with their own correctly typed hooks.

LANGUAGE: tsx
CODE:
import { createClient } from "@liveblocks/client";
import { createRoomContext } from "@liveblocks/react";

const client = createClient({
  // publicApiKey: "",
  // authEndpoint: "/api/liveblocks-auth",
});

// Presence represents the properties that exist on every user in the Room
// and that will automatically be kept in sync. Accessible through the
// `user.presence` property. Must be JSON-serializable.
type Presence = {
  // cursor: { x: number, y: number } | null,
  // ...
};

// Optionally, Storage represents the shared document that persists in the
// Room, even after all users leave. Fields under Storage typically are
// LiveList, LiveMap, LiveObject instances, for which updates are
// automatically persisted and synced to all connected clients.
type Storage = {
  // animals: LiveList<string>,
  // ...
};

// Optionally, UserMeta represents static/readonly metadata on each user, as
// provided by your own custom auth back end (if used). Useful for data that
// will not change during a session, like a user's name or avatar.
// type UserMeta = {
//   id?: string,  // Accessible through `user.id`
//   info?: Json,  // Accessible through `user.info`
// };

// Optionally, the type of custom events broadcast and listened to in this
// room. Use a union for multiple events. Must be JSON-serializable.
// type RoomEvent = {};

// Optionally, when using Comments, ThreadMetadata represents metadata on
// each thread. Can only contain booleans, strings, and numbers.
// export type ThreadMetadata = {
//   pinned: boolean;
//   quote: string;
//   time: number;
// };

export const {
  RoomProvider,
  useMyPresence,
  useStorage,

  // Other hooks
  // ...
} = createRoomContext<
  Presence,
  Storage
  /* UserMeta, RoomEvent, ThreadMetadata */
>(client);

----------------------------------------

TITLE: Unresolving Threads with useMarkThreadAsUnresolved in Liveblocks
DESCRIPTION: Shows how to use useMarkThreadAsUnresolved hook to mark a thread as unresolved.

LANGUAGE: tsx
CODE:
import { useMarkThreadAsUnresolved } from "@liveblocks/react/suspense";

const markThreadAsUnresolved = useMarkThreadAsUnresolved();
markThreadAsUnresolved("th_xxx");

----------------------------------------

TITLE: Implementing Responsive Thread Display with Tailwind CSS
DESCRIPTION: Shows how to use FloatingThreads and AnchoredThreads components together for optimal responsive experience. FloatingThreads is displayed on mobile screens while AnchoredThreads is shown on larger screens using Tailwind CSS classes. Threads are filtered to only show unresolved ones.

LANGUAGE: tsx
CODE:
import { useThreads } from "@liveblocks/react/suspense";
import { AnchoredThreads, FloatingThreads } from "@liveblocks/react-tiptap";
import { Editor } from "@tiptap/react";

function ThreadOverlay({ editor }: { editor: Editor | null }) {
  const { threads } = useThreads({ query: { resolved: false } });

  return (
    <>
      <FloatingThreads
        editor={editor}
        threads={threads}
        className="w-[350px] block md:hidden"
      />
      <AnchoredThreads
        editor={editor}
        threads={threads}
        className="w-[350px] hidden sm:block"
      />
    </>
  );
}

----------------------------------------

TITLE: Accessing Awareness from a Provider
DESCRIPTION: Demonstrates how to access the awareness instance from a LiveblocksYjsProvider, which is used for presence and cursor information in collaborative editing.

LANGUAGE: typescript
CODE:
// Yjs awareness
const awareness = yProvider.awareness;

----------------------------------------

TITLE: Setting up localtunnel for Webhook Testing
DESCRIPTION: Command for creating a temporary public URL using localtunnel to expose a local development server running on port 3000, allowing Liveblocks webhooks to reach your local endpoint.

LANGUAGE: bash
CODE:
npx localtunnel --port 3000

----------------------------------------

TITLE: Setting Values in LiveList Using set() Method
DESCRIPTION: Example demonstrating how to use the LiveList.set() method introduced in v0.16.0. This method allows setting a specific element at a given index in a LiveList, similar to array assignment but for collaborative data structures.

LANGUAGE: typescript
CODE:
const list = new LiveList(["🦁", "🦊", "🐵"]);
list.set(0, "🐺");
list.toArray(); // equals ["🐺", "🦊", "🐵"]

----------------------------------------

TITLE: Retrieving a Yjs Document as JSON in Liveblocks
DESCRIPTION: Gets a JSON representation of a room's Yjs document using getYjsDocument. Returns the document structure which can include text, arrays, and other Yjs data types.

LANGUAGE: typescript
CODE:
const yjsDocument = await liveblocks.getYjsDocument("my-room-id");

// { yourYText: "...", yourYArray: [...], ... }
console.log(yjsDocument);

----------------------------------------

TITLE: Creating a Slate Editor Binary Update for Yjs in Liveblocks
DESCRIPTION: Shows how to create a Yjs binary update specifically for the Slate editor, converting Slate document nodes to an insert delta and applying it to a Y.XmlText instance.

LANGUAGE: typescript
CODE:
import { Liveblocks } from "@liveblocks/node";
import * as Y from "yjs";
import { slateNodesToInsertDelta } from "@slate-yjs/core";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export async function POST() {
  // Create a Yjs document
  const yDoc = new Y.Doc();

  // Create Slate document state
  const slateDoc = {
    type: "paragraph",
    children: [{ text: "Hello world" }]
  };

  // Create your data structures and make your update
  const insertDelta = slateNodesToInsertDelta(slateDoc);
  (yDoc.get("content", Y.XmlText) as Y.XmlText).applyDelta(insertDelta);

  // Encode the document state as an update
  const update = Y.encodeStateAsUpdate(yDoc);

  // Send update to Liveblocks
  await liveblocks.sendYjsBinaryUpdate("my-room-id", update);
}

----------------------------------------

TITLE: Using LiveMap in Liveblocks Schema
DESCRIPTION: Shows how to define a LiveMap in a schema for key-value pair storage. Creates a map of shapes where each shape has position and color properties.

LANGUAGE: typescript
CODE:
type Shape {
  x: number
  y: number
  fill: "red" | "yellow" | "blue"
}

type Storage {
  shapes: LiveMap<string, Shape>
  //      ^^^^^^^
}

----------------------------------------

TITLE: Implementing Composer.SuggestionsList Component in React
DESCRIPTION: Displays a list of suggestions within Composer.Editor, mapping through user IDs to render individual suggestion items.

LANGUAGE: tsx
CODE:
<Composer.SuggestionsList>
  {userIds.map((userId) => (
    <Composer.SuggestionsListItem key={userId} value={userId}>
      @{userId}
    </Composer.SuggestionsListItem>
  ))}
</Composer.SuggestionsList>

----------------------------------------

TITLE: Using Composer.SuggestionsListItem Component in React
DESCRIPTION: Displays an individual suggestion within Composer.SuggestionsList, requiring a value prop for the suggestion's value.

LANGUAGE: tsx
CODE:
<Composer.SuggestionsListItem key={userId} value={userId}>
  @{userId}
</Composer.SuggestionsListItem>

----------------------------------------

TITLE: Retrieving Mentioned User IDs from Comment Body in TypeScript
DESCRIPTION: The getMentionedIdsFromCommentBody function extracts an array of user IDs that have been mentioned in a CommentBody object. This is commonly used in conjunction with the Comments API functions.

LANGUAGE: typescript
CODE:
import { getMentionedIdsFromCommentBody } from "@liveblocks/node";

const mentionedIds = getMentionedIdsFromCommentBody(comment.body);

----------------------------------------

TITLE: Using Toolbar.SectionInline for text formatting
DESCRIPTION: Shows how to add a section containing inline formatting buttons (bold, italic, underline) to the toolbar for text styling.

LANGUAGE: tsx
CODE:
import { Toolbar } from "@liveblocks/react-tiptap";

<Toolbar editor={editor}>
  // +++
  <Toolbar.SectionInline />
  // +++
</Toolbar>;

----------------------------------------

TITLE: Global String Overrides and Localization in Liveblocks UI
DESCRIPTION: Demonstrates how to override default strings globally using LiveblocksUIConfig. This is useful for localization or changing default text throughout the application.

LANGUAGE: tsx
CODE:
import { LiveblocksUIConfig } from "@liveblocks/react-ui";

export function App() {
  return (
    <LiveblocksUIConfig
      overrides={{ locale: "fr", USER_UNKNOWN: "Anonyme" /* ... */ }}
    >
      {/* ... */}
    </LiveblocksUIConfig>
  );
}

----------------------------------------

TITLE: Editing Thread Metadata in TypeScript
DESCRIPTION: Example of updating a thread's custom metadata. This method allows setting new values for metadata properties or removing existing properties by setting them to null.

LANGUAGE: ts
CODE:
await room.editThreadMetadata({
  threadId: "th_xxx",
  metadata: {
    color: "blue",
    page: 3,
    pinned: true,
  },
});

----------------------------------------

TITLE: Advanced stringifyCommentBody Options in TypeScript
DESCRIPTION: Example showing advanced options for stringifyCommentBody including custom formatting, separators, element overrides, and user resolution for mentions. These options provide flexibility in how comments are displayed.

LANGUAGE: typescript
CODE:
import { stringifyCommentBody } from "@liveblocks/client";

const stringComment = await stringifyCommentBody(comment.body, {
  // Optional, convert to specific format, "plain" (default) | "markdown" | "html"
  format: "markdown",

  // Optional, supply a separator to be used between paragraphs
  separator: `\n\n`,

  // Optional, override any elements in the CommentBody with a custom string
  elements: {
    // Optional, override the `paragraph` element
    paragraph: ({ element, children }) => `<p>${children}</p>`,

    // Optional, override the `text` element
    text: ({ element }) =>
      element.bold ? `<strong>${element.text}</strong>` : `${element.text}`,

    // Optional, override the `link` element
    link: ({ element, href }) =>
      `<a href="${href}" target="_blank">${element.url}</a>`,

    // Optional, override the `mention` element. `user` available if `resolveUsers` supplied
    mention: ({ element, user }) =>
      `<a href="${user.profileUrl}">${element.id}</a>`,
  },

  // Optional, get your user's names and info from their ID to be displayed in mentions
  async resolveUsers({ userIds }) {
    const usersData = await __getUsersFromDB__(userIds);

    return usersData.map((userData) => ({
      // Name is inserted into the output instead of a user's ID
      name: userData.name,

      // Custom formatting in `elements.mention` allows custom properties to be used
      profileUrl: userData.profileUrl,
    }));
  },
});

----------------------------------------

TITLE: Initializing RoomProvider with LiveObject and LiveList in React
DESCRIPTION: Example of setting up a Liveblocks RoomProvider with initial storage containing a scientist LiveObject with nested data including a LiveList for pets.

LANGUAGE: tsx
CODE:
<RoomProvider
  id="my-room"
  initialPresence={/* ... */}
  initialStorage={{
    scientist: new LiveObject({
      firstName: "Ada",
      lastName: "Lovelace",
      pets: new LiveList(["🐶", "🐈"]),
    }),
  }}
>
  <App />
</RoomProvider>

----------------------------------------

TITLE: Synchronizing Liveblocks Yjs Data with PlanetScale MySQL Database in TypeScript
DESCRIPTION: Complete implementation of a webhook handler that verifies incoming requests, fetches Yjs document data from Liveblocks, and synchronizes it with a PlanetScale MySQL database. It uses the mysql2 package to insert or update records in the database when Yjs document updates occur.

LANGUAGE: typescript
CODE:
import { WebhookHandler } from "@liveblocks/node";
import mysql from "mysql2";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";

// Your PlanetScale database URL
const DATABASE_URL = "YOUR_DATABASE_URL";

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When Yjs document data has been updated
  if (event.type === "ydocUpdated") {
    const { roomId } = event.data;

    // Get Yjs data from Liveblocks REST API
    const url = `https://api.liveblocks.io/v2/rooms/${roomId}/ydoc`;
    const response = await fetch(url, {
      headers: { Authorization: `Bearer ${API_SECRET}` },
    });

    if (!response.ok) {
      return new Response("Problem accessing Liveblocks REST APIs", {
        status: 500,
      });
    }

    // Your JSON Yjs document data as a string
    const yDocData = await response.text();

    // Update database
    const connection = await mysql.createConnection(DATABASE_URL);

    const sql = `
      INSERT INTO documents (roomId, yDocData)
      VALUES (?, ?)
      ON DUPLICATE KEY UPDATE
          yDocData = VALUES(yDocData);
    `;

    try {
      await connection.query(sql, [roomId, yDocData]);
    } catch (err) {
      return new Response("Problem inserting data into database", {
        status: 500,
      });
    }

    await connection.end();
  }

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Customizing Thread Components within FloatingThreads
DESCRIPTION: Advanced customization of the Thread component within FloatingThreads using the components prop. This approach allows modifying individual Thread components with custom styling or behaviors.

LANGUAGE: tsx
CODE:
import { Thread } from "@liveblocks/react-ui";

<FloatingThreads
  threads={threads}
  className="my-floating-thread"
  // +++
  components={{
    Thread: (props) => (
      <Thread {...props} className="border shadow" style={{ width: "300px" }} />
    ),
  }}
  // +++
/>;

----------------------------------------

TITLE: Using useStorageStatus Hook with Suspense
DESCRIPTION: Shows the Suspense version of the useStorageStatus hook, which provides a simplified set of states compared to the non-Suspense version.

LANGUAGE: ts
CODE:
import { useStorageStatus } from "@liveblocks/react/suspense";

const storageStatus = useStorageStatus();

// "synchronizing" | "synchronized"
console.log(storageStatus);

----------------------------------------

TITLE: Installing Dependencies for Manual Setup
DESCRIPTION: Command to install all required npm dependencies for the project when setting up manually without the create-liveblocks-app tool.

LANGUAGE: bash
CODE:
npm install

----------------------------------------

TITLE: Marking Threads as Read with useMarkThreadAsRead in Liveblocks
DESCRIPTION: Shows how to use useMarkThreadAsRead hook to mark a thread as read.

LANGUAGE: tsx
CODE:
import { useMarkThreadAsRead } from "@liveblocks/react/suspense";

const markThreadAsRead = useMarkThreadAsRead();
markThreadAsRead("th_xxx");

----------------------------------------

TITLE: Extending Default AI Toolbar Suggestions
DESCRIPTION: Shows how to keep the default AI suggestions while adding custom ones by using a function that receives the default children and returns the combined result.

LANGUAGE: tsx
CODE:
<AiToolbar
  editor={editor}
  // +++
  suggestions={({ children }) => (
    <>
      {children}
      // +++
      <AiToolbar.SuggestionsSeparator />
      <AiToolbar.SuggestionsLabel>Custom</AiToolbar.SuggestionsLabel>
      <AiToolbar.Suggestion>Custom suggestion</AiToolbar.Suggestion>
    </>
  )}
/>

----------------------------------------

TITLE: Editing Comments with useEditComment in Liveblocks
DESCRIPTION: Shows how to use useEditComment hook to edit a comment's body and attachments.

LANGUAGE: tsx
CODE:
import { useEditComment } from "@liveblocks/react/suspense";

const editComment = useEditComment();
editComment({
  threadId: "th_xxx",
  commentId: "cm_xxx",
  body: {},
  attachments: [],
});

----------------------------------------

TITLE: Retrieving and Creating a Y.Doc from Liveblocks Server
DESCRIPTION: This code demonstrates how to fetch Yjs document data from a Liveblocks room and create a Y.Doc instance with it. It initializes a Liveblocks instance with a secret key, retrieves binary update data, and applies it to a new Y.Doc instance.

LANGUAGE: typescript
CODE:
import * as Y from "yjs";
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export async function POST() {
  // Get your Yjs data as a binary update
  const update = await liveblocks.getYjsDocumentAsBinaryUpdate("my-room-name");

  // Create a Yjs document
  const yDoc = new Y.Doc();

  // Apply the binary update to `yDoc`
  Y.applyUpdate(yDoc, new Uint8Array(update));

  // `yDoc` can now be used as you like
  // ...
}

----------------------------------------

TITLE: Using ClientSideSuspense with Thread Components
DESCRIPTION: Example of implementing ClientSideSuspense with thread components to prevent rendering until threads have loaded. This creates a better user experience by avoiding rendering components before data is available.

LANGUAGE: tsx
CODE:
<LexicalComposer initialConfig={initialConfig}>
  <LiveblocksPlugin>
    <FloatingComposer />
    // +++
    <ClientSideSuspense fallback={null}>
      <ThreadOverlay />
    </ClientSideSuspense>
    // +++
  </LiveblocksPlugin>
</LexicalComposer>

----------------------------------------

TITLE: Mapping Through Multiple Threads with useThreads Hook
DESCRIPTION: Example showing how to retrieve and render multiple threads using the useThreads hook from @liveblocks/react/suspense. This pattern allows displaying all threads in a room.

LANGUAGE: tsx
CODE:
import { Thread } from "@liveblocks/react-ui";
import { useThreads } from "@liveblocks/react/suspense";

function Component() {
  const { threads } = useThreads();

  return (
    <>
      {threads.map((thread) => (
        <Thread key={thread.id} thread={thread} />
      ))}
    </>
  );
}

----------------------------------------

TITLE: Retrieving the Yjs Document from Awareness
DESCRIPTION: Shows how to access the Yjs document that the current awareness instance is attached to.

LANGUAGE: typescript
CODE:
// The current Yjs document
const yDoc: Y.Doc = awareness.doc;

----------------------------------------

TITLE: Subscribing to Storage Status with Room.subscribe in TypeScript
DESCRIPTION: Demonstrates how to subscribe to storage status changes in a Liveblocks room. The callback function handles different possible status values: 'not-loaded', 'loading', 'synchronizing', and 'synchronized'.

LANGUAGE: typescript
CODE:
room.subscribe("storage-status", (status) => {
  switch (status) {
    case "not-loaded":
      break;
    case "loading":
      break;
    case "synchronizing":
      break;
    case "synchronized":
      break;
    default:
      break;
  }
});

----------------------------------------

TITLE: Using Composer.Link Component in React
DESCRIPTION: Displays links within Composer.Editor, allowing for URL references and customizable content.

LANGUAGE: tsx
CODE:
<Composer.Link href={href}>{children}</Composer.Link>

----------------------------------------

TITLE: Setting Z-Index for Liveblocks Floating Elements
DESCRIPTION: Shows how to control the stacking order of portaled floating elements like tooltips and dropdowns by setting their z-index values. Both global and element-specific targeting approaches are demonstrated.

LANGUAGE: css
CODE:
/* Target all floating elements */
.lb-portal {
  z-index: 5;
}

/* Target a specific floating element */
.lb-tooltip {
  z-index: 10;
}

----------------------------------------

TITLE: Installing Required Packages for Collaborative Monaco Editor
DESCRIPTION: Command to install all necessary dependencies including Monaco editor, Yjs, and Liveblocks packages for building a collaborative code editor.

LANGUAGE: bash
CODE:
npm install @liveblocks/client @liveblocks/react @liveblocks/yjs yjs @monaco-editor/react y-monaco y-protocols

----------------------------------------

TITLE: Installing Required Packages for Collaborative Monaco Editor
DESCRIPTION: Command to install all necessary dependencies including Monaco editor, Yjs, and Liveblocks packages for building a collaborative code editor.

LANGUAGE: bash
CODE:
npm install @liveblocks/client @liveblocks/react @liveblocks/yjs yjs @monaco-editor/react y-monaco y-protocols

----------------------------------------

TITLE: Formatting Examples for stringifyCommentBody in TypeScript
DESCRIPTION: Examples showing different output formats for the same CommentBody using stringifyCommentBody. Shows plain text, custom user resolution, markdown, HTML, and custom HTML formatting options.

LANGUAGE: typescript
CODE:
// "Hello marc@example.com from https://liveblocks.io"
await stringifyCommentBody(comment.body);

// "Hello @Marc from https://liveblocks.io"
await stringifyCommentBody(comment.body, {
  resolveUsers({ userIds }) {
    return [{ name: "Marc" }];
  },
});

// "**Hello** @Marc from [https://liveblocks.io](https://liveblocks.io)"
await stringifyCommentBody(comment.body, {
  format: "markdown",

  resolveUsers() {
    return [{ name: "Marc" }];
  },
});

// "<b>Hello</b> <span data-mention>@Marc</span> from
// <a href="https://liveblocks.io">https://liveblocks.io</a>"
await stringifyCommentBody(comment.body, {
  format: "html",

  resolveUsers() {
    return [{ name: "Marc" }];
  },
});

// "<b>Hello</b> <a href="https://example.com" data-id="marc@example.com">@Marc</a> from
// <a href="https://liveblocks.io">https://liveblocks.io</a>"
await stringifyCommentBody(comment.body, {
  format: "html",

  mention: ({ element, user }) =>
    `<a href="${user.profileUrl}" data-id="${element.id}">${user.name}</a>`,

  resolveUsers() {
    return [{ name: "Marc", profileUrl: "https://example.com" }];
  },
});

----------------------------------------

TITLE: Filtering Threads by Metadata with StartsWith in Liveblocks (TypeScript)
DESCRIPTION: Shows how to filter threads using the startsWith operator on metadata fields. This example filters for threads with an 'assigned' field that starts with 'sales:'.

LANGUAGE: typescript
CODE:
// Creating a thread with `{ assigned: "sales:stacy" } metadata
await room.createThread({
  body: {
    // ...
  },
  // +++
  metadata: { assigned: "sales:stacy" },
  // +++
});

// Filtering for threads with `assigned` metadata that starts with `sales:`
const threads = await room.getThreads({
  query: {
    // +++
    metadata: {
      assigned: {
        startsWith: "sales:",
      },
    },
    // +++
  },
});

----------------------------------------

TITLE: Filtering Threads by Metadata with StartsWith in Liveblocks (TypeScript)
DESCRIPTION: Shows how to filter threads using the startsWith operator on metadata fields. This example filters for threads with an 'assigned' field that starts with 'sales:'.

LANGUAGE: typescript
CODE:
// Creating a thread with `{ assigned: "sales:stacy" } metadata
await room.createThread({
  body: {
    // ...
  },
  // +++
  metadata: { assigned: "sales:stacy" },
  // +++
});

// Filtering for threads with `assigned` metadata that starts with `sales:`
const threads = await room.getThreads({
  query: {
    // +++
    metadata: {
      assigned: {
        startsWith: "sales:",
      },
    },
    // +++
  },
});

----------------------------------------

TITLE: Customizing Thread Components within AnchoredThreads
DESCRIPTION: Advanced customization of AnchoredThreads by providing a custom Thread component through the components prop. This allows for styling individual Thread components with custom classes and styles.

LANGUAGE: tsx
CODE:
import { Thread } from "@liveblocks/react-ui";

<AnchoredThreads
  threads={threads}
  style={{ width: "350px" }}
  className="my-anchored-thread"
  // +++
  components={{
    Thread: (props) => (
      <Thread
        {...props}
        className="border shadow"
        style={{ background: "white" }}
      />
    ),
  }}
  // +++
/>;

----------------------------------------

TITLE: Using useMarkAllInboxNotificationsAsRead hook in React
DESCRIPTION: Shows how to mark all inbox notifications as read for the current user.

LANGUAGE: tsx
CODE:
import { useMarkAllInboxNotificationsAsRead } from "@liveblocks/react/suspense";

const markAllInboxNotificationsAsRead = useMarkAllInboxNotificationsAsRead();
markAllInboxNotificationsAsRead();

----------------------------------------

TITLE: Implementing AiToolbar with Suggestion Separator in React-TipTap
DESCRIPTION: This snippet demonstrates how to use the AiToolbar.SuggestionsSeparator component to visually separate groups of prompt suggestions in the AI toolbar. The separator is placed between different suggestion categories.

LANGUAGE: tsx
CODE:
import { AiToolbar } from "@liveblocks/react-tiptap";

<AiToolbar
  editor={editor}
  suggestions={
    <>
      <AiToolbar.Suggestion>Translate in French</AiToolbar.Suggestion>
      <AiToolbar.Suggestion>Translate in English</AiToolbar.Suggestion>
      // +++
      <AiToolbar.SuggestionsSeparator />
      // +++
      <AiToolbar.Suggestion>Custom suggestion</AiToolbar.Suggestion>
    </>
  }
/>;

----------------------------------------

TITLE: Using InboxNotificationList to Display Multiple Notifications
DESCRIPTION: Example of showing multiple inbox notifications in a list format. The InboxNotificationList component wraps each InboxNotification in a list item element.

LANGUAGE: tsx
CODE:
<InboxNotificationList>
  <InboxNotification />
  <InboxNotification />
  <InboxNotification />
</InboxNotificationList>

----------------------------------------

TITLE: Basic Comment Body Formatting with stringifyCommentBody in TypeScript
DESCRIPTION: Demonstrates the basic usage of stringifyCommentBody to convert a comment's body into a plain text string. This simplifies the comment content by removing formatting and converting user mentions to user IDs.

LANGUAGE: typescript
CODE:
import { stringifyCommentBody } from "@liveblocks/node";

// Format comment text into a string
const stringComment = await stringifyCommentBody(comment.body);

// "Thank you so much emil.joyce@example.com!"
console.log(stringComment);

----------------------------------------

TITLE: Using getOrCreateRoom Method in Liveblocks Node Package
DESCRIPTION: Example of the getOrCreateRoom method that optimizes room creation by making a single round-trip to the server, introduced in v2.22.2.

LANGUAGE: javascript
CODE:
.getOrCreateRoom()

----------------------------------------

TITLE: Creating Reusable Typed Notification Components
DESCRIPTION: Shows how to create reusable typed notification components using InboxNotificationCustomKindProps generic type for custom notification kinds.

LANGUAGE: tsx
CODE:
import {
  InboxNotification,
  InboxNotificationCustomKindProps,
} from "@liveblocks/react-ui";

function AlertNotification(props: InboxNotificationCustomKindProps<"$alert">) {
  // `title` and `message` are correctly typed, as defined in your config
  const { title, message } = props.inboxNotification.activities[0].data;

  return (
    <InboxNotification.Custom
      {...props}
      title={title}
      aside={<InboxNotification.Icon>❗</InboxNotification.Icon>}
    >
      {message}
    </InboxNotification.Custom>
  );
}

function Notification({ inboxNotification }) {
  return (
    <InboxNotification
      inboxNotification={inboxNotification}
      kinds={{ $alert: AlertNotification }}
    />
  );
}

----------------------------------------

TITLE: Retrieving a Yjs Subdocument as Binary Update in Liveblocks
DESCRIPTION: Shows how to retrieve a specific Yjs subdocument as a binary update by providing its GUID to the getYjsDocumentAsBinaryUpdate method.

LANGUAGE: typescript
CODE:
const binaryYjsUpdate = await liveblocks.getYjsDocumentAsBinaryUpdate(
  "my-room-id",
  {
    // Optional, return a subdocument instead. guid is its unique identifier
    guid: "c4a755...",
  }
);

----------------------------------------

TITLE: Enabling Experimental Offline Support in Tiptap
DESCRIPTION: Demonstrates how to enable experimental offline support for the Tiptap editor, which saves documents locally to provide instant loading without network connectivity.

LANGUAGE: tsx
CODE:
import { useLiveblocksExtension } from "@liveblocks/react-tiptap";

function TextEditor() {
  const liveblocks = useLiveblocksExtension({
    offlineSupport_experimental: true,
  });

  // ...
}

----------------------------------------

TITLE: Monitoring WebSocket Connection Status with Liveblocks Redux
DESCRIPTION: Retrieves the current WebSocket connection status of the Liveblocks room using useStore.

LANGUAGE: js
CODE:
const {
  liveblocks: { status },
} = useStore();

----------------------------------------

TITLE: Handling Attachments with useComposer
DESCRIPTION: Example of using useComposer to manage file attachments in a composer. This demonstrates how to access the attachments array and implement attachment removal functionality in a custom component.

LANGUAGE: tsx
CODE:
import { Composer, useComposer } from "@liveblocks/react-ui/primitives";
import { useCreateThread } from "@liveblocks/react/suspense";

function MyComposer() {
  const createThread = useCreateThread();

  return (
    <Composer.Form
      onComposerSubmit={({ body, attachments }) => {
        const thread = createThread({
          body,
          attachments,
          metadata: {},
        });
      }}
    >
      <Composer.Editor components={/* Your custom component parts */} />
      // +++
      <MyComposerAttachments />
      // +++
      <Composer.AttachFiles>Attach Files</Composer.AttachFiles>
      <Composer.Submit>Submit</Composer.Submit>
    </Composer.Form>
  );
}

function MyComposerAttachments() {
  // +++
  const { attachments, removeAttachment } = useComposer();
  // +++

  return (
    <div>
      // +++
      {attachments.map((attachment) => (
        <div key={attachment.id}>
          {attachment.name} ({attachment.status})
          <button onClick={() => removeAttachment(attachment.id)}>
            Remove
          </button>
        </div>
      ))}
      // +++
    </div>
  );
}

----------------------------------------

TITLE: Implementing Responsive Thread Display with Media Query Hook
DESCRIPTION: Alternative approach to responsive thread display using a custom media query hook. The component conditionally renders either FloatingThreads or AnchoredThreads based on screen size, with helper functions for monitoring screen width changes.

LANGUAGE: tsx
CODE:
import { useSyncExternalStore } from "react";
import { useThreads } from "@liveblocks/react/suspense";
import { AnchoredThreads, FloatingThreads } from "@liveblocks/react-tiptap";
import { Editor } from "@tiptap/react";

function ThreadOverlay({ editor }: { editor: Editor | null }) {
  const { threads } = useThreads({ query: { resolved: false } });
  // +++
  const isMobile = useIsMobile();
  // +++

  // +++
  if (isMobile) {
    return (
      <FloatingThreads
        editor={editor}
        threads={threads}
        style={{ width: "350px" }}
      />
    );
  }
  // +++

  // +++
  return (
    <AnchoredThreads
      editor={editor}
      threads={threads}
      style={{ width: "350px" }}
    />
  );
  //+++
}

export function useIsMobile() {
  return useSyncExternalStore(subscribe, getSnapshot, getSnapshot);
}

function subscribe(callback: () => void) {
  const query = window.matchMedia("(max-width: 1024px)");

  query.addEventListener("change", callback);
  return () => query.removeEventListener("change", callback);
}

function getSnapshot() {
  const query = window.matchMedia("(max-width: 1024px)");
  return query.matches;
}

----------------------------------------

TITLE: Styling Liveblocks Components with Class Names
DESCRIPTION: Uses specific class names to customize individual Liveblocks components and their states. This provides deeper customization than CSS variables when needed.

LANGUAGE: css
CODE:
.lb-thread {
  /* Customise thread */
}

.lb-avatar[data-loading] {
  /* Customise avatar loading state */
}

----------------------------------------

TITLE: Installing Liveblocks 0.18 with NPM
DESCRIPTION: Command to install the latest version (0.18) of Liveblocks client and React packages using NPM.

LANGUAGE: bash
CODE:
npm install @liveblocks/client@0.18 @liveblocks/react@0.18

----------------------------------------

TITLE: Basic FloatingComposer Implementation in React-TipTap
DESCRIPTION: Shows the basic implementation of the FloatingComposer component that allows users to create comment threads attached to the current text selection in TipTap editor.

LANGUAGE: tsx
CODE:
<FloatingComposer editor={editor} />

----------------------------------------

TITLE: Connecting to a Liveblocks Room in React Component
DESCRIPTION: Implements room connection functionality using Redux actions to enter a Liveblocks room when the component mounts and leave it when unmounting. This establishes the collaborative session.

LANGUAGE: javascript
CODE:
import { useEffect } from "react";
import "./App.css";
import { useDispatch } from "react-redux";
import { actions } from "@liveblocks/redux";

const roomId = "redux-whiteboard";

export default function App() {
  const dispatch = useDispatch();

  useEffect(() => {
    dispatch(actions.enterRoom(roomId));

    return () => {
      dispatch(actions.leaveRoom());
    };
  }, [dispatch]);

  return <div className="container">Whiteboard app</div>;
}

----------------------------------------

TITLE: Selecting Storage Items by Key and Filtering
DESCRIPTION: Examples of how to select individual items from a LiveMap and how to filter values from a LiveMap in useStorage selectors.

LANGUAGE: typescript
CODE:
const key = "errands";
const myTodos = useStorage((root) => root.todoMap.get(key));

LANGUAGE: typescript
CODE:
const myTodos = useStorage(
  root => Array.from(root.todoMap.values()).filter(...),
  shallow,
);

----------------------------------------

TITLE: Installing the Collaborative Flowchart Example using npx
DESCRIPTION: Command to set up the collaborative flowchart example locally using the create-liveblocks-app package. This automatically downloads the example and helps you set up your API key from your Liveblocks account.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example zustand-flowchart --api-key

----------------------------------------

TITLE: Using withProsemirrorDocument to modify ProseMirror documents
DESCRIPTION: Initialize a Liveblocks client and use withProsemirrorDocument to access and modify a ProseMirror document in a specific room. This is the main entry point for server-side document manipulation.

LANGUAGE: typescript
CODE:
import { Liveblocks } from "@liveblocks/node";
import { withProsemirrorDocument } from "@liveblocks/node-prosemirror";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

await withProsemirrorDocument(
  { roomId: "your-room-id", client: liveblocks },
  (api) => {
    // Modify your document with the api
    // ...
  }
);

----------------------------------------

TITLE: Rendering Comments from a Thread with Custom Components
DESCRIPTION: Demonstrates how to render a list of comments from a thread with custom Mention and Link implementations, using data from useThreads.

LANGUAGE: tsx
CODE:
import {
  Comment,
  CommentBodyLinkProps,
  CommentBodyMentionProps,
} from "@liveblocks/react-ui/primitives";
import { ThreadData } from "@liveblocks/client";

// Render custom comments in a thread. Pass a thread from `useThreads`.
function MyComments({ thread }: { thread: ThreadData }) {
  return (
    <>
      {thread.comments.map((comment) => (
        <div key={comment.id}>
          <Comment.Body
            body={comment.body}
            components={{
              Mention,
              Link,
            }}
          />
        </div>
      ))}
    </>
  );
}

// Render a mention in the comment, e.g. "@Emil Joyce"
function Mention({ userId }: CommentBodyMentionProps) {
  return <Comment.Mention>@{userId}</Comment.Mention>;
}

// Render a link in the comment, e.g. "https://liveblocks.io"
function Link({ href, children }: CommentBodyLinkProps) {
  return <Comment.Link href={href}>{children}</Comment.Link>;
}

----------------------------------------

TITLE: Customizing AnchoredThreads with Styling
DESCRIPTION: Example showing how to customize AnchoredThreads with CSS styling properties, adding width, className, and other standard HTML attributes to control the appearance of the thread container.

LANGUAGE: tsx
CODE:
<AnchoredThreads
  threads={threads}
  style={{ width: "350px" }}
  className="my-anchored-thread"
/>

----------------------------------------

TITLE: Rendering FileSize Component in React
DESCRIPTION: Basic usage of the FileSize component to display a formatted file size. The component automatically converts byte values to human-readable size formats.

LANGUAGE: tsx
CODE:
<FileSize size={100000} />

----------------------------------------

TITLE: Basic Comment.Body Implementation with Custom Components
DESCRIPTION: Configures the Comment.Body component with custom Mention and Link components for rendering comment content.

LANGUAGE: tsx
CODE:
<Comment.Body
  components={{
    Mention: <Comment.Mention />,
    Link: <Comment.Link />,
  }}
/>

----------------------------------------

TITLE: Using Toolbar.Toggle Component with Lexical Editor
DESCRIPTION: Shows how to implement a toggle button for text formatting using the Toolbar.Toggle component with Lexical editor commands. The example toggles bold formatting based on the current state.

LANGUAGE: tsx
CODE:
import { FORMAT_TEXT_COMMAND } from "lexical";
import { isTextFormatActive, Toolbar } from "@liveblocks/react-lexical";

<Toolbar>
  <Toolbar.Toggle
    name="Highlight"
    active={isTextFormatActive(editor, "bold")}
    onClick={() => editor.dispatchCommand(FORMAT_TEXT_COMMAND, "bold")}
  />
</Toolbar>;

----------------------------------------

TITLE: Initialize Storage Document using toPlainLson Helper
DESCRIPTION: Creates a room and initializes its Storage with LSON data using the toPlainLson helper from @liveblocks/client. This approach simplifies creating properly structured LSON data.

LANGUAGE: typescript
CODE:
import { toPlainLson, LiveList, LiveObject } from "@liveblocks/client";

// Create a new room
const room = await liveblocks.createRoom("my-room-id", {
  defaultAccesses: ["room:write"],
});

// If this were your Storage type...
declare global {
  interface Liveblocks {
    Storage: {
      names: LiveList<string>;
    };
  }
}

// Create the initial conflict-free data
const initialStorage: LiveObject<Liveblocks["Storage"]> = new LiveObject({
  names: new LiveList(["Olivier", "Nimesh"]),
});

// Convert to LSON and create Storage
const storage = await liveblocks.initializeStorageDocument(
  "my-room-id",
  toPlainLson(initialStorage)
);

----------------------------------------

TITLE: Checking if Redo is Available in Liveblocks History (TypeScript)
DESCRIPTION: Shows how to use the canRedo method to check if there are any operations that can be redone. This is useful for enabling or disabling redo buttons in a user interface.

LANGUAGE: typescript
CODE:
const person = new LiveObject();
person.set("name", "Pierre");

// false
room.history.canRedo();

room.history.undo();

// true
room.history.canRedo();

----------------------------------------

TITLE: Styling User Avatars for Collaborative Editor
DESCRIPTION: CSS styles for the Avatars component, defining the appearance of user avatars and tooltips. Includes hover effects to show user names and styling for avatar images.

LANGUAGE: css
CODE:
.avatars {
  display: flex;
  padding: 0 0.75rem;
}

.avatar {
  display: flex;
  place-content: center;
  position: relative;
  border: 4px solid #fff;
  border-radius: 9999px;
  width: 42px;
  height: 42px;
  background-color: #9ca3af;
  margin-left: -0.75rem;
}

.avatar:before {
  content: attr(data-tooltip);
  position: absolute;
  top: 100%;
  opacity: 0;
  transition: opacity 0.15s ease;
  padding: 5px 10px;
  color: white;
  font-size: 0.75rem;
  border-radius: 8px;
  margin-top: 10px;
  z-index: 1;
  background: black;
  white-space: nowrap;
}

.avatar:hover:before {
  opacity: 1;
}

.avatar_picture {
  width: 100%;
  height: 100%;
  border-radius: 9999px;
}

----------------------------------------

TITLE: Importing Liveblocks Hooks Directly in React (v2.0)
DESCRIPTION: Demonstrates the improved hook import pattern in v2.0. Instead of importing hooks from a local config file, developers can now import them directly from @liveblocks/react, which provides a cleaner and more intuitive API.

LANGUAGE: typescript
CODE:
// ❌ Before: get hooks exported from your Liveblocks config
import { RoomProvider, useRoom, ... } from "./liveblocks.config";

// ✅ After: import hooks directly
import { RoomProvider, useRoom, ... } from "@liveblocks/react";
import { RoomProvider, useRoom, ... } from "@liveblocks/react/suspense";

----------------------------------------

TITLE: Using Toolbar.SectionCollaboration in React-Lexical
DESCRIPTION: Demonstrates how to add a collaboration section containing an 'add comment' button to the Toolbar component. This component can be placed inside the Toolbar or FloatingToolbar.

LANGUAGE: tsx
CODE:
import { Toolbar } from "@liveblocks/react-lexical";

<Toolbar>
  // +++
  <Toolbar.SectionCollaboration />
  // +++
</Toolbar>;

----------------------------------------

TITLE: Using useUpdateMyPresence Hook for Efficient Presence Updates
DESCRIPTION: Shows how to use the useUpdateMyPresence hook to update presence without subscribing to re-renders when presence changes, which is more efficient for components that only need to update presence.

LANGUAGE: ts
CODE:
import { useUpdateMyPresence } from "@liveblocks/react/suspense";

const updateMyPresence = useUpdateMyPresence();

updateMyPresence({ y: 0 });

----------------------------------------

TITLE: Emitting Aliased Sync Events
DESCRIPTION: Demonstrates that 'sync' and 'synced' event names can be used interchangeably when emitting synchronization events.

LANGUAGE: typescript
CODE:
// "sync" and "synced" both listen to the same event
yProvider.emit("sync" /* , ... */);
yProvider.emit("synced" /* , ... */);

----------------------------------------

TITLE: Adding a Reaction to a Comment in TypeScript
DESCRIPTION: Example of adding an emoji reaction from the current user to a comment using room.addReaction. This requires specifying the thread ID, comment ID, and emoji to add.

LANGUAGE: ts
CODE:
const reaction = await room.addReaction({
  threadId: "th_xxx",
  commentId: "cm_xxx",
  emoji: "👍",
});

----------------------------------------

TITLE: Importing Dark Mode Styles with System Theme Detection
DESCRIPTION: Example of importing dark mode styles that use the system's color scheme preference. This uses the prefers-color-scheme media query to automatically switch between light and dark modes.

LANGUAGE: tsx
CODE:
// Dark mode using the system theme with `prefers-color-scheme`
import "@liveblocks/react-ui/styles/dark/media-query.css";

----------------------------------------

TITLE: Using Comment.Link Component in React
DESCRIPTION: Displays links within Comment.Body, providing proper formatting and attributes for hyperlinks in comment content.

LANGUAGE: tsx
CODE:
<Comment.Link href={href}>{children}</Comment.Link>

----------------------------------------

TITLE: Creating a Schema for Storage Validation in Liveblocks
DESCRIPTION: Uses createSchema to define a structure for validating room Storage data. The schema defines the expected data types, in this case a LiveList of strings.

LANGUAGE: typescript
CODE:
const schemaBody = `
  type Storage {
    names: LiveList<string>
  }
`;

const schema = await liveblocks.createSchema("my-schema-name", schemaBody);

// { id: "my-schema-name@1", name: "my-schema-name", version: 1, ... }
console.log(schema);

----------------------------------------

TITLE: Using Comment.Body Component in React
DESCRIPTION: Displays a comment body from a comment object, requiring the body prop which contains the structured comment content.

LANGUAGE: tsx
CODE:
<Comment.Body body={comment.body} />

----------------------------------------

TITLE: Using Toolbar.SectionHistory for undo and redo buttons
DESCRIPTION: Demonstrates how to add a section containing undo and redo buttons to the toolbar for history management.

LANGUAGE: tsx
CODE:
import { Toolbar } from "@liveblocks/react-tiptap";

<Toolbar editor={editor}>
  // +++
  <Toolbar.SectionHistory />
  // +++
</Toolbar>;

----------------------------------------

TITLE: Rendering Thread Inbox Notification in React with Liveblocks
DESCRIPTION: Example of displaying a thread inbox notification with customized properties. The component supports showing/hiding room names and other display options.

LANGUAGE: tsx
CODE:
<InboxNotification
  inboxNotification={inboxNotification}
  kinds={{
    thread: (props) => (
      <InboxNotification.Thread {...props} showRoomName={false} />
    ),
  }}
/>

----------------------------------------

TITLE: Customizing Individual Threads with components.Thread Prop
DESCRIPTION: Demonstrates how to override the Thread component to apply custom styling to each thread within FloatingThreads. This is useful for modifying thread width or applying custom border and shadow effects.

LANGUAGE: tsx
CODE:
import { Thread } from "@liveblocks/react-ui";

<FloatingThreads
  editor={editor}
  threads={threads}
  className="my-floating-thread"
  // +++
  components={{
    Thread: (props) => (
      <Thread {...props} className="border shadow" style={{ width: "300px" }} />
    ),
  }}
  // +++
/>;

----------------------------------------

TITLE: Sending a Yjs Binary Update in Liveblocks
DESCRIPTION: Uses sendYjsBinaryUpdate to update or initialize a room's Yjs document with binary updates. This is the basic form of the method call.

LANGUAGE: typescript
CODE:
await liveblocks.sendYjsBinaryUpdate("my-room-id", update);

----------------------------------------

TITLE: Multiple Loading Spinners with ClientSideSuspense in React
DESCRIPTION: Demonstrates how to use multiple ClientSideSuspense components in different parts of the application to create localized loading states rather than wrapping the entire application.

LANGUAGE: tsx
CODE:
import { ClientSideSuspense } from "@liveblocks/react/suspense";

function Page() {
  return (
    <LiveblocksProvider authEndpoint="/api/liveblocks-auth">
      <RoomProvider id="my-room-id">
        <header>My title</header>

        <main>
          <ClientSideSuspense fallback={<div>Loading…</div>}>
            <Canvas />
          </ClientSideSuspense>
        </main>

        <aside>
          <ClientSideSuspense fallback={<div>Loading…</div>}>
            <LiveAvatars />
          </ClientSideSuspense>
        </aside>
      </RoomProvider>
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Filtering Threads by Metadata in Liveblocks (TypeScript)
DESCRIPTION: Demonstrates how to filter threads by custom metadata. This example shows creating a thread with priority metadata and then filtering threads to find those with matching metadata.

LANGUAGE: typescript
CODE:
// Creating a thread with `priority` metadata
await room.createThread({
  body: {
    // ...
  },
  // +++
  metadata: { priority: "HIGH" },
  // +++
});

// Filtering for threads with the same metadata
const threads = await room.getThreads({
  query: {
    // +++
    metadata: { priority: "HIGH" },
    // +++
  },
});

----------------------------------------

TITLE: Accessing Liveblocks Data from Zustand Store
DESCRIPTION: React component showing how to access collaborative data from the Liveblocks-connected Zustand store to display the number of other users online.

LANGUAGE: tsx
CODE:
"use client";

import useStore from "./store";

export function Room() {
  const others = useStore((state) => state.liveblocks.others);
  const userCount = others.length;
  return <div>There are {userCount} other user(s) online</div>;
}

----------------------------------------

TITLE: Corrected ActivitiesData Type Definition in TypeScript
DESCRIPTION: Fixed version of the ActivitiesData type definition that addresses both issues: using a string for the date value and adding the required $ prefix to the success notification kind.

LANGUAGE: typescript
CODE:
declare global {
  interface Liveblocks {
    ActivitiesData: {
      // Your custom notification kinds go here...
      $error: {
        code: number;
        date: string;
      };
      $success: {
        message: string;
      };
    };
  }
}

----------------------------------------

TITLE: Using useSyncStatus Hook with Smooth Option
DESCRIPTION: Example of using the useSyncStatus hook with the smooth option to show a saving indicator while Liveblocks is synchronizing local changes to the server.

LANGUAGE: typescript
CODE:
useSyncStatus({ smooth: true })

----------------------------------------

TITLE: Customizing AI Toolbar Suggestions
DESCRIPTION: Demonstrates how to customize the suggestion options displayed in the AI toolbar using AiToolbar.Suggestion components and related elements.

LANGUAGE: tsx
CODE:
<AiToolbar
  editor={editor}
  // +++
  suggestions={
    <>
      <AiToolbar.SuggestionsLabel>Suggested</AiToolbar.SuggestionsLabel>
      <AiToolbar.Suggestion>Fix mistakes</AiToolbar.Suggestion>
      <AiToolbar.Suggestion prompt="Add emojis to the text">
        Emojify
      </AiToolbar.Suggestion>
      <AiToolbar.SuggestionsSeparator />
      <AiToolbar.Suggestion icon={<Icon.Sparkles />}>
        Continue writing
      </AiToolbar.Suggestion>
    </>
  }
  // +++
/>

----------------------------------------

TITLE: Setting Initial Content for Liveblocks TipTap Editor
DESCRIPTION: This snippet shows how to set initial content for the editor using the initialContent option. This content will only be used if the editor has never been edited by any users.

LANGUAGE: tsx
CODE:
import { useLiveblocksExtension } from "@liveblocks/react-tiptap";

function TextEditor() {
  const liveblocks = useLiveblocksExtension({
    // +++
    initialContent: "<p>Hello world</p>",
    // +++
  });

  // ...
}

----------------------------------------

TITLE: Updating App Component with Pointer Event Handlers
DESCRIPTION: Updates to the App component to add pointer event handlers for moving rectangles. The component is enhanced with onCanvasPointerMove and onCanvasPointerUp event handlers connected to the Liveblocks store.

LANGUAGE: tsx
CODE:
import { useEffect } from "react";
import useStore from "./store";

import "./App.css";

export default function App() {
  const shapes = useStore((state) => state.shapes);
  const insertRectangle = useStore((state) => state.insertRectangle);
  const others = useStore((state) => state.liveblocks.others);
  const selectedShape = useStore((state) => state.selectedShape);
  const deleteShape = useStore((state) => state.deleteShape);
  const onCanvasPointerMove = useStore((state) => state.onCanvasPointerMove);
  const onCanvasPointerUp = useStore((state) => state.onCanvasPointerUp);

  /* ... */

  return (
    <>
      <div
        className="canvas"
        onPointerMove={onCanvasPointerMove}
        onPointerUp={onCanvasPointerUp}
      >
        {/* ... */}
      </div>
      <div className="toolbar">{/* ... */}</div>
    </>
  );
}

/* Rectangle */

----------------------------------------

TITLE: Adding Shape Deletion to Zustand Store
DESCRIPTION: Extends the Zustand store with a deleteShape function that removes the currently selected shape from the shapes object and resets the selection state. This enables users to delete shapes they've selected.

LANGUAGE: typescript
CODE:
/* ... */

type State = {
  shapes: Record<string, Shape>;
  selectedShape: string | null;
  insertRectangle: () => void;
  onShapePointerDown: (shapeId: string | null) => void;
  deleteShape: () => void;
};

/* ... */

const useStore = create<WithLiveblocks<State>>()(
  liveblocks(
    (set, get) => ({
      shapes: {},
      selectedShape: null,
      insertRectangle: () => {
        /* ... */
      },
      onShapePointerDown: (shapeId) => {
        /* ... */
      },
      deleteShape: () => {
        const { shapes, selectedShape } = get();
        if (!selectedShape) {
          /* Nothing todo */
          return;
        }
        const { [selectedShape]: shapeToDelete, ...newShapes } = shapes;
        set({
          shapes: newShapes,
          selectedShape: null,
        });
      },
    }),
    {
      client,
      storageMapping: { shapes: true },
      presenceMapping: { selectedShape: true },
    }
  )
);

export default useStore;

----------------------------------------

TITLE: Implementing Load More Button with useThreads in Liveblocks
DESCRIPTION: Example of implementing a Load More button to fetch additional threads using the fetchMore function. Shows how to handle loading states and completion state.

LANGUAGE: tsx
CODE:
<div>
  {threads.map((thread) => (
    <Thread key={thread.id} />
  ))}

  {hasFetchedAll ? (
    <div>🎉 You're all caught up!</div>
  ) : (
    <button disabled={isFetchingMore} onClick={fetchMore}>
      Load more
    </button>
  )}
</div>

----------------------------------------

TITLE: Deploying Live Cursors Example to Vercel
DESCRIPTION: Command to set up the Live Cursors example and deploy it to Vercel. This downloads the example and guides you through the Vercel deployment process.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example vuejs-live-cursors --vercel

----------------------------------------

TITLE: Subscribing to Storage Status Changes in TypeScript
DESCRIPTION: Example of using the Room.subscribe method to monitor storage status changes. This code demonstrates how to handle different storage states: not-loaded, loading, synchronizing, and synchronized.

LANGUAGE: typescript
CODE:
room.subscribe("storage-status", (status) => {
  switch (status) {
    case "not-loaded":
      break;
    case "loading":
      break;
    case "synchronizing":
      break;
    case "synchronized":
      break;
    default:
      break;
  }
});

----------------------------------------

TITLE: Getting All Users' Awareness States
DESCRIPTION: Demonstrates how to retrieve awareness states for all users using the getStates method.

LANGUAGE: typescript
CODE:
// A Map of each user's awareness state
const states: Map<number, unknown> = awareness.getStates();

----------------------------------------

TITLE: Deleting All Notifications with Client.deleteAllInboxNotifications in TypeScript
DESCRIPTION: Demonstrates how to delete all inbox notifications for the current user. This method doesn't return any value or require any arguments.

LANGUAGE: typescript
CODE:
await client.deleteAllInboxNotifications();

----------------------------------------

TITLE: Creating Custom Block Selector Items with Liveblocks Lexical
DESCRIPTION: This snippet shows how to create custom block selector items for a Toolbar.BlockSelector component using the isBlockNodeActive helper. It demonstrates how to check for and set specific block types like code blocks.

LANGUAGE: tsx
CODE:
//+++
import { isBlockNodeActive, Toolbar } from "@liveblocks/react-lexical";
// +++
import { $setBlocksType } from "@lexical/selection";
import { $isCodeNode } from "@lexical/code";
import { $getSelection } from "lexical";

<Toolbar>
  <Toolbar.BlockSelector
    items={(defaultItems) => [
      ...defaultItems,
      {
        name: "Code block",
        icon: <div>❮ ❯</div>,
        // +++
        isActive: (editor) => isBlockNodeActive(editor, $isCodeNode),
        // +++
        setActive: (editor) =>
          $setBlocksType($getSelection(), () => $createCodeNode()),
      },
    ]}
  />
</Toolbar>;

----------------------------------------

TITLE: Rendering Timestamp Component in React
DESCRIPTION: Basic usage of the Timestamp component to display a formatted date. This component automatically re-renders to support relative formatting for recent dates and absolute formatting for older ones.

LANGUAGE: tsx
CODE:
<Timestamp date={new Date()} />

----------------------------------------

TITLE: Subscribing to Storage Status Changes in Liveblocks
DESCRIPTION: Example showing how to subscribe to storage status changes in a Liveblocks room. The code demonstrates handling different status values including not-loaded, loading, synchronizing, and synchronized states.

LANGUAGE: typescript
CODE:
room.subscribe("storage-status", (status) => {
  switch (status) {
    case "not-loaded":
      break;
    case "loading":
      break;
    case "synchronizing":
      break;
    case "synchronized":
      break;
    default:
      break;
  }
});

----------------------------------------

TITLE: Creating a Custom Toolbar for Tiptap Editor
DESCRIPTION: This example demonstrates how to create a fully custom toolbar by passing elements as children to the Toolbar component, overriding the default toolbar content with custom content.

LANGUAGE: tsx
CODE:
import { Toolbar } from "@liveblocks/react-lexical";
import { Editor } from "@tiptap/react";

function CustomToolbar({ editor }: { editor: Editor | null }) {
  return (
    <Toolbar editor={editor}>
      Hello <strong>world</strong>
    </Toolbar>
  );
}

----------------------------------------

TITLE: Typing Presence in Liveblocks with TypeScript
DESCRIPTION: Demonstrates how to type Presence values in Liveblocks by defining the Presence interface. This allows for type safety when working with presence data like status and cursor position.

LANGUAGE: typescript
CODE:
declare global {
  interface Liveblocks {
    Presence: {
      status: string;
      cursor: { x: number; y: number };
    };
  }
}

----------------------------------------

TITLE: Updating Cursor Position with Redux Actions in Liveblocks
DESCRIPTION: Demonstrates how to dispatch Redux actions to update cursor position, which will be broadcasted to all users in the room through Liveblocks presence.

LANGUAGE: jsx
CODE:
import { useDispatch } from "react-redux";
import { setCursor } from "./store.js";

function YourComponent() {
  const dispatch = useDispatch();

  return (
    <div
      style={{ width: "100vw", height: "100vh" }}
      onPointerMove={(e) => dispatch(setCursor({ x: e.clientX, y: e.clientY }))}
    />
  );
}

----------------------------------------

TITLE: Typing Others' Presence in Zustand with Liveblocks
DESCRIPTION: Example of how to type the presence of other users in a Liveblocks-enabled Zustand store using the TPresence generic argument on the middleware, allowing for type-safe access to others' presence.

LANGUAGE: typescript
CODE:
type Presence = {
  isTyping: true;
}

const useStore = create(
  middleware<State, Presence>(/* ... */, {
    client,
    presenceMapping: { isTyping: true },
    storageMapping: { todos: true }
  })
);

// In your component
useStore(state => state.liveblocks.others[0].presence?.isTyping)

----------------------------------------

TITLE: Implementing a custom toggle with React state
DESCRIPTION: Shows how to create a custom toggle component using Toolbar.Toggle with React's useState hook. This approach manages the toggle state independently of the editor.

LANGUAGE: tsx
CODE:
import { Toolbar } from "@liveblocks/react-tiptap";
import { Editor } from "@tiptap/react";
import { useState } from "react";

function CustomToggle({ editor }: { editor: Editor | null }) {
  const [active, setActive] = useState(false);

  return (
    <Toolbar.Toggle
      name="Toggle options"
      active={active}
      onClick={() => setActive(!active)}
    />
  );
}

----------------------------------------

TITLE: Implementing History Pause and Resume for Drag Operations
DESCRIPTION: Enhancement to the store to pause and resume history during rectangle drag operations. This improves the undo/redo experience by preventing intermediary positions from being added to history.

LANGUAGE: typescript
CODE:
/* ... */

const useStore = create<WithLiveblocks<State>>()(
  liveblocks(
    (set, get) => ({
      isDragging: false,
      shapes: {},
      selectedShape: null,

      insertRectangle: () => {
        /* ... */
      },
      onShapePointerDown: (shapeId) => {
        get().liveblocks.room?.history.pause();
        set({ selectedShape: shapeId, isDragging: true });
      },
      deleteShape: () => {
        /* ... */
      },
      onCanvasPointerUp: () => {
        set({ isDragging: false });
        get().liveblocks.room?.history.resume();
      },
      onCanvasPointerMove: (e) => {
        /* ... */
      },
    }),
    {
      client,
      storageMapping: { shapes: true },
      presenceMapping: { selectedShape: true },
    }
  )
);

export default useStore;

----------------------------------------

TITLE: Importing Dark Mode Styles with Class and Data Attributes
DESCRIPTION: Example of importing dark mode styles that use class names and data attributes for theme detection. This approach works with the 'dark' class or specific data attributes for theme control.

LANGUAGE: tsx
CODE:
// Dark mode using `className="dark"`, `data-theme="dark"`, or `data-dark="true"`
import "@liveblocks/react-ui/styles/dark/attributes.css";

----------------------------------------

TITLE: Advanced Thread Metadata Editing with Liveblocks API
DESCRIPTION: Updates thread metadata with various data types and removal options. Shows how to set string, number, and boolean values, and how to remove metadata with null.

LANGUAGE: typescript
CODE:
const editedMetadata = await liveblocks.editThreadMetadata({
  roomId: "my-room-id",
  threadId: "th_d75sF3...",

  data: {
    // Custom metadata
    metadata: {
      // Metadata can be a string, number, or boolean
      title: "My thread title",
      page: 3,
      pinned: true,

      // Remove metadata with null
      color: null,
    },

    // The ID of the user that updated the metadata
    userId: "marc@example.com",

    // Optional, the time the user updated the metadata
    updatedAt: new Date(),
  },
});

// { title: "My thread title", page: 3, pinned: true }
console.log(editedMetadata);

----------------------------------------

TITLE: Using useUpdateNotificationSettings Hook with @liveblocks/react
DESCRIPTION: Example showing the useUpdateNotificationSettings hook which provides a dedicated function to update user notification settings, useful for simpler cases like unsubscribe buttons.

LANGUAGE: tsx
CODE:
// A suspense version of this hook is available
import { useUpdateNotificationSettings } from "@liveblocks/react";

const updateSettings = useUpdateNotificationSettings();

const onUnsubscribe = () => {
  updateSettings({
    slack: {
      thread: false,
    },
  });
};

----------------------------------------

TITLE: Migrating from createClient to LiveblocksProvider in Liveblocks 2.0
DESCRIPTION: Shows how to migrate from the older createClient pattern to the new LiveblocksProvider component introduced in Liveblocks 2.0, which provides a more React-native approach to configuration.

LANGUAGE: typescript
CODE:
// ❌ Before
const client = createClient(/* options */);

// ✅ After
<LiveblocksProvider /* options */>
  <App />
</LiveblocksProvider>;

----------------------------------------

TITLE: Styling Liveblocks Components with CSS Variables
DESCRIPTION: Demonstrates how to globally style all default Comments components by setting custom CSS variables within the .lb-root class, including changing the accent color, spacing, and border radius.

LANGUAGE: css
CODE:
/* Styles all default Comments components */
.lb-root {
  --lb-accent: purple;
  --lb-spacing: 1em;
  --lb-radius: 0;
}

----------------------------------------

TITLE: Using Composer.Submit Component in React
DESCRIPTION: Provides a button to submit the composer content, supporting the asChild property for customization.

LANGUAGE: tsx
CODE:
<Composer.Submit>Send</Composer.Submit>

----------------------------------------

TITLE: Comparing arrays and objects with shallow function
DESCRIPTION: Shows how the shallow function performs equality checks on arrays and objects by comparing their members one level deep.

LANGUAGE: tsx
CODE:
// Comparing arrays
shallow([1, 2, 3], [1, 2, 3]); // true

// Comparison objects
shallow({ a: 1 }, { a: 1 }); // true

----------------------------------------

TITLE: Setting Up Liveblocks Client
DESCRIPTION: Code snippet that creates a Liveblocks client by initializing it with a public API key. This client handles communication with the Liveblocks backend service.

LANGUAGE: ts
CODE:
const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

----------------------------------------

TITLE: Basic Composer Component Implementation
DESCRIPTION: Simple usage of the Composer component which creates a new thread when submitted. The Composer allows users to create new threads or comments in a collaborative environment.

LANGUAGE: tsx
CODE:
<Composer />

----------------------------------------

TITLE: Configuring Liveblocks Client for React Native
DESCRIPTION: Shows how to configure the Liveblocks client for React Native by providing the atob polyfill from the base-64 package. This is necessary since React Native doesn't natively include atob.

LANGUAGE: ts
CODE:
import { createClient } from "@liveblocks/client";
import { decode } from "base-64";

const client = createClient({
  polyfills: {
    atob: decode,
  },

  // Other options
  // ...
});

----------------------------------------

TITLE: Retrieving Room Notification Settings with Room.getNotificationSettings in TypeScript
DESCRIPTION: Demonstrates how to get the current user's notification settings for the current room. Returns settings object with thread notification preferences.

LANGUAGE: typescript
CODE:
const settings = await room.getNotificationSettings();

----------------------------------------

TITLE: Deleting Threads with useDeleteThread in Liveblocks
DESCRIPTION: Shows how to use useDeleteThread hook to delete a thread and all its associated comments by ID. Only the thread creator can delete the thread.

LANGUAGE: tsx
CODE:
import { useDeleteThread } from "@liveblocks/react/suspense";

const deleteThread = useDeleteThread();
deleteThread("th_xxx");

----------------------------------------

TITLE: Installing Live Avatar Stack Example with create-liveblocks-app
DESCRIPTION: Command to set up the Live Avatar Stack example using the create-liveblocks-app CLI tool, which downloads the example and helps configure the API key from a Liveblocks account.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example vuejs-live-avatars --api-key

----------------------------------------

TITLE: Using Typed Presence with Liveblocks Zustand Middleware
DESCRIPTION: Example showing how to use the TPresence generic argument to type the 'others' presence in a Liveblocks-enhanced Zustand store.

LANGUAGE: typescript
CODE:
type Presence = {
  isTyping: true;
}

const useStore = create(
  middleware<State, Presence>(/* ... */, {
    client,
    presenceMapping: { isTyping: true },
    storageMapping: { todos: true }
  })
);

// In your component
useStore(state => state.liveblocks.others[0].presence?.isTyping)

----------------------------------------

TITLE: Using Toolbar.SectionHistory Component
DESCRIPTION: Shows how to add a section containing undo and redo buttons to a Toolbar using the Toolbar.SectionHistory component. This section can also be placed inside a FloatingToolbar.

LANGUAGE: tsx
CODE:
import { Toolbar } from "@liveblocks/react-lexical";

<Toolbar>
  // +++
  <Toolbar.SectionHistory />
  // +++
</Toolbar>;

----------------------------------------

TITLE: Using Timestamp Component with Thread Comments
DESCRIPTION: Example showing how to use the Timestamp component with comment creation timestamps in a thread. The component is used to display human-readable times for when comments were created.

LANGUAGE: tsx
CODE:
import { ThreadData, Timestamp } from "@liveblocks/react-ui";

function MyComments({ thread }: { thread: ThreadData }) {
  return (
    <>
      {thread.comments.map((comment) => (
        <div key={comment.id}>
          <Timestamp date={comment.createdAt} />
          <Comment.Body body={comment.body} components={/* ... */} />
        </div>
      ))}
    </>
  );
}

----------------------------------------

TITLE: Using WebhookHandler to Verify Requests in @liveblocks/node
DESCRIPTION: Method that allows passing a Header object to the headers parameter in WebhookHandler.verifyRequest() for webhook verification.

LANGUAGE: typescript
CODE:
WebhookHandler.verifyRequest({ headers: Header })

----------------------------------------

TITLE: Adding Comments to Existing Thread in Liveblocks
DESCRIPTION: This snippet demonstrates how to add additional comments to an existing thread in Liveblocks. It specifies the room ID, thread ID, user ID, creation timestamp, and structured comment body content.

LANGUAGE: typescript
CODE:
// The unique ID for the room
const roomId = "my-room-id";

// Create a room
const room = await liveblocks.createRoom(roomId, {
  defaultAccesses: [],
});

// Create a thread
const thread = await liveblocks.createThread({
  /* ... */
});

// +++
// Adding a comment to the existing thread
const comment = await liveblocks.createComment({
  roomId,
  threadId: thread.id,

  data: {
    // ID of the user that created the comment
    userId: "pierre@example.com",

    // Optional, when the comment was created
    createdAt: new Date(),

    body: {
      version: 1,
      content: [
        // The comment's body text goes here
        // {
        //   type: "paragraph",
        //   children: [{ text: "Hello " }, { text: "world", bold: true }],
        // },
      ],
    },
  },
});
// +++

----------------------------------------

TITLE: Installing Liveblocks Node Package
DESCRIPTION: Command to install the @liveblocks/node package as a dependency for the project.

LANGUAGE: bash
CODE:
npm install @liveblocks/node

----------------------------------------

TITLE: Receiving Server-Sent Events in Liveblocks
DESCRIPTION: Shows how server-sent events are received in the client, with null user and -1 connectionId values to indicate the event came from the server.

LANGUAGE: typescript
CODE:
const unsubscribe = room.subscribe("event", ({ event, user, connectionId }) => {
  // `null`, `-1`
  console.log(user, connectionId);
});

----------------------------------------

TITLE: Deploying Collaborative Code Editor to Vercel
DESCRIPTION: Command to set up and deploy the collaborative code editor to Vercel. This downloads the example and opens a browser to complete the Vercel deployment process.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-yjs-codemirror --vercel

----------------------------------------

TITLE: Using Toolbar.Toggle with Tiptap highlight extension
DESCRIPTION: Demonstrates how to implement a basic toggle button using Toolbar.Toggle with the Tiptap highlight extension. The toggle's active state is determined by the editor's current state.

LANGUAGE: tsx
CODE:
import { Toolbar } from "@liveblocks/react-tiptap";

<Toolbar editor={editor}>
  <Toolbar.Toggle
    name="Highlight"
    active={editor?.isActive("highlight") ?? false}
    onClick={() => editor?.chain().focus().toggleHighlight().run()}
  />
</Toolbar>;

----------------------------------------

TITLE: Adding Delete Button to Whiteboard UI
DESCRIPTION: Updates the React component to include a delete button that removes the currently selected rectangle. The button is disabled when no shape is selected, providing a better user experience by preventing actions that would have no effect.

LANGUAGE: jsx
CODE:
import { useEffect } from "react";
import "./App.css";
import { useDispatch, useSelector } from "react-redux";
import { actions } from "@liveblocks/redux";

import { insertRectangle, onShapePointerDown, deleteShape } from "./store";

const roomId = "redux-whiteboard";

export default function App() {
  const shapes = useSelector((state) => state.shapes);
  const isLoading = useSelector((state) => state.liveblocks.isStorageLoading);
  const selectedShape = useSelector((state) => state.selectedShape);
  const others = useSelector((state) => state.liveblocks.others);

  const dispatch = useDispatch();

  /* ... */

  return (
    <>
      <div className="canvas">{/* ... */}</div>
      <div className="toolbar">
        <button onClick={() => dispatch(insertRectangle())}>Rectangle</button>
        <button
          onClick={() => dispatch(deleteShape())}
          disabled={selectedShape == null}
        >
          Delete
        </button>
      </div>
    </>
  );
}

/* Rectangle */

----------------------------------------

TITLE: Comparison of Old Room API in Liveblocks Client
DESCRIPTION: Shows the old, deprecated API for entering and leaving rooms in Liveblocks client that will remain functional but is no longer recommended.

LANGUAGE: typescript
CODE:
// Old APIs we'll no longer be recommending (but that will remain working)
const room = client.enter("my-room", options);
client.getRoom("my-room");
client.leave("my-room");

----------------------------------------

TITLE: Retrieving a Yjs Document as Binary Update in Liveblocks
DESCRIPTION: Uses getYjsDocumentAsBinaryUpdate to retrieve a room's Yjs document as a single binary update, useful for accessing document data on the backend.

LANGUAGE: typescript
CODE:
const binaryYjsUpdate =
  await liveblocks.getYjsDocumentAsBinaryUpdate("my-room-id");

----------------------------------------

TITLE: Customizing Toolbar.BlockSelector with Custom Items
DESCRIPTION: Demonstrates how to customize the items shown in the BlockSelector dropdown by adding a code block option to the default items. The example shows how to check if a block is active and how to apply a block type.

LANGUAGE: tsx
CODE:
import { isBlockNodeActive, Toolbar } from "@liveblocks/react-lexical";
import { $setBlocksType } from "@lexical/selection";
import { $isCodeNode } from "@lexical/code";
import { $getSelection } from "lexical";

<Toolbar>
  <Toolbar.BlockSelector
    items={(defaultItems) => [
      ...defaultItems,
      {
        name: "Code block",
        icon: <div>❮ ❯</div>, // Optional
        isActive: (editor) => isBlockNodeActive(editor, $isCodeNode),
        setActive: (editor) =>
          $setBlocksType($getSelection(), () => $createCodeNode()),
      },
    ]}
  />
</Toolbar>;

----------------------------------------

TITLE: Customizing InboxNotification for Different Notification Kinds
DESCRIPTION: Shows how to customize the rendering of different notification kinds by providing custom components through the kinds prop of InboxNotification.

LANGUAGE: tsx
CODE:
<InboxNotification
  inboxNotification={inboxNotification}
  kinds={{
    thread: (props) => (
      <InboxNotification.Thread {...props} showRoomName={false} />
    ),
    $myCustomNotification: (props) => (
      <InboxNotification.Custom
        {...props}
        title="New notification"
        aside={<InboxNotification.Icon>❕</InboxNotification.Icon>}
      >
        My custom notification
      </InboxNotification.Custom>
    ),
  }}
/>

----------------------------------------

TITLE: Comparing Old and New Client Room API in TypeScript
DESCRIPTION: Demonstrates the transition from the older room entry/exit API to the new recommended approach in Liveblocks client. The new API returns both the room and a leave function, allowing for entering/leaving the same room multiple times from different parts of an application.

LANGUAGE: typescript
CODE:
// Old APIs we'll no longer be recommending (but that will remain working)
const room = client.enter("my-room", options);
client.getRoom("my-room");
client.leave("my-room");

LANGUAGE: typescript
CODE:
// New API we'll be recommending instead
const { room, leave } = client.enterRoom("my-room", options);
leave();

----------------------------------------

TITLE: Customizing Thread Components within AnchoredThreads
DESCRIPTION: Shows how to customize the Thread component appearance by providing a custom Thread implementation to the components property.

LANGUAGE: tsx
CODE:
import { Thread } from "@liveblocks/react-ui";

<AnchoredThreads
  editor={editor}
  threads={threads}
  style={{ width: "350px" }}
  className="my-anchored-thread"
  // +++
  components={{
    Thread: (props) => (
      <Thread
        {...props}
        className="border shadow"
        style={{ background: "white" }}
      />
    ),
  }}
  // +++
/>;

----------------------------------------

TITLE: Creating a Comment in a Thread using Liveblocks TypeScript SDK
DESCRIPTION: Uses the liveblocks.createComment method to add a new comment to a specific thread. Requires roomId, threadId, and data containing body, userId and optional createdAt parameters.

LANGUAGE: typescript
CODE:
const comment = await liveblocks.createComment({
  roomId: "my-room-id",
  threadId: "th_d75sF3...",

  data: {
    body: {
      version: 1,
      content: [
        /* The comment's body text goes here, see below */
      ],
    },
    userId: "pierre@example.com",
    createdAt: new Date(), // Optional
  },
});

----------------------------------------

TITLE: Implementing Loading State with useIsEditorReady in TipTap
DESCRIPTION: This example shows how to integrate the useIsEditorReady hook into a complete editor component to display a loading indicator while the editor content is being loaded from Liveblocks.

LANGUAGE: tsx
CODE:
import { useLiveblocksExtension } from "@liveblocks/react-tiptap";
// +++
import { useIsEditorReady, useEditor, EditorContent } from "@tiptap/react";
// +++

function TextEditor() {
  const liveblocks = useLiveblocksExtension();
  // +++
  const ready = useIsEditorReady();
  // +++

  const editor = useEditor({
    extensions: [
      liveblocks,
      // ...
    ],
  });

  return (
    <div>
      // +++
      {!ready ? <div>Loading...</div> : <EditorContent editor={editor} />}
      // +++
    </div>
  );
}

----------------------------------------

TITLE: Deprecated Client Room API in Liveblocks
DESCRIPTION: Shows the old APIs for entering, getting, and leaving rooms in Liveblocks client that are still supported but no longer recommended.

LANGUAGE: typescript
CODE:
// Old APIs we'll no longer be recommending (but that will remain working)
const room = client.enter("my-room", options);
client.getRoom("my-room");
client.leave("my-room");

----------------------------------------

TITLE: Checking Synchronization Status
DESCRIPTION: Shows how to check if the Yjs document is currently synchronized with the server using the synced property of a LiveblocksYjsProvider instance.

LANGUAGE: typescript
CODE:
// Check if Yjs content is synchronized with the server
const isSynced: boolean = yProvider.synced;

----------------------------------------

TITLE: Using Comment.Mention Component in React
DESCRIPTION: Displays mentions within Comment.Body, typically used to highlight user references in comments.

LANGUAGE: tsx
CODE:
<Comment.Mention>@{userId}</Comment.Mention>

----------------------------------------

TITLE: Installing Node.js polyfills for LiveblocksProvider
DESCRIPTION: Command to install the WebSocket and fetch polyfills required for using Liveblocks in a Node.js environment.

LANGUAGE: bash
CODE:
npm install ws node-fetch

----------------------------------------

TITLE: Installing Latest Liveblocks Packages for React Applications
DESCRIPTION: Command to upgrade to Liveblocks 1.2 by installing the latest versions of Liveblocks packages for a React application. All Liveblocks packages need to be updated together.

LANGUAGE: bash
CODE:
npm install @liveblocks/client@latest @liveblocks/node@latest @liveblocks/react@latest

----------------------------------------

TITLE: Logging Out from Liveblocks Client
DESCRIPTION: Shows how to log out a user by purging authentication tokens from the client's memory using client.logout(). Forces any connected rooms to reauthorize.

LANGUAGE: ts
CODE:
client.logout();

----------------------------------------

TITLE: Installing Liveblocks Packages with npm
DESCRIPTION: Command to install the required Liveblocks packages for notifications functionality. All packages should use the same version.

LANGUAGE: bash
CODE:
npm install @liveblocks/client @liveblocks/react @liveblocks/react-ui

----------------------------------------

TITLE: Creating Liveblocks Client with preventUnsavedChanges Option
DESCRIPTION: Example demonstrating how to create a Liveblocks client with the preventUnsavedChanges option enabled to prevent browser tabs from closing with unsaved changes.

LANGUAGE: typescript
CODE:
createClient({ preventUnsavedChanges: true })

----------------------------------------

TITLE: Configuring presenceMapping in liveblocks middleware
DESCRIPTION: Example of how to use presenceMapping to synchronize part of the Zustand state with Liveblocks Room presence. The cursor position is mapped to be synchronized with other users in real-time.

LANGUAGE: javascript
CODE:
const useStore = create(
  liveblocks(
    (set) => ({
      cursor: { x: 0, y: 0 },
    }),
    {
      client,
      presenceMapping: { cursor: true },
    }
  )
);

----------------------------------------

TITLE: Typing Custom Thread Metadata with TypeScript in Liveblocks
DESCRIPTION: Configuration for typing custom thread metadata in TypeScript. This allows for type-safe custom metadata properties for threads, which can be string, number, or boolean types.

LANGUAGE: ts
CODE:
declare global {
  interface Liveblocks {
    // Set your custom metadata types
    // +++
    ThreadMetadata: {
      // Example types, e.g. colors, coordinates
      color: string;
      x: number;
      y: number;
    };
    // +++

    // Other types
    // ...
  }
}

----------------------------------------

TITLE: Deploying Liveblocks Live Cursors Example to Vercel
DESCRIPTION: Command to download the SvelteKit live cursors example and deploy it to Vercel. This creates the project and initiates the Vercel deployment process with appropriate configurations.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example sveltekit-live-cursors --vercel

----------------------------------------

TITLE: Styling the Whiteboard Canvas and Shapes with CSS
DESCRIPTION: CSS styles for the whiteboard application, including canvas layout, rectangle shapes, loading state, and toolbar components with hover and active states.

LANGUAGE: css
CODE:
body {
  background-color: #eeeeee;
}

.loading {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100vh;
  width: 100vw;
}

.canvas {
  background-color: #eeeeee;
  touch-action: none;
  width: 100vw;
  height: 100vh;
}

.rectangle {
  position: absolute;
  /* transition: all 0.1s ease; */
  stroke-width: 1;
  border-style: solid;
  border-width: 2px;
  height: 100px;
  width: 100px;
}

.toolbar {
  position: fixed;
  top: 12px;
  left: 50%;
  transform: translateX(-50%);
  padding: 4px;
  border-radius: 8px;
  box-shadow:
    0px 2px 4px rgba(0, 0, 0, 0.1),
    0px 0px 0px 1px rgba(0, 0, 0, 0.05);
  display: flex;
  background-color: #ffffff;
  user-select: none;
}

.toolbar button {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 4px 8px;
  border-radius: 4px;
  background-color: #f8f8f8;
  color: #181818;
  border: none;
  box-shadow:
    0px 2px 4px rgba(0, 0, 0, 0.1),
    0px 0px 0px 1px rgba(0, 0, 0, 0.05);
  margin: 4px;
  font-weight: 500;
  font-size: 12px;
}

.toolbar button:hover,
.toolbar button:focus {
  background-color: #ffffff;
}

.toolbar button:active {
  background-color: #eeeeee;
}

----------------------------------------

TITLE: Initializing Liveblocks Configuration File
DESCRIPTION: Command to create the liveblocks.config.ts file which will be used to define types for the Liveblocks application.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --init --framework react

----------------------------------------

TITLE: Resolving Threads with useMarkThreadAsResolved in Liveblocks
DESCRIPTION: Shows how to use useMarkThreadAsResolved hook to mark a thread as resolved.

LANGUAGE: tsx
CODE:
import { useMarkThreadAsResolved } from "@liveblocks/react/suspense";

const markThreadAsResolved = useMarkThreadAsResolved();
markThreadAsResolved("th_xxx");

----------------------------------------

TITLE: Initializing Liveblocks Configuration File
DESCRIPTION: Command to create the liveblocks.config.ts file which will be used to define types for the Liveblocks application.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --init --framework react

----------------------------------------

TITLE: Using useNotificationSettings Hook with React
DESCRIPTION: Demonstrates how to use the useNotificationSettings hook to retrieve and update user notification settings in a React component.

LANGUAGE: tsx
CODE:
// A suspense version of this hook is available
import { useNotificationSettings } from "@liveblocks/react";

const [{ isLoading, error, settings }, updateSettings] =
  useNotificationSettings();
// { email: { thread: true, ... }, slack: { thread: false, ... }, ... }
console.log(settings);

const onSave = () => {
  updateSettings({
    slack: {
      textMention: true,
    },
  });
};

----------------------------------------

TITLE: Using mutateStorage Method for Backend Storage Modification
DESCRIPTION: Shows how to use the new mutateStorage method which allows making changes to Storage from the backend.

LANGUAGE: javascript
CODE:
.mutateStorage()

----------------------------------------

TITLE: Retrieving and Updating a Schema in Liveblocks
DESCRIPTION: Demonstrates retrieving a schema by its ID using getSchema. The schema ID combines its name and version number, and the method returns schema details.

LANGUAGE: typescript
CODE:
const updatedBody = `
  type Storage {
    names: LiveMap<string, string>
  }
`;

const schema = await liveblocks.getSchema("my-schema-name@1", updatedBody);

// { id: "my-schema-name@1", name: "my-schema-name", version: 1, ... }
console.log(schema);

----------------------------------------

TITLE: Custom Thread Component in AnchoredThreads
DESCRIPTION: Shows how to customize the Thread component within AnchoredThreads by passing a custom component to apply styling.

LANGUAGE: tsx
CODE:
import { Thread } from "@liveblocks/react-ui";

<AnchoredThreads
  editor={editor}
  threads={threads}
  style={{ width: "350px" }}
  className="my-anchored-thread"
  // +++
  components={{
    Thread: (props) => (
      <Thread
        {...props}
        className="border shadow"
        style={{ background: "white" }}
      />
    ),
  }}
  // +++
/>;

----------------------------------------

TITLE: Displaying Version History Summary with Interactive Selection
DESCRIPTION: Example of rendering a selectable version history summary component. The component displays version information and handles selection state to show which version is currently selected.

LANGUAGE: tsx
CODE:
<HistoryVersionSummary
  onClick={() => {
    setSelectedVersionId(version.id);
  }}
  version={version}
  selected={version.id === selectedVersionId}
/>

----------------------------------------

TITLE: Using Pagination with useThreads Hook
DESCRIPTION: Example of using the useThreads hook with pagination support to fetch threads incrementally with a query parameter. This improves initial load time and allows loading more data as users interact with the application.

LANGUAGE: TSX
CODE:
const {
  threads,
  isLoading,
  error,

  // ✨ New in Liveblocks 2.9
  fetchMore,
  isFetchingMore,
  hasFetchedAll,
  fetchMoreError,
} = useThreads({ query });

----------------------------------------

TITLE: Creating a Liveblocks authentication endpoint in Next.js
DESCRIPTION: This code implements an API route handler for Liveblocks authentication in Next.js. It verifies user identity and assigns permissions for specific rooms.

LANGUAGE: typescript
CODE:
import { Liveblocks } from "@liveblocks/node";
import { NextRequest } from "next/server";

const liveblocks = new Liveblocks({
  secret: "sk_prod_xxxxxxxx",
});

export async function POST(request: NextRequest) {
  // Get the current user from your database
  const user = {
    id: "charlie.layne@example.com",
    info: {
      name: "Charlie Layne",
    },
  };

  // Start an authorized session
  const session = liveblocks.prepareSession(
    user.id,
    { userInfo: user.info }
  );

  // Give the user access to the room
  const { room } = await request.json();
  session.allow(room, session.FULL_ACCESS);

  // Authorize the user and return the result
  const { body, status } = await session.authorize();
  return new Response(body, { status });
}

----------------------------------------

TITLE: Installing Liveblocks, Yjs, and Monaco Packages
DESCRIPTION: Installs the necessary npm packages for implementing a collaborative Monaco code editor with Liveblocks and Yjs. All Liveblocks packages should use the same version for compatibility.

LANGUAGE: bash
CODE:
npm install @liveblocks/client @liveblocks/yjs yjs monaco-editor y-monaco

----------------------------------------

TITLE: Configuring Liveblocks Client for Node.js
DESCRIPTION: Shows how to configure the Liveblocks client for Node.js by providing WebSocket and fetch polyfills. This setup is necessary since Node.js doesn't natively support these browser APIs.

LANGUAGE: ts
CODE:
import { createClient } from "@liveblocks/client";
import fetch from "node-fetch";
import WebSocket from "ws";

const client = createClient({
  polyfills: {
    fetch,
    WebSocket,
  },

  // Other options
  // ...
});

----------------------------------------

TITLE: Using useBroadcastEvent Hook in Liveblocks React
DESCRIPTION: The useBroadcastEvent hook returns a callback that allows broadcasting custom events to other users in the room. This example shows how a client can broadcast an emoji event to others.

LANGUAGE: typescript
CODE:
import { useBroadcastEvent } from "@liveblocks/react/suspense";

// +++
// On client A
const broadcast = useBroadcastEvent();
broadcast({ type: "EMOJI", emoji: "🔥" });
// +++

----------------------------------------

TITLE: Using Composer.Mention Component in React
DESCRIPTION: Displays mentions within the Composer.Editor component, supporting the asChild property for replacing the rendered element.

LANGUAGE: tsx
CODE:
<Composer.Mention>@{userId}</Composer.Mention>

----------------------------------------

TITLE: Styling the Tiptap Toolbar
DESCRIPTION: CSS module for styling the text formatting toolbar. Defines styles for the toolbar container and buttons, including hover, focus, active, and selected states.

LANGUAGE: css
CODE:
.toolbar {
  display: flex;
  padding: 1em;
  gap: 6px;
}

.button {
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  border-radius: 6px;
  height: 32px;
  width: 32px;
  background: #fff;
  color: #1f2937;
  border: none;
  box-shadow:
    rgba(0, 0, 0, 0.12) 0 4px 8px 0,
    rgba(0, 0, 0, 0.02) 0 0 0 1px;
}

.button:hover {
  color: #111827;
  box-shadow:
    rgba(0, 0, 0, 0.16) 0 5px 8px 0,
    rgba(0, 0, 0, 0.04) 0 0 0 1px;
}

.button:focus-visible {
  outline-offset: 2px;
}

.button:active {
  box-shadow:
    rgba(0, 0, 0, 0.16) 0 2px 3px 0,
    rgba(0, 0, 0, 0.04) 0 0 0 1px;
}

.button[data-active] {
  background: #fafafa;
}

----------------------------------------

TITLE: Managing User Notification Settings with @liveblocks/client
DESCRIPTION: Demonstrates how to use the client methods to retrieve and update user notification settings using the @liveblocks/client package. The example shows getting current settings and updating email thread notifications.

LANGUAGE: tsx
CODE:
import { createClient } from '@liveblocks/client'
const client = createClient({ ... })

const settings = await client.getNotificationSettings();
// { email: { thread: true, ... }, slack: { thread: false, ... }, ... }
console.log(settings);

const updatedSettings = await client.updateNotificationSettings({
  email: {
    thread: false,
  }
});

----------------------------------------

TITLE: Updating Schema with Liveblocks API
DESCRIPTION: Updates a schema's body and increments its version using the schema ID (name@version format). Returns the updated schema details including ID, name, and version.

LANGUAGE: typescript
CODE:
const schema = await liveblocks.updateSchema("my-schema-name@1");

// { id: "my-schema-name@1", name: "my-schema-name", version: 1, ... }
console.log(schema);

----------------------------------------

TITLE: Implementing Multiple TipTap Editors with Different Fields
DESCRIPTION: This example shows the complete implementation of multiple editors on one page, each with its own field property. The TextEditor component accepts a field prop which is passed to useLiveblocksExtension.

LANGUAGE: tsx
CODE:
import { useLiveblocksExtension } from "@liveblocks/react-tiptap";
import { useEditor, EditorContent } from "@tiptap/react";

function TextEditors() {
  return (
    <div>
      // +++
      <TextEditor field="one" />
      <TextEditor field="two" />
      // +++
    </div>
  );
}

function TextEditor({ field }: { field: string }) {
  // +++
  const liveblocks = useLiveblocksExtension({ field });
  // +++

  const editor = useEditor({
    extensions: [
      liveblocks,
      // ...
    ],
  });

  return (
    <div>
      <EditorContent editor={editor} />
    </div>
  );
}

----------------------------------------

TITLE: Basic AnchoredThreads Implementation Example
DESCRIPTION: Shows the basic implementation of the AnchoredThreads component to display threads vertically alongside the BlockNote editor.

LANGUAGE: tsx
CODE:
<AnchoredThreads editor={editor} threads={threads} />

----------------------------------------

TITLE: Mass Mutating Storage Across Multiple Rooms in Liveblocks
DESCRIPTION: Uses massMutateStorage to modify storage contents for multiple rooms simultaneously. Without filters, it modifies all rooms in the project, allowing operations such as adding items to LiveLists.

LANGUAGE: typescript
CODE:
// Mutate a number of rooms
await liveblocks.massMutateStorage(
  {},

  // Callback runs on every selected room
  ({ room, root }) => {
    // { type: "room", id: "my-room-id", metadata: {...}, ... }
    console.log(room);

    root.get("animals").push("🦍");
  }
);

----------------------------------------

TITLE: Creating a Version History Summary List with Selection Handling
DESCRIPTION: Example of building a complete version history list from individual summary components. Maps through available versions and renders each with proper selection handling.

LANGUAGE: tsx
CODE:
<HistoryVersionSummaryList>
  {versions?.map((version) => (
    <HistoryVersionSummary
      onClick={() => {
        setSelectedVersionId(version.id);
      }}
      key={version.id}
      version={version}
      selected={version.id === selectedVersionId}
    />
  ))}
</HistoryVersionSummaryList>

----------------------------------------

TITLE: Subscribing to History Changes in Liveblocks Room (TypeScript)
DESCRIPTION: Shows how to subscribe to history change events in a Liveblocks room. The callback receives an object with canUndo and canRedo boolean values that indicate whether undo/redo operations are available.

LANGUAGE: typescript
CODE:
const unsubscribe = room.subscribe("history", ({ canUndo, canRedo }) => {
  // Do something
});

----------------------------------------

TITLE: Using Pagination with useInboxNotifications Hook
DESCRIPTION: Example showing how to use the pagination features added to the useInboxNotifications hook to incrementally load inbox notifications as users interact with the app.

LANGUAGE: tsx
CODE:
const {
  inboxNotifications,
  isLoading,
  error,

  // ✨ New in Liveblocks 2.9
  fetchMore,
  isFetchingMore,
  hasFetchedAll,
  fetchMoreError,
} = useInboxNotifications();

----------------------------------------

TITLE: Getting the Client ID from Awareness
DESCRIPTION: Demonstrates how to retrieve the unique client identifier from the awareness object.

LANGUAGE: typescript
CODE:
// A unique number representing the current user
const clientId: number = awareness.clientId;

----------------------------------------

TITLE: Using FileSize Component with Comment Attachments
DESCRIPTION: Example showing how to use the FileSize component to display human-readable sizes of attachments in comments. This integrates with the comment data structure from Liveblocks.

LANGUAGE: tsx
CODE:
import { CommentData, FileSize } from "@liveblocks/react-ui";

function MyComment({ comment }: { comment: CommentData }) {
  return (
    <div>
      {/* ... */}

      {comment.attachments.map((attachment) => (
        <div key={attachment.id}>
          {attachment.name}
          // +++
          <FileSize size={attachment.size} />
          // +++
        </div>
      ))}
    </div>
  );
}

----------------------------------------

TITLE: Implementing User Resolution in LiveblocksProvider
DESCRIPTION: Example of implementing the resolveUsers function in LiveblocksProvider to map user IDs to user objects with name and avatar information. This is essential for displaying user data in Comments components and other collaborative features.

LANGUAGE: tsx
CODE:
import { LiveblocksProvider } from "@liveblocks/react/suspense";

function App() {
  return (
    <LiveblocksProvider
      resolveUsers={async ({ userIds }) => {
        const usersData = await __getUsersFromDB__(userIds);

        return usersData.map((userData) => ({
          name: userData.name,
          avatar: userData.avatar.src,
        }));
      }}

      // Other props
      // ...
    >
      {/* children */}
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Initializing Liveblocks Configuration File
DESCRIPTION: Command to create the liveblocks.config.ts file, which can be used later to define types for the application.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --init --framework react

----------------------------------------

TITLE: Comparing Old and New Room Entry APIs in Liveblocks Client
DESCRIPTION: Shows the transition from deprecated client room entry APIs to the new recommended approach. The new API returns both the room and a leave function, supporting multiple entries to the same room.

LANGUAGE: typescript
CODE:
// Old APIs we'll no longer be recommending (but that will remain working)
const room = client.enter("my-room", options);
client.getRoom("my-room");
client.leave("my-room");

LANGUAGE: typescript
CODE:
// New API we'll be recommending instead
const { room, leave } = client.enterRoom("my-room", options);
leave();

----------------------------------------

TITLE: Clearing content from a ProseMirror document
DESCRIPTION: Remove all content from a ProseMirror document using the clearContent method, effectively resetting the document to an empty state.

LANGUAGE: typescript
CODE:
await withProsemirrorDocument(
  { roomId: "my-room-id", client: liveblocks },
  async (api) => {
    // +++
    return api.clearContent();
    // +++
  }
);

----------------------------------------

TITLE: Implementing Thread Components for Comments in Tiptap
DESCRIPTION: Sets up AnchoredThreads and FloatingThreads components to display comment threads associated with text selections within the editor.

LANGUAGE: tsx
CODE:
export function Threads({ editor }) {
  const { threads } = useThreads();

  return (
    <>
      <AnchoredThreads editor={editor} threads={threads} />
      <FloatingThreads editor={editor} threads={threads} />
    </>
  );
}

----------------------------------------

TITLE: Verifying Webhook Request with Stringified Body
DESCRIPTION: Example of verifying a webhook request when the framework parses request bodies into objects, requiring JSON.stringify to be used.

LANGUAGE: javascript
CODE:
const event = webhookHandler.verifyRequest({
  headers: req.headers,
  rawBody: JSON.stringify(req.body),
});

----------------------------------------

TITLE: Initializing Liveblocks Configuration File
DESCRIPTION: Command to initialize the liveblocks.config.ts file using the create-liveblocks-app CLI tool, which can later be used to define types for the application.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --init --framework javascript

----------------------------------------

TITLE: Using LiveblocksProvider with Unsaved Changes Prevention
DESCRIPTION: Example of using the LiveblocksProvider component in React with the preventUnsavedChanges prop enabled to prevent browser tabs from closing while local changes are not yet synchronized.

LANGUAGE: JSX
CODE:
<LiveblocksProvider preventUnsavedChanges />

----------------------------------------

TITLE: Using Pagination with useInboxNotifications in React
DESCRIPTION: Code example showing the new pagination support added to the useInboxNotifications hook in Liveblocks v2.9. This feature enables more efficient loading of inbox notifications with pagination controls.

LANGUAGE: tsx
CODE:
const {
  inboxNotifications,
  isLoading,
  error,

  // ✨ New in Liveblocks 2.9
  fetchMore,
  isFetchingMore,
  hasFetchedAll,
  fetchMoreError,
} = useInboxNotifications();

----------------------------------------

TITLE: Creating a Simple Design System Link Component in React
DESCRIPTION: Shows an example of a design system link component that could be integrated with Liveblocks Comment primitives.

LANGUAGE: tsx
CODE:
function DesignSystemLink({ url, children }) {
  return (
    <a href={url} target="_blank">
      {children}
    </a>
  );
}

----------------------------------------

TITLE: Implementing MentionSuggestions for Composer.Editor
DESCRIPTION: Shows how to set up the MentionSuggestions component within Composer.Editor to display a list of user suggestions.

LANGUAGE: tsx
CODE:
<Composer.Editor
  components={{
    MentionSuggestions: () => (
      <Composer.Suggestions>
        <Composer.SuggestionsList>
          <Composer.SuggestionsListItem />
        </Composer.SuggestionsList>
      </Composer.Suggestions>
    ),
  }}
/>

----------------------------------------

TITLE: Using ClientSideSuspense for SSR with Liveblocks
DESCRIPTION: This code shows how to use ClientSideSuspense from Liveblocks when working with Server Side Rendering frameworks like Next.js. This approach allows Suspense functionality to work correctly with SSR by only suspending on the client side.

LANGUAGE: tsx
CODE:
import { ClientSideSuspense } from "@liveblocks/react/suspense";

// ...

function Index() {
  return (
    <RoomProvider
      id="my-room-id"
      initialPresence={/* ... */}
      initialStorage={/* ... */}
    >
      <ClientSideSuspense fallback={<div>Loading...</div>}>
        {() => <App />}
      </ClientSideSuspense>
    </RoomProvider>
  );
}

----------------------------------------

TITLE: Setting Up Storage Mapping with Liveblocks Redux
DESCRIPTION: Configures storageMapping to synchronize scientist data from Redux state with Liveblocks Room storage.

LANGUAGE: js
CODE:
import { liveblocksEnhancer } from "@liveblocks/redux";

const initialState = {
  scientist: { name: "" },
};

const slice = createSlice({
  name: "state",
  initialState,
  reducers: {
    /* reducers */
  },
});

const store = configureStore({
  reducer: slice.reducer,
  enhancers: [
    liveblocksEnhancer({
      client,
      storageMapping: { scientist: true },
    }),
  ],
});

----------------------------------------

TITLE: Creating and Storing a Yjs Subdocument
DESCRIPTION: Shows how to create a new Yjs subdocument, add it to the main document's map, and add content to it. The example also demonstrates how to track the subdocument's GUID for later retrieval.

LANGUAGE: ts
CODE:
import { LiveblocksYjsProvider } from "@liveblocks/yjs";
import * as Y from "yjs";

// Create main document and connect, disabling auto-loading of subdocuments
const yDoc = new Y.Doc();
const yProvider = new LiveblocksYjsProvider(room, doc, {
  autoloadSubdocs: false,
});

// Create a Y.Map to hold subdocuments
const subdocMap = yDoc.getMap("subdocs");

// Create subdocument
const subdoc = new Y.Doc();
yDoc.getMap().set("my-document", subdoc);
subdoc.getText("default").insert(0, "This is a subdocument");

// Make note of its `guid`, which is used for retrieving it later
const guid = subdoc.guid; // e.g. "c4a755..."

----------------------------------------

TITLE: Retrieving Schema by Room ID with Liveblocks API
DESCRIPTION: Fetches the schema attached to a specific room using the room ID. Throws an error if the room is not found. Returns the schema details including ID, name, and version.

LANGUAGE: typescript
CODE:
const schema = await liveblocks.getSchemaByRoomId("my-room-id");

// { id: "my-schema-name@1", name: "my-schema-name", version: 1, ... }
console.log(schema);

----------------------------------------

TITLE: Using media query hook for responsive thread components
DESCRIPTION: Alternative implementation for responsive thread display using a custom useIsMobile hook to conditionally render FloatingThreads or AnchoredThreads based on screen size.

LANGUAGE: tsx
CODE:
import { useSyncExternalStore } from "react";
import { useThreads } from "@liveblocks/react/suspense";
import { AnchoredThreads, FloatingThreads } from "@liveblocks/react-blocknote";
import { BlockNoteEditor } from "@blocknote/core";

function ThreadOverlay({ editor }: { editor: BlockNoteEditor | null }) {
  const { threads } = useThreads({ query: { resolved: false } });
  // +++
  const isMobile = useIsMobile();
  // +++

  // +++
  if (isMobile) {
    return (
      <FloatingThreads
        editor={editor}
        threads={threads}
        style={{ width: "350px" }}
      />
    );
  }
  // +++

  // +++
  return (
    <AnchoredThreads
      editor={editor}
      threads={threads}
      style={{ width: "350px" }}
    />
  );
  //+++
}

export function useIsMobile() {
  return useSyncExternalStore(subscribe, getSnapshot, getSnapshot);
}

function subscribe(callback: () => void) {
  const query = window.matchMedia("(max-width: 1024px)");

  query.addEventListener("change", callback);
  return () => query.removeEventListener("change", callback);
}

function getSnapshot() {
  const query = window.matchMedia("(max-width: 1024px)");
  return query.matches;
}

----------------------------------------

TITLE: LiveObject Updates with Validation
DESCRIPTION: Shows valid and invalid updates to LiveObject fields. Demonstrates the requirement to use the LiveObject constructor when setting values.

LANGUAGE: typescript
CODE:
// ✅
root.set("scientist", new LiveObject({ name: "Marie Curie"; age: 66 }));

// ❌ Should be a LiveObject
root.set("scientist", { name: "Marie Curie"; age: 66 });

----------------------------------------

TITLE: Using Pagination with useThreads Hook in React
DESCRIPTION: Example of using the pagination features added in version 2.9.0 with the useThreads hook, showing how to query threads and handle pagination with fetchMore functionality.

LANGUAGE: tsx
CODE:
const {
  threads,
  isLoading,
  error,

  // ✨ New in Liveblocks 2.9
  fetchMore,
  isFetchingMore,
  hasFetchedAll,
  fetchMoreError,
} = useThreads({ query });

----------------------------------------

TITLE: Initializing Liveblocks Config File
DESCRIPTION: Command to initialize the liveblocks.config.ts file which can later be used to define types for the application.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --init --framework react

----------------------------------------

TITLE: Using One-Time Sync Event Listeners
DESCRIPTION: Shows how to add an event listener that will be called only once when a sync event occurs on a LiveblocksYjsProvider instance.

LANGUAGE: typescript
CODE:
// Listen for the sync event only once
yProvider.once("sync", (isSynced: boolean) => {
  if (isSynced === true) {
    // Yjs content is synchronized and ready
  } else {
    // Yjs content is not synchronized
  }
});

----------------------------------------

TITLE: Updating Room Notification Settings in Liveblocks
DESCRIPTION: Uses the liveblocks.updateRoomNotificationSettings method to modify a user's notification preferences for a specific room. Requires roomId, userId, and data containing the updated settings.

LANGUAGE: typescript
CODE:
const updatedNotificationSettings =
  await liveblocks.updateRoomNotificationSettings({
    roomId: "my-room-id",
    userId: "steven@example.com",
    data: {
      threads: "replies_and_mentions",
    },
  });

// { threads: "replies_and_mentions", ... }
console.log(updatedNotificationSettings);

----------------------------------------

TITLE: Importing hooks directly in Liveblocks React components
DESCRIPTION: Shows the improved import pattern in Liveblocks 2.0 where hooks can be imported directly from the package rather than from a local config file. This simplifies component code and improves developer experience.

LANGUAGE: typescript
CODE:
// ❌ Before: get hooks exported from your Liveblocks config
import { RoomProvider, useRoom, ... } from "./liveblocks.config";

// ✅ After: import hooks directly
import { RoomProvider, useRoom, ... } from "@liveblocks/react";
import { RoomProvider, useRoom, ... } from "@liveblocks/react/suspense";

----------------------------------------

TITLE: Structure of an Inbox Notification Object in TypeScript
DESCRIPTION: This code snippet shows the structure of an inbox notification object for a custom notification in Liveblocks. It includes properties such as id, kind, subjectId, readAt, notifiedAt, and activityData which contains custom properties.

LANGUAGE: typescript
CODE:
{
  id: "in_sfj29g...",
  kind: "$myCustomNotification",
  subjectId: "myCustomId_dxs9s0",
  readAt: Date <Fri Dec 16 2023 15:16:25 GMT+0000 (Greenwich Mean Time)>,
  notifiedAt: Date <Fri Dec 15 2023 14:15:22 GMT+0000 (Greenwich Mean Time)>,
  activityData: {
    myCustomProperty: "myCustomValue",
  }
}

----------------------------------------

TITLE: Rendering a Basic Composer Component in React
DESCRIPTION: Demonstrates the basic structure of the Composer component with its subcomponents including Form, AttachmentsDropArea, Editor, AttachFiles and Submit button.

LANGUAGE: tsx
CODE:
<Composer.Form>
  <Composer.AttachmentsDropArea />
  <Composer.Editor
    components={{
      Mention: () => <Composer.Mention />,
      MentionSuggestions: () => (
        <Composer.Suggestions>
          <Composer.SuggestionsList>
            <Composer.SuggestionsListItem />
          </Composer.SuggestionsList>
        </Composer.Suggestions>
      ),
      Link: () => <Composer.Link />,
    }}
  />
  <Composer.AttachFiles />
  <Composer.Submit />
</Composer.Form>

----------------------------------------

TITLE: Creating Custom Composer Behavior with useComposer
DESCRIPTION: Example of using useComposer with Composer primitives to create a custom composer with enhanced behavior. This shows how to implement features like creating mentions directly through a button click.

LANGUAGE: tsx
CODE:
import { Composer, useComposer } from "@liveblocks/react-ui/primitives";
import { useCreateThread } from "@liveblocks/react/suspense";

function MyComposer() {
  const createThread = useCreateThread();

  return (
    <Composer.Form
      onComposerSubmit={({ body, attachments }) => {
        const thread = createThread({
          body,
          attachments,
          metadata: {},
        });
      }}
    >
      <Editor />
    </Composer.Form>
  );
}

function Editor() {
  // +++
  const { createMention } = useComposer();
  // +++

  return (
    <>
      <Composer.Editor components={/* Your custom component parts */} />
      // +++
      <button onClick={createMention}>Add mention</button>
      // +++
    </>
  );
}

----------------------------------------

TITLE: Using Regular Hooks with Loading Checks in React
DESCRIPTION: Shows how to use non-Suspense Liveblocks hooks that return null while loading, requiring manual checks before rendering the main component.

LANGUAGE: tsx
CODE:
import { useStorage } from "@liveblocks/react";

function Component() {
  // `animals` is `null` when loading
  const animals = useStorage((root) => root.animals);

  if (!animals) {
    return <div>Loading…</div>;
  }

  // ...
}

----------------------------------------

TITLE: Targeting Liveblocks Components with Class Names
DESCRIPTION: Shows how to customize specific Liveblocks components using their predefined class names. This approach allows for more granular styling of individual components like threads and composers.

LANGUAGE: css
CODE:
.lb-thread {
  /* Customise thread */
}

.lb-composer {
  /* Customise composer */
}

----------------------------------------

TITLE: Installing Liveblocks Client Package
DESCRIPTION: Command to install the Liveblocks client package via npm. All packages should use the same version to ensure compatibility.

LANGUAGE: bash
CODE:
npm install @liveblocks/client

----------------------------------------

TITLE: Resolving User and Room Data for Email Notifications in Liveblocks
DESCRIPTION: This snippet demonstrates how to use resolver functions to transform user IDs into names and avatars, and to provide room information for email notifications. The resolvers work similarly to those on the client side but are used in the email preparation process.

LANGUAGE: tsx
CODE:
// ...

emailData = await prepareThreadNotificationEmailAsReact(liveblocks, event, {
  // +++
  resolveUsers: async ({ userIds }) => {
    const usersData = await __getUsersFromDB__(userIds);

    return usersData.map((userData) => ({
      name: userData.name, // "Steven"
      avatar: userData.avatar.src, // "https://example.com/steven.jpg"
    }));
  },
  resolveRoomInfo: async ({ roomId }) => {
    const roomData = await __getRoomFromDB__(roomId);

    return {
      name: roomData.name, // "Untitled document"
      url: roomData.url, //`https://example.com/my-room-id`
    };
  },
  // +++
});

// ...

----------------------------------------

TITLE: Converting CommentBody to String with stringifyCommentBody
DESCRIPTION: The stringifyCommentBody function converts a CommentBody object into a plain string. This is useful for displaying comment content in a simple text format.

LANGUAGE: typescript
CODE:
import { stringifyCommentBody } from "@liveblocks/node";

const stringComment = await stringifyCommentBody(comment.body);

----------------------------------------

TITLE: Adding Destroyed Event Listener to Awareness
DESCRIPTION: Shows how to listen for the destroyed event which is triggered when awareness.destroy is called.

LANGUAGE: typescript
CODE:
awareness.on("destroyed", () => {
  // Awareness has been cleaned up
});

----------------------------------------

TITLE: Setting Throttle Rate in LiveblocksProvider
DESCRIPTION: Configures the LiveblocksProvider with a throttle prop of 16ms (equivalent to 60fps) to make cursor movements smoother. The default throttle rate is 100ms.

LANGUAGE: tsx
CODE:
<LiveblocksProvider publicApiKey={publicApiKey} throttle={16}>

----------------------------------------

TITLE: Configuring User Metadata in Access Tokens for Liveblocks Comments
DESCRIPTION: Example of attaching user metadata (name and avatar) when preparing a session using access token authentication. This sets up the necessary user info for Comments components.

LANGUAGE: typescript
CODE:
const session = liveblocks.prepareSession("marc@example.com", {
  userInfo: {
    name: "Marc",
    avatar: "https://example.com/marc.png",

    // Your custom metadata
    // ...
  },
});

----------------------------------------

TITLE: Detaching Schema from Room with Liveblocks API
DESCRIPTION: Detaches a schema from a room using the room ID. This operation removes schema validation from the room. Returns no response.

LANGUAGE: typescript
CODE:
await liveblocks.detachSchemaFromRoom("my-room-id");

----------------------------------------

TITLE: Retrieving Room Notification Settings in Liveblocks
DESCRIPTION: Uses the liveblocks.getRoomNotificationSettings method to fetch a user's notification preferences for a specific room. Requires roomId and userId parameters and returns the current notification settings.

LANGUAGE: typescript
CODE:
const notificationSettings = await liveblocks.getRoomNotificationSettings({
  roomId: "my-room-id",
  userId: "steven@example.com",
});

// { threads: "all", ... }
console.log(notificationSettings);

----------------------------------------

TITLE: Initializing Liveblocks configuration file
DESCRIPTION: Creates the liveblocks.config.ts file which can be used later to define types for the application.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --init --framework react

----------------------------------------

TITLE: Configuring BlockNote and Liveblocks options
DESCRIPTION: Example showing how to apply configuration options to both BlockNote editor and Liveblocks integration, including animation settings and initial content.

LANGUAGE: tsx
CODE:
const editor = useCreateBlockNoteWithLiveblocks(
  {
    // +++
    animations: false,
    trailingBlock: false,
    // +++

    // Other BlockNote options
    // ...
  },
  {
    // +++
    initialContent: "<p>Hello world</p>",
    field: "editor-one",
    // +++

    // Other Liveblocks options
    // ...
  }
);

----------------------------------------

TITLE: Constructing a Custom Toolbar with Default Components in React-TipTap
DESCRIPTION: Illustrates how to use Liveblocks' pre-built toolbar sections to construct a custom toolbar. The example shows how the default toolbar is built using components like BlockSelector, SectionInline, and SectionCollaboration.

LANGUAGE: tsx
CODE:
import { FloatingToolbar, Toolbar } from "@liveblocks/react-tiptap";
import { Editor } from "@tiptap/react";

function CustomToolbar({ editor }: { editor: Editor | null }) {
  return (
    <FloatingToolbar editor={editor}>
      // +++
      <Toolbar.BlockSelector />
      <Toolbar.SectionInline />
      <Toolbar.Separator />
      <Toolbar.SectionCollaboration />
      // +++
    </FloatingToolbar>
  );
}

----------------------------------------

TITLE: Modifying and Updating a Y.Doc on the Liveblocks Server
DESCRIPTION: This code shows how to retrieve a Y.Doc, make changes to it, and send those changes back to Liveblocks so they're applied for all connected users. It demonstrates creating a text node, inserting text, encoding the state as an update, and sending it to Liveblocks.

LANGUAGE: typescript
CODE:
import * as Y from "yjs";
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export async function POST() {
  // Get your Yjs data as a binary update
  const update = await liveblocks.getYjsDocumentAsBinaryUpdate("my-room-name");

  // Create a Yjs document
  const yDoc = new Y.Doc();

  // Apply the binary update to `yDoc`
  Y.applyUpdate(yDoc, new Uint8Array(update));

  // An example of a `yDoc` modification
  const yText = yDoc.getText("text");
  yText.insert(0, "Hello world");

  // Encode the document state as an update
  const yUpdate = Y.encodeStateAsUpdate(yDoc);

  // Send the update to Liveblocks
  await liveblocks.sendYjsBinaryUpdate(roomId, yUpdate);
}

----------------------------------------

TITLE: Configuring Liveblocks Types in TypeScript
DESCRIPTION: Example of how to globally declare Liveblocks interface types in a configuration file. This demonstrates the improvement in DX introduced in v2.0 where types can be specified once and shared across all Liveblocks APIs.

LANGUAGE: typescript
CODE:
// ❌ Before
export const {
  suspense: {
    RoomProvider,
    useRoom,
    // etc
  },
} = createRoomContext<Presence, Storage>(client);

// ✅ After
declare global {
  interface Liveblocks {
    Presence: Presence;
    Storage: Storage;
  }
}

----------------------------------------

TITLE: Setting Up Liveblocks Presence in Zustand Store
DESCRIPTION: Configures a Zustand store with Liveblocks integration, including presence mapping for cursor position. This setup allows sharing cursor position in real-time with other users in the room.

LANGUAGE: ts
CODE:
import create from "zustand";
import { createClient } from "@liveblocks/client";
import { liveblocks } from "@liveblocks/zustand";
import type { WithLiveblocks } from "@liveblocks/zustand";

type Cursor = { x: number; y: number };

type State = {
  cursor: Cursor;
  setCursor: (cursor: Cursor) => void;
};

const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

const useStore = create<WithLiveblocks<State>>()(
  liveblocks(
    (set) => ({
      cursor: { x: 0, y: 0 },
      setCursor: (cursor) => set({ cursor }),
    }),
    {
      client,
      presenceMapping: {
        cursor: true,
      },
    }
  )
);

export default useStore;

----------------------------------------

TITLE: Filtering Threads with useThreads Query in Liveblocks
DESCRIPTION: Demonstrates how to filter threads using the query option in useThreads. Allows filtering by metadata properties and resolved status.

LANGUAGE: tsx
CODE:
// Returns threads that match the entire `query`, e.g. { color: "blue", pinned: true, ... }
const { threads } = useThreads({
  query: {
    // Filter for unresolved threads
    resolved: false,

    metadata: {
      // Filter for threads that contain specific string, boolean, and number data
      color: "blue",
      pinned: true,
      priority: 3,

      // Filter for threads with string metadata that starts with a certain value
      organization: {
        startsWith: "liveblocks:",
      },
    },
  },
});

----------------------------------------

TITLE: Implementing a Custom Toolbar Button with TypeScript
DESCRIPTION: This code shows how to create a custom button for the Lexical toolbar. It defines a Help button with an icon, keyboard shortcut, and click handler that could be added to a custom toolbar.

LANGUAGE: tsx
CODE:
function CustomButton() {
  return (
    // +++
    <Toolbar.Button
      name="Help"
      icon={<Icon.QuestionMark />}
      shortcut="CMD-H"
      onClick={() => console.log("help")}
    />
    // +++
  );
}

----------------------------------------

TITLE: Using Aliased One-Time Sync Event Listeners
DESCRIPTION: Demonstrates that 'sync' and 'synced' event names can be used interchangeably when adding one-time event listeners for synchronization events.

LANGUAGE: typescript
CODE:
// "sync" and "synced" both listen to the same event
yProvider.once("sync", (sync: boolean) => /* ... */);
yProvider.once("synced", (sync: boolean) => /* ... */);

----------------------------------------

TITLE: Anonymous Object Types in Liveblocks Schema
DESCRIPTION: Demonstrates how to use anonymous (inline) object types in a schema. This approach defines the object structure directly within the parent type.

LANGUAGE: typescript
CODE:
type Storage  {
  scientist: { name: string, age: number }
}

----------------------------------------

TITLE: Deleting a Thread in Liveblocks using TypeScript
DESCRIPTION: Uses the liveblocks.deleteThread method to completely remove a thread. Requires roomId and threadId parameters. The method throws an error if the room or thread is not found.

LANGUAGE: typescript
CODE:
await liveblocks.deleteThread({
  roomId: "my-room-id",
  threadId: "th_d75sF3...",
});

----------------------------------------

TITLE: Customizing FloatingToolbar position and offset
DESCRIPTION: Shows how to customize the position and offset of the FloatingToolbar relative to the current text selection.

LANGUAGE: tsx
CODE:
<FloatingToolbar
  editor={editor}
  // +++
  position="bottom" // Position can be `top` or `bottom`
  offset={12} // Distance in px from selection
  // +++
/>

----------------------------------------

TITLE: Using useUpdateNotificationSettings Hook in React
DESCRIPTION: Example showing how to use the useUpdateNotificationSettings hook from @liveblocks/react for simpler use cases where you only need to update settings, such as an unsubscribe button implementation.

LANGUAGE: tsx
CODE:
// A suspense version of this hook is available
import { useUpdateNotificationSettings } from "@liveblocks/react";

const updateSettings = useUpdateNotificationSettings();

const onUnsubscribe = () => {
  updateSettings({
    slack: {
      thread: false,
    },
  });
};

----------------------------------------

TITLE: Using useUpdateNotificationSettings Hook with React
DESCRIPTION: Shows how to use the useUpdateNotificationSettings hook for simpler update-only scenarios like unsubscribe buttons in a React component.

LANGUAGE: tsx
CODE:
// A suspense version of this hook is available
import { useUpdateNotificationSettings } from "@liveblocks/react";

const updateSettings = useUpdateNotificationSettings();

const onUnsubscribe = () => {
  updateSettings({
    slack: {
      thread: false,
    },
  });
};

----------------------------------------

TITLE: Using useInboxNotifications with pagination support in React
DESCRIPTION: Shows how to use the useInboxNotifications hook with pagination features to fetch more notifications beyond the default limit of 50.

LANGUAGE: tsx
CODE:
import { useInboxNotifications } from "@liveblocks/react";

const {
  inboxNotifications,
  isLoading,
  error,

  +++
  hasFetchedAll,
  fetchMore,
  isFetchingMore,
  fetchMoreError,
  +++
} = useInboxNotifications();

----------------------------------------

TITLE: Setting up Yjs Provider with React
DESCRIPTION: Demonstrates how to set up a Yjs provider in a React application using the useRoom hook and getYjsProviderForRoom function from the @liveblocks/yjs package. This allows access to a Y.Doc for collaborative editing.

LANGUAGE: typescript
CODE:
import { useRoom } from "@liveblocks/react";
import { getYjsProviderForRoom } from "@liveblocks/yjs";

function App() {
  const room = useRoom();
  const yProvider = getYjsProviderForRoom(room);
  const yDoc = yProvider.getYDoc();

  // ...
}

----------------------------------------

TITLE: Handling Errors with LiveblocksError in TypeScript
DESCRIPTION: Demonstrates how to handle errors when working with Liveblocks API methods, using the LiveblocksError class to access HTTP status codes and error messages.

LANGUAGE: typescript
CODE:
try {
  const room = await liveblocks.getRoom("my-room-id");
  // Process room
} catch (error) {
  if (error instanceof LiveblocksError) {
    // Handle specific LiveblocksError cases
    console.error(`Error fetching room: ${error.status} - ${error.message}`);
    switch (
      error.status
      // Specific cases based on status codes
    ) {
    }
  } else {
    // Handle general errors
    console.error(`Unexpected error: ${error.message}`);
  }
}

----------------------------------------

TITLE: Mutating Storage with @liveblocks/node
DESCRIPTION: Example of using the mutateStorage method to make changes to Storage from a backend.

LANGUAGE: javascript
CODE:
// New method `.mutateStorage()` which can be used to make changes to Storage
// from your backend.

----------------------------------------

TITLE: Initializing Liveblocks Extension with TipTap Editor
DESCRIPTION: This snippet shows the basic implementation of the useLiveblocksExtension hook to add collaborative features to a TipTap editor. The extension is passed to the useEditor hook as part of the extensions array.

LANGUAGE: tsx
CODE:
import { useLiveblocksExtension } from "@liveblocks/react-tiptap";
import { useEditor, EditorContent } from "@tiptap/react";

function TextEditor() {
  // +++
  const liveblocks = useLiveblocksExtension();
  // +++

  const editor = useEditor({
    extensions: [
      // +++
      liveblocks,
      // +++
      // ...
    ],
  });

  return (
    <div>
      <EditorContent editor={editor} />
    </div>
  );
}

----------------------------------------

TITLE: Checking if Liveblocks storage is loading
DESCRIPTION: Determining if the room storage is currently in a loading state, which is useful for showing loading indicators in the UI.

LANGUAGE: javascript
CODE:
const {
  liveblocks: { isStorageLoading },
} = useStore();

----------------------------------------

TITLE: Using useComposer Hook in Liveblocks
DESCRIPTION: Basic usage of the useComposer hook to access composer-related states and methods. This hook can only be used within the Composer.Form primitive and provides functionality for managing the comment composer.

LANGUAGE: tsx
CODE:
import { useComposer } from "@liveblocks/react-ui/primitives";

const { isEmpty, attachments, submit /* ... */ } = useComposer();

----------------------------------------

TITLE: Initializing LiveblocksYjsProvider Directly
DESCRIPTION: Shows how to initialize the LiveblocksYjsProvider class directly with a Yjs document and Liveblocks room. Note that using getYjsProviderForRoom is generally recommended instead as it handles cleanup automatically.

LANGUAGE: typescript
CODE:
import * as Y from "yjs";
import { createClient } from "@liveblocks/client";
import { LiveblocksYjsProvider } from "@liveblocks/yjs";

const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

const { room, leave } = client.enterRoom("your-room-id");

// Create Yjs document and provider
const yDoc = new Y.Doc();
const yProvider = new LiveblocksYjsProvider(room, yDoc, {
  // Options
  // ...
});

----------------------------------------

TITLE: Thread Notification Email Response Structure Example
DESCRIPTION: This code snippet shows the expected response format for unread replies notifications from the prepareThreadNotificationEmailAsReact function. It returns thread information and an array of comment data.

LANGUAGE: js
CODE:
{
  type: "unreadReplies",
  roomId: "my-room-id",
  comments: [
    {/* Comment data */},
    // ...
  ],
}

----------------------------------------

TITLE: FloatingThreads Customization with Classes
DESCRIPTION: Shows how to customize the FloatingThreads component using CSS classes. The FloatingThreads component can be styled like a regular div element.

LANGUAGE: tsx
CODE:
<FloatingThreads threads={threads} className="my-floating-thread" />

----------------------------------------

TITLE: Deleting All Inbox Notifications with deleteAllInboxNotifications in TypeScript
DESCRIPTION: Demonstrates how to delete all inbox notifications for a user by providing their userId.

LANGUAGE: typescript
CODE:
await liveblocks.deleteAllInboxNotifications({
  userId: "steven@example.com",
});

----------------------------------------

TITLE: Implementing Thread Components for Collaborative Comments
DESCRIPTION: Sets up components for comments functionality in the text editor using FloatingComposer, AnchoredThreads, and FloatingThreads for displaying and creating threads on both desktop and mobile.

LANGUAGE: tsx
CODE:
"use client";

import { useThreads } from "@liveblocks/react/suspense";
import {
  AnchoredThreads,
  FloatingComposer,
  FloatingThreads,
} from "@liveblocks/react-lexical";

export function Threads() {
  const { threads } = useThreads();

  return (
    <>
      <div className="anchored-threads">
        <AnchoredThreads threads={threads} />
      </div>
      <FloatingThreads className="floating-threads" threads={threads} />
      <FloatingComposer className="floating-composer" />
    </>
  );
}

----------------------------------------

TITLE: Retrieving Values from a LiveMap in TypeScript
DESCRIPTION: Demonstrates how to get a specific element from a LiveMap by key using the get method, which returns undefined if the key doesn't exist.

LANGUAGE: typescript
CODE:
const map = new LiveMap([
  ["nimesh", "developer"],
  ["pierre", "designer"],
]);

// "developer"
map.get("nimesh");

// undefined
map.get("alicia");

----------------------------------------

TITLE: Using LiveblocksProvider Instead of createClient
DESCRIPTION: Example showing the transition from using createClient function to using the LiveblocksProvider component for initializing Liveblocks in v2.0.

LANGUAGE: typescript
CODE:
// ❌ Before
const client = createClient(/* options */);

// ✅ After
<LiveblocksProvider /* options */>
  <App />
</LiveblocksProvider>

----------------------------------------

TITLE: Customizing React Components in Thread Notification Emails
DESCRIPTION: This snippet shows how to customize the React components used to render comment bodies in notification emails. You can replace default components like Container, Paragraph, Text, Link, and Mention with your own styled components including react-email components.

LANGUAGE: tsx
CODE:
const emailData = await prepareThreadNotificationEmailAsReact(
  liveblocks,
  webhookEvent,
  {
    // +++
    components: {
      Paragraph: ({ children }) => <p>{children}</p>,

      // `react-email` components are supported
      Text: ({ children }) => (
        <Text className="text-sm text-black m-0 mb-4">{children}</Text>
      ),

      // `user` is the optional data returned from `resolveUsers`
      Mention: ({ element, user }) => (
        <span style={{ color: "red" }}>@{user?.name ?? element.id}</span>
      ),

      // If the link is rich-text render it, otherwise use the URL
      Link: ({ element, href }) => <a href={href}>{element?.text ?? href}</a>,
    },
    // +++
  }
);

// { type: "unreadMention", comment: { ... }, ... }
console.log(emailData);

// The components are now used in this React body
console.log(emailData.comment.reactBody);

----------------------------------------

TITLE: Basic FloatingToolbar implementation
DESCRIPTION: Shows how to implement a basic floating toolbar that appears near the current text selection for quick styling access.

LANGUAGE: tsx
CODE:
<FloatingToolbar editor={editor} />

----------------------------------------

TITLE: Using getSyncStatus Method in Liveblocks Client
DESCRIPTION: Example showing the new client.getSyncStatus() method that returns the synchronization status of local changes in Liveblocks, available from version 2.12.0.

LANGUAGE: typescript
CODE:
client.getSyncStatus()

----------------------------------------

TITLE: Installing the Connection Status Example with Liveblocks CLI
DESCRIPTION: Command to set up the Liveblocks connection status example project. This automatically downloads the example and helps set up your API key from your Liveblocks account.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-connection-status --api-key

----------------------------------------

TITLE: Using updateMyPresence with History Support
DESCRIPTION: Demonstrates how to use the updateMyPresence function with addToHistory option to add presence changes to the undo/redo stack.

LANGUAGE: ts
CODE:
updateMyPresence({ selectedId: "xxx" }, { addToHistory: true });

----------------------------------------

TITLE: Implementing Default Values in BlockNote with Yjs
DESCRIPTION: This solution avoids the duplication problem by waiting for Liveblocks Yjs to connect, checking if the editor's content is empty, and only then setting a default value using the editor's insertBlocks method.

LANGUAGE: tsx
CODE:
function Editor({ doc, provider }: EditorProps) {
  const editor = useEditor({
    // Options
    // ...
  });

  // +++
  // Set default state
  useEffect(() => {
    function setDefault() {
      if (!editor) {
        return;
      }

      if (editor.document.length === 1) {
        editor.insertBlocks(
          [{ type: "paragraph", content: "Hello world" }],
          editor.document[0]
        );
      }
    }

    if (provider.isReady) {
      setDefault();
    }

    provider.on("sync", setDefault);
    return () => provider.off("sync", setDefault);
  }, [provider, editor]);
  // +++

  return <BlockNoteView editor={editor} />;
}

----------------------------------------

TITLE: Demonstrating New Recommended Room Entry/Exit API in TypeScript
DESCRIPTION: Shows the new recommended API pattern for entering and leaving rooms. This approach returns both the room object and a leave function, supporting multiple connections to the same room.

LANGUAGE: typescript
CODE:
// New API we'll be recommending instead
const { room, leave } = client.enterRoom("my-room", options);
leave();

----------------------------------------

TITLE: Customizing React Components in prepareTextMentionNotificationEmailAsReact
DESCRIPTION: Example showing how to customize the React components used in the text mention notification email through the components option, allowing for styling and integration with email component libraries.

LANGUAGE: tsx
CODE:
const emailData = await prepareThreadNotificationEmailAsReact(
  liveblocks,
  webhookEvent,
  {
    // +++
    components: {
      // `react-email` components are supported
      Container: ({ children }) => <Section>{children}</Section>,

      Text: ({ children }) => (
        <Text className="text-sm text-black m-0 mb-4">{children}</Text>
      ),

      // `user` is the optional data returned from `resolveUsers`
      Mention: ({ element, user }) => (
        <span style={{ color: "red" }}>@{user?.name ?? element.id}</span>
      ),
    },
    // +++
  }
);

// { mention: { ... }, ... }
console.log(emailData);

// The components are now used in this React content
console.log(emailData.mention.reactContent);
``

----------------------------------------

TITLE: Revised Schema with Required Field in TypeScript
DESCRIPTION: An updated schema definition that makes the 'checked' field required instead of optional. This change demonstrates how schema validation can enforce constraints on data structure.

LANGUAGE: typescript
CODE:
type Storage {
  todos: LiveList<LiveObject<Todo>>
}

type Todo {
  text: string
  checked: boolean
}

----------------------------------------

TITLE: Typing Presence in Liveblocks Zustand Middleware
DESCRIPTION: Example of how to type the presence of other users in a room when using Liveblocks middleware with Zustand. Defines a separate Presence type and uses it as a type parameter for the middleware.

LANGUAGE: typescript
CODE:
type Presence = {
  isTyping: true;
}

const useStore = create(
  middleware<State, Presence>(/* ... */, {
    client,
    presenceMapping: { isTyping: true },
    storageMapping: { todos: true }
  })
);

// In your component
useStore(state => state.liveblocks.others[0].presence?.isTyping)

----------------------------------------

TITLE: Removing Sync Event Listeners
DESCRIPTION: Shows how to remove event listeners for sync events from a LiveblocksYjsProvider instance to prevent memory leaks.

LANGUAGE: typescript
CODE:
const handleSync = (synced: boolean) => {};
yProvider.on("sync", handleSync);

// Clean up sync event
yProvider.off("sync", handleSync);

----------------------------------------

TITLE: Using useMarkInboxNotificationAsRead hook in React
DESCRIPTION: Demonstrates how to mark a specific inbox notification as read for the current user using its ID.

LANGUAGE: tsx
CODE:
import { useMarkInboxNotificationAsRead } from "@liveblocks/react/suspense";

const markInboxNotificationAsRead = useMarkInboxNotificationAsRead();
markInboxNotificationAsRead("in_xxx");

----------------------------------------

TITLE: Basic Toolbar.BlockSelector implementation
DESCRIPTION: Shows how to implement a basic BlockSelector dropdown component within a Toolbar to allow switching between different block types like text, headings, and blockquotes.

LANGUAGE: tsx
CODE:
import { Toolbar } from "@liveblocks/react-tiptap";

<Toolbar editor={editor}>
  <Toolbar.BlockSelector />
</Toolbar>;

----------------------------------------

TITLE: Configuring Multiple TipTap Editors with Liveblocks Fields
DESCRIPTION: This snippet demonstrates using the field property to create multiple editors on one page. Each editor gets a unique field identifier, allowing them to maintain separate content states.

LANGUAGE: tsx
CODE:
import { useLiveblocksExtension } from "@liveblocks/react-tiptap";

function TextEditor() {
  const liveblocks = useLiveblocksExtension({
    // +++
    field: "editor-one",
    // +++
  });

  // ...
}

----------------------------------------

TITLE: Client Creation Pattern Update in Liveblocks v2
DESCRIPTION: Shows the change from using createClient function to using the LiveblocksProvider component for client initialization in Liveblocks v2.

LANGUAGE: typescript
CODE:
// ❌ Before
const client = createClient(/* options */);

// ✅ After
<LiveblocksProvider /* options */>
  <App />
</LiveblocksProvider>

----------------------------------------

TITLE: Using toPlainLson Utility in @liveblocks/client
DESCRIPTION: Utility function exported to assist in calling the initialize storage API, converting Liveblocks data structures to plain JavaScript objects.

LANGUAGE: typescript
CODE:
toPlainLson(liveBlocksData)

----------------------------------------

TITLE: Deploying Liveblocks Collaborative Dashboard to Vercel
DESCRIPTION: Command to create and deploy the collaborative dashboard example to Vercel. This sets up the project with Vercel integration for deployment and local development.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-dashboard --vercel

----------------------------------------

TITLE: Creating Fully Custom Thread Components with Comment Primitives
DESCRIPTION: Shows how to create completely custom thread components by replacing Thread with custom implementation using Comment primitives. This allows for maximum flexibility in styling and behavior of thread components.

LANGUAGE: tsx
CODE:
import { Comment } from "@liveblocks/react-ui/primitives";

<FloatingThreads
  editor={editor}
  threads={threads}
  className="my-floating-thread"
  components={{
    Thread: (props) => (
      // +++
      <div>
        {props.thread.comments.map((comment) => (
          <Comment.Body
            key={comment.id}
            body={comment.body}
            components={/* ... */}
          />
        ))}
      </div>
      // +++
    ),
  }}
/>;

----------------------------------------

TITLE: Adding One-time Destroyed Event Listener to Awareness
DESCRIPTION: Shows how to add a listener for the destroyed event that will only trigger once.

LANGUAGE: typescript
CODE:
awareness.once("destroyed", () => {
  // Awareness has been cleaned up
});

----------------------------------------

TITLE: Custom Mention Component for Comment.Body
DESCRIPTION: Defines a custom Mention component to be used within Comment.Body for displaying user mentions with formatting.

LANGUAGE: tsx
CODE:
<Comment.Body
  components={{
    Mention: ({ userId }) => <Comment.Mention>@{userId}</Comment.Mention>,
  }}
/>

----------------------------------------

TITLE: Preventing Unsaved Changes in LiveblocksProvider
DESCRIPTION: Example of using the preventUnsavedChanges option in LiveblocksProvider to warn users when they attempt to close a tab with unsynchronized changes. This helps prevent data loss when users have slow connections or abruptly close their browser.

LANGUAGE: tsx
CODE:
function Page() {
  return (
    <LiveblocksProvider
      // highlight-next-line
      preventUnsavedChanges

      // Other options
      // ...
    >
      ...
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Rendering Simple Custom Notification Components
DESCRIPTION: Demonstrates how to completely override the default component for a custom notification kind with a simple custom component.

LANGUAGE: tsx
CODE:
<InboxNotification
  inboxNotification={inboxNotification}
  kinds={{
    $myCustomNotification: (props) => <div>New notification</div>,
  }}
/>

----------------------------------------

TITLE: Setting up RoomProvider with Initial Storage in React
DESCRIPTION: Configures the RoomProvider component with initialStorage, creating a LiveObject for the scientist with default values. This establishes the initial state for the collaborative room.

LANGUAGE: typescript
CODE:
import { LiveObject } from "@liveblocks/client";
import { RoomProvider } from "@liveblocks/react/suspense";

/* App */

function Index() {
  return (
    <RoomProvider
      id="my-room-id"
      initialPresence={/* ... */}
      // +++
      initialStorage={{
        scientist: new LiveObject({
          firstName: "Marie",
          lastName: "Curie",
        }),
        // +++
      }}
    >
      <App />
    </RoomProvider>
  );
}

----------------------------------------

TITLE: Setting Initial Presence in RoomProvider
DESCRIPTION: This code shows how to configure the RoomProvider with an initialPresence property that sets the starting cursor position to null, indicating the user's cursor is off-screen when they first join.

LANGUAGE: tsx
CODE:
import { RoomProvider, useOthers } from "@liveblocks/react/suspense";

// App

function Index() {
  return (
    <RoomProvider id="my-room-id" initialPresence={{ cursor: null }}>
      <App />
    </RoomProvider>
  );
}

----------------------------------------

TITLE: Complete Next.js Route Handler Implementation for Thread Notifications
DESCRIPTION: This snippet shows a complete Next.js route handler implementation for processing Liveblocks webhook events. It verifies the webhook request, checks if it's a thread notification event, and processes it to create React-based email content.

LANGUAGE: tsx
CODE:
import { isThreadNotificationEvent, WebhookHandler } from "@liveblocks/node";
import { Liveblocks } from "@liveblocks/node";
// +++
import { prepareThreadNotificationEmailAsReact } from "@liveblocks/emails";
// +++

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

const webhookHandler = new WebhookHandler(
  process.env.LIVEBLOCKS_WEBHOOK_SECRET_KEY as string
);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // +++
  if (isThreadNotificationEvent(event)) {
    const emailData = await prepareThreadNotificationEmailAsReact(
      liveblocks,
      event
    );
    let email;

    switch (emailData.type) {
      case "unreadMention": {
        email = (
          <div>
            <div>
              @{emailData.comment.author.id} at {emailData.comment.createdAt}
            </div>
            <div>{emailData.comment.body}</div>
          </div>
        );
        break;
      }

      case "unreadReplies": {
        email = (
          <div>
            {emailData.comments.map((comment) => (
              <div key={comment.id}>
                <div>
                  @{comment.author.id} at {comment.createdAt}
                </div>
                <div>{comment.body}</div>
              </div>
            ))}
          </div>
        );
        break;
      }
    }

    // Send your email
    // ...
  }
  // +++

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Authenticating with JWT Token in Liveblocks API
DESCRIPTION: Example of how to use a JWT token in the authorization header for Liveblocks API calls.

LANGUAGE: bash
CODE:
curl https://liveblocks.net/api/v1/* \
  -H "Authorization: Bearer YOUR_JWT_TOKEN"

----------------------------------------

TITLE: Complete Implementation of FloatingComposer in React-Lexical
DESCRIPTION: Demonstrates a complete setup for FloatingComposer with the necessary Lexical and Liveblocks components. This allows users to create comment threads at the current text selection.

LANGUAGE: tsx
CODE:
import { LexicalComposer } from "@lexical/react/LexicalComposer";
import { RichTextPlugin } from "@lexical/react/LexicalRichTextPlugin";
import { ContentEditable } from "@lexical/react/LexicalContentEditable";
import { LexicalErrorBoundary } from "@lexical/react/LexicalErrorBoundary";
import {
  liveblocksConfig,
  LiveblocksPlugin,
  FloatingComposer,
} from "@liveblocks/react-lexical";

const initialConfig = liveblocksConfig({
  namespace: "MyEditor",
  theme: {},
  nodes: [],
  onError: (err) => console.error(err),
});

function Editor() {
  return (
    <LexicalComposer initialConfig={initialConfig}>
      <LiveblocksPlugin>
        <FloatingComposer style={{ width: "350px" }} />
      </LiveblocksPlugin>
      <RichTextPlugin
        contentEditable={<ContentEditable />}
        placeholder={<div>Enter some text...</div>}
        ErrorBoundary={LexicalErrorBoundary}
      />
    </LexicalComposer>
  );
}

----------------------------------------

TITLE: Checking a User's Room Permissions in Liveblocks
DESCRIPTION: This snippet shows how to retrieve and check a user's assigned permission types for a specific room using liveblocks.getRoom().

LANGUAGE: typescript
CODE:
const room = await liveblocks.getRoom("a32wQXid4A9");

// { "ellen@acme.inc": ["room:write"] }
console.log(room.data.usersAccesses);

----------------------------------------

TITLE: Using useDeleteAllInboxNotifications hook in React
DESCRIPTION: Shows how to delete all inbox notifications for the current user.

LANGUAGE: tsx
CODE:
import { useDeleteAllInboxNotifications } from "@liveblocks/react/suspense";

const deleteAllInboxNotifications = useDeleteAllInboxNotifications();
deleteAllInboxNotifications();

----------------------------------------

TITLE: Creating a Liveblocks Room Component in Next.js
DESCRIPTION: Sets up a Room component with LiveblocksProvider, RoomProvider, and ClientSideSuspense to establish a collaborative space. This component handles room connection and loading states.

LANGUAGE: tsx
CODE:
"use client";

import { ReactNode } from "react";
import {
  LiveblocksProvider,
  RoomProvider,
  ClientSideSuspense,
} from "@liveblocks/react/suspense";

export function Room({ children }: { children: ReactNode }) {
  return (
    <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>\n      <RoomProvider id="my-room">\n        <ClientSideSuspense fallback={<div>Loading…</div>}>\n          {children}\n        </ClientSideSuspense>\n      </RoomProvider>\n    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Initializing Liveblocks Configuration
DESCRIPTION: Command to create and initialize the liveblocks.config.ts file which will be used to define types for the application. Uses the create-liveblocks-app CLI tool to set up the configuration.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --init --framework react

----------------------------------------

TITLE: Using getOrCreateRoom Method in Node.js
DESCRIPTION: Example of the new getOrCreateRoom method introduced in v2.22.2 of @liveblocks/node package, which optimizes room creation by making only a single round-trip to the server.

LANGUAGE: typescript
CODE:
const liveblocks = createClient({ ... });
const room = await liveblocks.getOrCreateRoom("my-room-id");

----------------------------------------

TITLE: Using getOrCreateRoom Method in Node.js
DESCRIPTION: Example of the new getOrCreateRoom method introduced in v2.22.2 of @liveblocks/node package, which optimizes room creation by making only a single round-trip to the server.

LANGUAGE: typescript
CODE:
const liveblocks = createClient({ ... });
const room = await liveblocks.getOrCreateRoom("my-room-id");

----------------------------------------

TITLE: Verifying Liveblocks Webhook Requests with @liveblocks/node
DESCRIPTION: Implementation of webhook request verification using the WebhookHandler from @liveblocks/node. This code validates that incoming requests are genuine Liveblocks webhook events by checking the signature with your webhook secret.

LANGUAGE: typescript
CODE:
import { WebhookHandler } from "@liveblocks/node";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // Update database
  // ...

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Implementing Toolbar with Comments in Tiptap Editor
DESCRIPTION: This code demonstrates how to use the Toolbar component with a Tiptap editor, along with FloatingComposer and FloatingThreads for comment functionality. The Toolbar provides formatting controls for the text editor.

LANGUAGE: tsx
CODE:
import {
  useLiveblocksExtension,
  // +++
  Toolbar,
  // +++
  FloatingComposer,
  FloatingThreads,
} from "@liveblocks/react-tiptap";
import { useEditor, EditorContent } from "@tiptap/react";

function TextEditor() {
  const liveblocks = useLiveblocksExtension();

  const editor = useEditor({
    extensions: [
      liveblocks,
      // ...
    ],
  });

  return (
    <div>
      // +++
      <Toolbar editor={editor} />
      // +++
      <EditorContent editor={editor} />
      <FloatingComposer editor={editor} style={{ width: "350px" }} />
      <FloatingThreads editor={editor} style={{ width: "350px" }} />
    </div>
  );
}

----------------------------------------

TITLE: Basic Zustand Store Without Liveblocks Middleware
DESCRIPTION: Example of a basic Zustand store definition without Liveblocks middleware integration, showing the typical state structure for a to-do list application.

LANGUAGE: typescript
CODE:
import create from "zustand";

type State = {
  draft: string;
  isTyping: boolean;
  todos: Todo[];
  setDraft: (draft: string) => void;
  addTodo: () => void;
  deleteTodo: (index: number) => void;
};

create<State>(/* ... */);

----------------------------------------

TITLE: Installing Liveblocks Live Cursors Example with API Key Setup
DESCRIPTION: Command to create a new Liveblocks application with the advanced live cursors example. This automatically downloads the example code and helps you set up your API key from your liveblocks.io account.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-live-cursors-advanced --api-key

----------------------------------------

TITLE: Manually Emitting Sync Events
DESCRIPTION: Shows how to manually emit sync events on a LiveblocksYjsProvider instance, which will call all registered listeners with the provided arguments.

LANGUAGE: typescript
CODE:
// Call each listener and pass `true` as an argument
yProvider.emit("sync", true);

----------------------------------------

TITLE: Configuring Static UserId for Testing with Liveblocks Authentication
DESCRIPTION: This snippet demonstrates how to set up a static userId for automated testing environments to avoid counting test users against your Liveblocks MAU limits. It uses environment variables to determine when to use the test userId.

LANGUAGE: dotenv
CODE:
 TEST_USERID="machine"

LANGUAGE: typescript
CODE:
export default async function auth(req, res) {
  const room = req.body.room;
  const response = await authorize({
    room,
    secret,
    userId:
      process.env.NODE_ENV === "test" ? process.env.TEST_USERID : "user123",
  });
  return res.status(response.status).end(response.body);
}

----------------------------------------

TITLE: Formatting localtunnel URL for Webhook Endpoint
DESCRIPTION: Example showing how to replace the localhost domain with the generated localtunnel domain to create a publicly accessible webhook endpoint URL for testing purposes.

LANGUAGE: shell
CODE:
# Take your local URL
http://localhost:3000/api/liveblocks-database-sync

# Replace localhost with the generated domain, then copy it
https://my-localtunnel-url.loca.lt/api/liveblocks-database-sync

----------------------------------------

TITLE: UserEnteredEvent Schema in TypeScript
DESCRIPTION: TypeScript schema and example for the UserEnteredEvent webhook. This event is triggered when a user connects to a room and includes details like user ID, connection ID, and the total number of active users.

LANGUAGE: typescript
CODE:
// Schema
type UserEnteredEvent = {
  type: "userEntered";
  data: {
    projectId: string;
    roomId: string;
    connectionId: number;
    userId: string | null;
    userInfo: Record<string, any> | null;
    enteredAt: string;
    numActiveUsers: number;
  };
};

// Example
const userEnteredEvent = {
  type: "userEntered",
  data: {
    projectId: "my-project-id",
    roomId: "my-room-id",
    connectionId: 4,
    userId: "a-user-id",
    userInfo: null,
    enteredAt: "2021-10-06T01:45:56.558Z",
    numActiveUsers: 8,
  },
};

----------------------------------------

TITLE: Creating a Private Room with User Access in Liveblocks
DESCRIPTION: This snippet shows how to create a private room with liveblocks.createRoom() while granting access to a specific user through usersAccesses property.

LANGUAGE: typescript
CODE:
const room = await liveblocks.createRoom("a32wQXid4A9", {
  // This is a private room
  defaultAccesses: [],

  // But Olivier can enter
  usersAccesses: {
    "olivier@example.com": ["room:read"],
  },
});

----------------------------------------

TITLE: Iterating Through All Inbox Notifications with iterInboxNotifications in TypeScript
DESCRIPTION: Demonstrates how to use the iterInboxNotifications method to automatically paginate through all inbox notifications for a user using an asynchronous iterator.

LANGUAGE: typescript
CODE:
const userId = "steven@example.com";

for await (const item of liveblocks.iterInboxNotifications({ userId })) {
  console.log(item.id); // in_3dH7sF3...
  console.log(item.kind); // "thread", "textMention", ...
}

----------------------------------------

TITLE: Basic AnchoredThreads Component Usage in React TSX
DESCRIPTION: Demonstrates how to implement the AnchoredThreads component with required properties. The component wraps Thread components and requires a width to be set.

LANGUAGE: tsx
CODE:
<AnchoredThreads
  editor={editor}
  threads={threads}
  style={{ width: "350px" }}
  className="my-anchored-thread"
/>

----------------------------------------

TITLE: Using thread pagination with React
DESCRIPTION: Example of the useThreads hook with pagination support, allowing incremental fetching of thread data as users interact with the application.

LANGUAGE: TSX
CODE:
const {
  threads,
  isLoading,
  error,

  // ✨ New in Liveblocks 2.9
  fetchMore,
  isFetchingMore,
  hasFetchedAll,
  fetchMoreError,
} = useThreads({ query });

----------------------------------------

TITLE: Using LiveblocksProvider with preventUnsavedChanges in React
DESCRIPTION: Example of how to enable preventUnsavedChanges feature in React to prevent browser tabs from being closed while local changes are not yet synchronized.

LANGUAGE: JSX
CODE:
<LiveblocksProvider preventUnsavedChanges />

----------------------------------------

TITLE: Installing the TipTap Notifications Email Example with Liveblocks
DESCRIPTION: Command to set up the example project with an automatically generated Liveblocks API key. This creates a new project with all the necessary dependencies and configuration.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-tiptap-emails-resend --api-key

----------------------------------------

TITLE: Customizing BlockSelector items with additional options
DESCRIPTION: Demonstrates how to customize the BlockSelector dropdown by adding a new code block item to the default options while preserving the existing items.

LANGUAGE: tsx
CODE:
import { Toolbar } from "@liveblocks/react-tiptap";

<Toolbar editor={editor}>
  <Toolbar.BlockSelector
    items={(defaultItems) => [
      ...defaultItems,
      {
        name: "Code block",
        icon: <div>❮ ❯</div>, // Optional
        isActive: (editor) => editor.isActive("codeBlock"),
        setActive: (editor) =>
          editor.chain().focus().clearNodes().toggleCodeBlock().run(),
      },
    ]}
  />
</Toolbar>;

----------------------------------------

TITLE: Retrieving Thread by ID with Liveblocks API
DESCRIPTION: Fetches a single thread using room ID and thread ID. Returns the thread object or throws an error if the room or thread is not found.

LANGUAGE: typescript
CODE:
const thread = await liveblocks.getThread({
  roomId: "my-room-id",
  threadId: "th_d75sF3...",
});

// { type: "thread", id: "th_d75sF3...", ... }
console.log(thread);

----------------------------------------

TITLE: Destroying Awareness Instance
DESCRIPTION: Demonstrates how to clean up the Awareness instance and remove all associated resources.

LANGUAGE: typescript
CODE:
// Cleanup function
awareness.destroy();

----------------------------------------

TITLE: Using Composer.Editor with Placeholder Text
DESCRIPTION: Shows how to use the Composer.Editor component with a placeholder text that appears when the editor is empty.

LANGUAGE: tsx
CODE:
<Composer.Editor placeholder="Write a comment…" />

----------------------------------------

TITLE: Setting Up Liveblocks Collaborative Code Editor with Next.js
DESCRIPTION: Command to initialize a new collaborative code editor project using Liveblocks, Yjs, and CodeMirror with Next.js. This automatically downloads the example and helps set up the API key from your Liveblocks account.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-yjs-codemirror --api-key

----------------------------------------

TITLE: Using getOrCreateRoom Method with @liveblocks/node
DESCRIPTION: Example of using the getOrCreateRoom method which optimizes API calls by making only a single round-trip to the server.

LANGUAGE: javascript
CODE:
// Optimize `.getOrCreateRoom()` to only make a single round-trip to the server.

----------------------------------------

TITLE: Updating Room IDs using Liveblocks Node SDK
DESCRIPTION: This code demonstrates how to use the liveblocks.updateRoomId endpoint from the @liveblocks/node package to rename a room ID. The function returns the updated room object with the new ID.

LANGUAGE: typescript
CODE:
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

const room = await liveblocks.updateRoomId({
  roomId: "my-room-id",
  newRoomId: "new-room-id",
});

// { type: "room", id: "new-room-id", ... }
console.log(room);

----------------------------------------

TITLE: Customizing Thread Positioning with CSS Variables
DESCRIPTION: Shows how to modify thread positioning and appearance using CSS variables to control the gap between threads and horizontal offset of the active thread.

LANGUAGE: css
CODE:
.lb-tiptap-anchored-threads {
  /* Minimum gap between threads */
  --lb-tiptap-anchored-threads-gap: 8px;

  /* How far the active thread is offset to the left */
  --lb-tiptap-anchored-threads-active-thread-offset: 12px;
}

----------------------------------------

TITLE: Using LiveblocksProvider Instead of createClient
DESCRIPTION: Shows the transition from using createClient to wrapping the application with LiveblocksProvider component, which is a new pattern introduced in Liveblocks 2.0.

LANGUAGE: typescript
CODE:
// ❌ Before
const client = createClient(/* options */);

// ✅ After
<LiveblocksProvider /* options */>
  <App />
</LiveblocksProvider>

----------------------------------------

TITLE: Installing Liveblocks, Yjs, and Monaco dependencies
DESCRIPTION: Command to install all required npm packages for creating a collaborative Monaco editor with Liveblocks and Yjs in a Vue.js application.

LANGUAGE: bash
CODE:
npm install @liveblocks/client @liveblocks/yjs yjs monaco-editor y-monaco

----------------------------------------

TITLE: Initializing Liveblocks Configuration
DESCRIPTION: Command to create and initialize the liveblocks.config.ts file, which can be used for defining types for the application.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --init --framework react

----------------------------------------

TITLE: Using getSyncStatus Method in Liveblocks Client
DESCRIPTION: Example of the newly added getSyncStatus method in Liveblocks client for tracking synchronization status of pending local changes.

LANGUAGE: typescript
CODE:
client.getSyncStatus()

----------------------------------------

TITLE: Creating a Basic Next.js API Endpoint for Liveblocks Webhooks
DESCRIPTION: Initial setup of a POST request handler in Next.js that will receive webhook events from Liveblocks. This endpoint will extract the request body and headers for processing.

LANGUAGE: typescript
CODE:
export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Handle webhooks and database
  // ...

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Setting up Firebase Callable Function for Liveblocks Authentication
DESCRIPTION: Creates a Firebase callable function that implements security logic for Liveblocks authentication. It identifies the user and returns the appropriate authentication tokens based on the user's ID and metadata.

LANGUAGE: javascript
CODE:
const functions = require("firebase-functions");
const { Liveblocks } = require("@liveblocks/node");

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

exports.auth = functions.https.onCall(async (data, context) => {
  // Get the current user from your database
  const user = __getUserFromDB__(data);

  // Identify the user and return the result
  const { status, body } = await liveblocks.identifyUser(
    {
      userId: user.id,
      groupIds, // Optional
    },
    { userInfo: user.metadata },
  );

  return JSON.parse(body);
});

----------------------------------------

TITLE: Installing the Liveblocks tldraw Example with API Key
DESCRIPTION: Command for setting up the tldraw whiteboard example project with Liveblocks. This command downloads the example and prompts for API key configuration from a liveblocks.io account.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-tldraw-whiteboard-yjs --api-key

----------------------------------------

TITLE: Setting Local User's Awareness State
DESCRIPTION: Demonstrates how to set the current user's complete awareness state with JSON-compatible objects.

LANGUAGE: typescript
CODE:
// Set the current user's awareness
awareness.setLocalState({
  user: {
    name: "Jonathan",
  },
});

----------------------------------------

TITLE: Return Value Example for Unread Text Mention
DESCRIPTION: This snippet shows the structure of the return value from prepareTextMentionNotificationEmailAsHtml for an unread text mention. It includes room information, mention details, and formatted HTML content ready for use in emails.

LANGUAGE: js
CODE:
{
  roomInfo: {
    name: "my room name"
    url: "https://my-room-url.io"
  },
  mention: {
    id: "in_oiujhdg...",
    roomId: "my-room-id",
    createdAt: Date <Fri Dec 15 2023 14:15:22 GMT+0000 (Greenwich Mean Time)>,
    userId: "user_0"

    // The formatted content, as an HTML string
    htmlContent: { /* ... */}

    author: {
      id: "vincent@example.com",
      info: { /* Custom user info you have resolved */ }
    }
  },
}

----------------------------------------

TITLE: Generating Webhook Signature for Manual Verification
DESCRIPTION: Demonstrates how to generate a signature using HMAC SHA-256 to manually verify webhook authenticity using the webhook secret key.

LANGUAGE: typescript
CODE:
// Your endpoint's secret key
const secret = "whsec_MfKQ9r8GKYqrTwjUPD8ILPZIo2LaLaSw";

// Need to base64 decode the secret
const secretBytes = new Buffer(secret.split("_")[1], "base64");
// This is the signature you will compare against the signature header
const signature = crypto
.createHmac("sha256", secretBytes)
.update(signedContent)
.digest("base64");

----------------------------------------

TITLE: Setting up Firebase Callable Function for Liveblocks Authentication
DESCRIPTION: Creates a Firebase callable function that implements security logic for Liveblocks authentication. It identifies the user and returns the appropriate authentication tokens based on the user's ID and metadata.

LANGUAGE: javascript
CODE:
const functions = require("firebase-functions");
const { Liveblocks } = require("@liveblocks/node");

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

exports.auth = functions.https.onCall(async (data, context) => {
  // Get the current user from your database
  const user = __getUserFromDB__(data);

  // Identify the user and return the result
  const { status, body } = await liveblocks.identifyUser(
    {
      userId: user.id,
      groupIds, // Optional
    },
    { userInfo: user.metadata },
  );

  return JSON.parse(body);
});

----------------------------------------

TITLE: Defining Global Liveblocks Types in TypeScript
DESCRIPTION: Example showing how to define global Liveblocks types in a configuration file, which is the approach recommended in Liveblocks v2.0+. This allows types to be shared across all Liveblocks APIs.

LANGUAGE: typescript
CODE:
// ❌ Before
export const {
  suspense: {
    RoomProvider,
    useRoom,
    // etc
  },
} = createRoomContext<Presence, Storage>(client);

// ✅ After
declare global {
  interface Liveblocks {
    Presence: Presence;
    Storage: Storage;
  }
}

----------------------------------------

TITLE: Loading a Yjs Subdocument by GUID
DESCRIPTION: Demonstrates how to load a subdocument on a different client using its GUID. This allows for lazy-loading large Yjs documents only when needed.

LANGUAGE: ts
CODE:
import { LiveblocksYjsProvider } from "@liveblocks/yjs";
import * as Y from "yjs";

// Create main document and connect, disabling auto-loading of subdocuments
const yDoc = new Y.Doc();
const yProvider = new LiveblocksYjsProvider(room, doc, {
  autoloadSubdocs: false,
});

// From another client, load the subdoc using the GUID from `subdoc.guid` or `doc.getSubdocGuids`
yProvider.loadSubdoc("c4a755...");

// Alternatively, get a reference to a subdocument from `doc.getSubdocs()` and then load
// subdoc.load();

----------------------------------------

TITLE: Installing Liveblocks Client Package
DESCRIPTION: Command to install the Liveblocks client package using npm, which is required for implementing real-time collaboration features in a Vue.js application.

LANGUAGE: bash
CODE:
npm install @liveblocks/client

----------------------------------------

TITLE: Creating Liveblocks Client with preventUnsavedChanges Option
DESCRIPTION: Example of configuring the createClient function with preventUnsavedChanges option to prevent browser tabs from being closed while local changes are not yet synchronized.

LANGUAGE: typescript
CODE:
createClient({ preventUnsavedChanges: true })

----------------------------------------

TITLE: Handling CommentCreated Events in Liveblocks Webhooks
DESCRIPTION: Extended webhook handler that specifically processes commentCreated events. This code extracts the roomId, threadId, and commentId from the webhook event data for use in sending notifications.

LANGUAGE: typescript
CODE:
import { WebhookHandler } from "@liveblocks/node";

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When a comment has been created
  if (event.type === "commentCreated") {
    const { roomId, threadId, commentId } = event.data;

    // Send notifications
    // ...
  }

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Next.js Webhook Handler Example
DESCRIPTION: A complete example of handling Liveblocks webhooks in a Next.js route handler, including verification and event type handling for different webhook events.

LANGUAGE: javascript
CODE:
import { WebhookHandler } from "@liveblocks/node";

// Will fail if not properly initialized with a secret
// Obtained from the Webhooks section of your project dashboard
// https://liveblocks.io/dashboard
const webhookHandler = new WebhookHandler(process.env.WEBHOOK_SECRET);

export function POST(request) {
  try {
    const event = webhookHandler.verifyRequest({
      headers: req.headers,
      rawBody: JSON.stringify(req.body),
    });

    // Handle `WebhookEvent`

    if (event.type === "storageUpdated") {
      // Handle `StorageUpdatedEvent`
    } else if (event.type === "userEntered") {
      // Handle `UserEnteredEvent`
    } else if (event.type === "userLeft") {
      // Handle `UserLeftEvent`
    }
  } catch (error) {
    console.error(error);
    return new Response(error, { status: 400 });
  }
}

----------------------------------------

TITLE: Customizing BlockSelector item styles with labels
DESCRIPTION: Shows how to customize the appearance of dropdown items by adding a custom label property that overrides the default display of name and icon for specific items.

LANGUAGE: tsx
CODE:
import { Toolbar } from "@liveblocks/react-tiptap";

<Toolbar editor={editor}>
  <Toolbar.BlockSelector
    items={(defaultItems) => [
      ...defaultItems,
      {
        name: "Code block",
        // +++
        label: <div className="font-mono">Code</div>, // Optional, overwrites `icon` + `name`
        // +++
        isActive: (editor) => editor.isActive("codeBlock"),
        setActive: (editor) =>
          editor.chain().focus().clearNodes().toggleCodeBlock().run(),
      },
    ]}
  />
</Toolbar>;

----------------------------------------

TITLE: New Recommended Room Entry API in Liveblocks
DESCRIPTION: The new recommended API for entering and leaving rooms in Liveblocks. This API provides better support for connecting to the same room from different parts of an application.

LANGUAGE: typescript
CODE:
// New API we'll be recommending instead
const { room, leave } = client.enterRoom("my-room", options);
leave();

----------------------------------------

TITLE: Deploying Live Avatar Stack on Vercel
DESCRIPTION: Command to deploy the Live Avatar Stack example on Vercel. This downloads the example and guides you through the Vercel deployment process.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-live-avatars --vercel

----------------------------------------

TITLE: Converting a ProseMirror document to JSON
DESCRIPTION: Serialize a ProseMirror document to JSON format using the toJSON method, which represents the document structure in a portable format.

LANGUAGE: typescript
CODE:
const docAsJSON = await withProsemirrorDocument(
  { roomId: "my-room-id", client: liveblocks },
  async (api) => {
    // +++
    return api.toJSON();
    // +++
  }
);

----------------------------------------

TITLE: Marking Thread as Resolved with Liveblocks API
DESCRIPTION: Marks a thread as resolved by setting its resolved property to true. Requires room ID, thread ID, and the user ID of the person resolving the thread. Returns the updated thread.

LANGUAGE: typescript
CODE:
const thread = await liveblocks.markThreadAsResolved({
  roomId: "my-room-id",
  threadId: "th_d75sF3...",
  data: {
    userId: "steven@example.com",
  },
});

// { type: "thread", id: "th_d75sF3...", ... }
console.log(thread);

----------------------------------------

TITLE: Resolving User and Room Data Example in TypeScript
DESCRIPTION: This example demonstrates how to use the resolveUsers and resolveRoomInfo options to enhance the email content with custom user and room information. It shows how to fetch user data from a database and format room URLs.

LANGUAGE: tsx
CODE:
const emailData = await prepareTextMentionNotificationEmailAsHtml(
  liveblocks,
  webhookEvent,
  {
    // +++
    resolveUsers: async ({ userIds }) => {
      const usersData = await __getUsersFromDB__(userIds);

      return usersData.map((userData) => ({
        name: userData.name, // "Nimesh"
        avatar: userData.avatar.src, // "https://..."
      }));
    },
    resolveRoomInfo({ roomId }) {
      return {
        name: roomId, // "my-room-name"
        url: `https://example.com/${roomId}`,
      };
    },
    // +++
  }
);

// { mention: { ... }, ... }
console.log(emailData);

// { name: "Nimesh", avatar: "https://..." }
console.log(emailData.mention.author.info);

// { name: "my-room-name", url: "https://example.com/my-room-name" }
console.log(emailData.roomInfo);

----------------------------------------

TITLE: Retrieving text content from a ProseMirror document
DESCRIPTION: Extract the plain text content from a ProseMirror document in a Liveblocks room using the getText API method. This allows you to retrieve the document's text representation.

LANGUAGE: typescript
CODE:
const textContent = await withProsemirrorDocument(
  { roomId: "my-room-id", client: liveblocks },
  (api) => api.getText()
);

// "My content"
console.log(textContent);

----------------------------------------

TITLE: Using AiToolbar.Suggestion Components with Different Configurations
DESCRIPTION: Demonstrates various ways to configure AI suggestion components, including setting custom prompts and icons for AI-powered text operations.

LANGUAGE: tsx
CODE:
import { AiToolbar } from "@liveblocks/react-tiptap";
import { Icon } from "@liveblocks/react-ui";

// "Translate to French" is displayed in the suggestion and used as the prompt
<AiToolbar.Suggestion>Translate to French</AiToolbar.Suggestion>

// "Emojify" is displayed in the suggestion but "Add emojis to the text" is used as the prompt
<AiToolbar.Suggestion prompt="Add emojis to the text">Emojify</AiToolbar.Suggestion>

// Custom icon
<AiToolbar.Suggestion icon={<div>?</div>}>Explain</AiToolbar.Suggestion>

// Using a Liveblocks icon
<AiToolbar.Suggestion icon={<Icon.QuestionMark />}>Explain</AiToolbar.Suggestion>

----------------------------------------

TITLE: Initializing Liveblocks Client in Node.js
DESCRIPTION: Creates a new Liveblocks client instance using your secret key. This client provides access to Liveblocks REST API and is used for authentication.

LANGUAGE: typescript
CODE:
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

----------------------------------------

TITLE: Installing the Collaborative Text Editor Example with create-liveblocks-app
DESCRIPTION: Command to set up the example locally using the Liveblocks CLI tool, which downloads the example and helps configure the API key from a Liveblocks account.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-yjs-blocknote --api-key

----------------------------------------

TITLE: Initializing WebhookHandler with Secret Key
DESCRIPTION: Sets up the WebhookHandler class with your webhook secret key from the Liveblocks dashboard.

LANGUAGE: typescript
CODE:
import { WebhookHandler } from "@liveblocks/node";

// Insert your webhook secret key
const webhookHandler = new WebhookHandler("whsec_...");

----------------------------------------

TITLE: Error handling with useInboxNotifications in React
DESCRIPTION: Demonstrates how to handle errors when fetching inbox notifications, including both initial loading errors and errors when fetching additional notifications.

LANGUAGE: tsx
CODE:
import { InboxNotification } from "@liveblocks/react-ui";
import { useInboxNotifications } from "@liveblocks/react/suspense";

function Inbox() {
  const { inboxNotifications, error, fetchMore, fetchMoreError } =
    useInboxNotifications();

  // Handle error if the initial load failed.
  // The `error` field is not returned by the Suspense hook as the error is thrown to nearest ErrorBoundary
  // +++
  if (error) {
    return (
      <div>
        <p>Error loading inbox notifications: {error.message}</p>
      </div>
    );
  }
  // +++

  return (
    <div>
      {inboxNotifications.map((notification) => (
        <InboxNotification key={notification.id}>...</InboxNotification>
      ))}

      {fetchMoreError && (
        <div>
          <p>
            Error loading more inbox notifications: {fetchMoreError.message}
          </p>
          <button onClick={fetchMore}>Retry</button>
        </div>
      )}
    </div>
  );
}

----------------------------------------

TITLE: Installing Liveblocks Node Package
DESCRIPTION: Command to install the @liveblocks/node package which is required for server-side authentication.

LANGUAGE: bash
CODE:
npm install @liveblocks/node

----------------------------------------

TITLE: Customizing FloatingThreads with CSS Classes
DESCRIPTION: Shows how to apply custom styling to the FloatingThreads component using CSS classes. The component can be treated like a div element, accepting classes, listeners, and other props.

LANGUAGE: tsx
CODE:
<FloatingThreads
  editor={editor}
  threads={threads}
  className="my-floating-thread"
/>

----------------------------------------

TITLE: Typing Others' Presence in Zustand Middleware
DESCRIPTION: Example demonstrating how to use the TPresence generic argument to type the presence of other users in a Liveblocks-enhanced Zustand store, allowing for type-safe access to other users' presence data.

LANGUAGE: typescript
CODE:
type Presence = {
  isTyping: true;
}

const useStore = create(
  middleware<State, Presence>(/* ... */, {
    client,
    presenceMapping: { isTyping: true },
    storageMapping: { todos: true }
  })
);

// In your component
useStore(state => state.liveblocks.others[0].presence?.isTyping)

----------------------------------------

TITLE: Example of Liveblocks Storage Root Structure
DESCRIPTION: This snippet shows how Liveblocks creates the underlying storage structure based on the Zustand store configuration. It demonstrates how Liveblocks converts regular JavaScript values into LiveObject and LiveList instances for conflict-free collaborative editing.

LANGUAGE: typescript
CODE:
const root = new LiveObject({
  firstName: "Marie",
  lastName: "Curie",
  discoveries: new LiveList(["Polonium", "Radium"]),
});

----------------------------------------

TITLE: Using useNotificationSettings Hook in React Component
DESCRIPTION: Shows how to implement the useNotificationSettings hook to retrieve and update user notification settings within a React component. The hook returns the current settings state (loading, error, settings) and an update function.

LANGUAGE: tsx
CODE:
// A suspense version of this hook is available
import { useNotificationSettings } from "@liveblocks/react";

const [{ isLoading, error, settings }, updateSettings] =
  useNotificationSettings();
// { email: { thread: true, ... }, slack: { thread: false, ... }, ... }
console.log(settings);

const onSave = () => {
  updateSettings({
    slack: {
      textMention: true,
    },
  });
};

----------------------------------------

TITLE: Real-world resolveUsers Example for Liveblocks Comments
DESCRIPTION: Practical implementation of resolveUsers that fetches user data from a backend service based on user IDs provided by Liveblocks Comments.

LANGUAGE: tsx
CODE:
<LiveblocksProvider
  resolveUsers={async ({ userIds }) => {
    // Get users from your back end
    const users = await __fetchUsers__(userIds);

    // Return a list of users
    return users;
  }}

  // ...
/>;

----------------------------------------

TITLE: Initializing Liveblocks Configuration File
DESCRIPTION: Command to create the liveblocks.config.ts file which will be used for defining types and configuring the Liveblocks client.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --init --framework javascript

----------------------------------------

TITLE: Filtering Threads by Absence of Metadata in Liveblocks React
DESCRIPTION: Example showing how to filter threads by the absence of metadata using the useThreads hook in @liveblocks/react. This demonstrates filtering for threads that have certain metadata but are missing other attributes.

LANGUAGE: ts
CODE:
useThreads({
  query: {
    // Filter any "pinned" threads that don't have a color set
    metadata: {
      pinned: true,
      color: null, // ✨
    },
  },
});

----------------------------------------

TITLE: Setting Up localtunnel for Testing Webhooks Locally
DESCRIPTION: Command to run localtunnel, a tool that creates a temporary public URL for your localhost server, allowing you to test webhooks during development.

LANGUAGE: bash
CODE:
npx localtunnel --port 3000

----------------------------------------

TITLE: Debugging RoomInfo Type Issues in TypeScript
DESCRIPTION: A diagnostic technique to find the root cause of type incompatibilities by explicitly assigning the custom RoomInfo type to the BaseRoomInfo type and letting TypeScript show the specific error.

LANGUAGE: typescript
CODE:
import type { BaseRoomInfo } from "@liveblocks/client";

declare global {
  interface Liveblocks {
    RoomInfo: MyRoomInfo;
  }
}

// Quick debugging snippet to find root cause
const xxx: BaseRoomInfo = {} as MyRoomInfo;
//    ^?
//    The error will appear here

----------------------------------------

TITLE: Resolving User and Room Data in prepareTextMentionNotificationEmailAsReact
DESCRIPTION: Example demonstrating how to resolve user information and room data when using prepareTextMentionNotificationEmailAsReact, similar to client-side resolvers but for server-side email generation.

LANGUAGE: tsx
CODE:
const emailData = await prepareTextMentionNotificationEmailAsReact(
  liveblocks,
  webhookEvent,
  {
    // +++
    resolveUsers: async ({ userIds }) => {
      const usersData = await __getUsersFromDB__(userIds);

      return usersData.map((userData) => ({
        name: userData.name, // "Nimesh"
        avatar: userData.avatar.src, // "https://..."
      }));
    },
    resolveRoomInfo({ roomId }) {
      return {
        name: roomId, // "my-room-name"
        url: `https://example.com/${roomId}`,
      };
    },
    // +++
  }
);

// { mention: { ... }, ... }
console.log(emailData);

// { name: "Nimesh", avatar: "https://..." }
console.log(emailData.mention.author.info);

// { name: "my-room-name", url: "https://example.com/my-room-name" }
console.log(emailData.roomInfo);

----------------------------------------

TITLE: Old Method: Accessing Nested Data in Liveblocks Storage
DESCRIPTION: Previous approach to access nested data in Liveblocks storage using useObject hook, requiring null checks and manual conversion of Live structures.

LANGUAGE: tsx
CODE:
function Component() {
  const scientist = useObject("scientist");
  if (scientist == null) {
    return null;
  }

  const pets = scientist.get("pets").toArray();
  // ["🐶", "🐈"]
}

----------------------------------------

TITLE: Liveblocks authorize endpoint request body with userId
DESCRIPTION: Example JSON body for the authorize endpoint that should include userId for Monthly Active Users tracking. This is for users who directly call the authorize endpoint with a secret key instead of using the authorize function.

LANGUAGE: typescript
CODE:
{
  "userId": "user123",
  "groupIds": [
    "g1",
    "g2"
  ],
  "userInfo": {
    "name": "bob",
    "colors": [
      "blue",
      "red"
    ]
  }
}

----------------------------------------

TITLE: Configuring LiveblocksProvider with Auth Endpoint
DESCRIPTION: Front-end configuration that replaces publicApiKey with authEndpoint in the LiveblocksProvider component, pointing to the authentication endpoint created earlier.

LANGUAGE: tsx
CODE:
<LiveblocksProvider authEndpoint="/api/liveblocks-auth">

----------------------------------------

TITLE: Using useSyncStatus Hook with Smooth Option
DESCRIPTION: Code example showing how to use the useSyncStatus hook with the smooth option to create a "Saving..." spinner for displaying synchronization status in a React application.

LANGUAGE: typescript
CODE:
useSyncStatus({ smooth: true })

----------------------------------------

TITLE: Defining UserMeta Type for Liveblocks Configuration
DESCRIPTION: Creates TypeScript type definitions for user metadata in the Liveblocks configuration file. This adds type hints to the editor and ensures the metadata format matches what the Text Editor expects.

LANGUAGE: typescript
CODE:
declare global {
  interface Liveblocks {
    UserMeta: {
      id: string;

      info: {
        name: string;
        color: string;
        avatar: string;

        // Your custom metadata
        // ...
      };
    };
  }
}

----------------------------------------

TITLE: Checking for CustomNotificationEvent with Type Guard
DESCRIPTION: The isCustomNotificationEvent function is a type guard that checks if a webhook event is a CustomNotificationEvent from triggerInboxNotification, useful for identifying custom notifications when sending email notifications.

LANGUAGE: javascript
CODE:
import { isCustomNotificationEvent } from "@liveblocks/node";

const event = webhookHandler.verifyRequest({
  headers: req.headers,
  rawBody: req.body,
});

// +++
if (isCustomNotificationEvent(event)) {
  // Handle `CustomNotificationEvent`
}
// +++

----------------------------------------

TITLE: Creating Liveblocks Client with preventUnsavedChanges Option
DESCRIPTION: Example of creating a Liveblocks client with the preventUnsavedChanges option enabled, which prevents browser tabs from being closed when changes haven't been synchronized to the server.

LANGUAGE: javascript
CODE:
createClient({ preventUnsavedChanges: true })

----------------------------------------

TITLE: Importing Default Liveblocks UI Styles
DESCRIPTION: Example of importing the default CSS styles for Liveblocks React UI components. This import should be placed at the root of your app or directly in a CSS file.

LANGUAGE: tsx
CODE:
import "@liveblocks/react-ui/styles.css";

----------------------------------------

TITLE: Using useNotificationSettings Hook with @liveblocks/react
DESCRIPTION: Example of using the useNotificationSettings hook to retrieve and modify user notification settings in a React component.

LANGUAGE: tsx
CODE:
// A suspense version of this hook is available
import { useNotificationSettings } from "@liveblocks/react";

const [{ isLoading, error, settings }, updateSettings] =
  useNotificationSettings();
// { email: { thread: true, ... }, slack: { thread: false, ... }, ... }
console.log(settings);

const onSave = () => {
  updateSettings({
    slack: {
      textMention: true,
    },
  });
};

----------------------------------------

TITLE: Integrating Zustand with Liveblocks Middleware
DESCRIPTION: Shows how to enhance a Zustand store with Liveblocks middleware to enable real-time collaboration. The middleware configuration maps state properties to presence and storage for synchronization across clients.

LANGUAGE: typescript
CODE:
import create from "zustand";
import { createClient } from "@liveblocks/client";
import { middleware } from "@liveblocks/zustand";

const client = createClient({ /*...*/ });

type State = {
  draft: string;
  isTyping: boolean;
  todos: Todo[];
  setDraft: (draft: string) => void;
  addTodo: () => void;
  deleteTodo: (index: number) => void;
};

create(
  middleware<State>(/* ... */, {
    client,
    presenceMapping: { isTyping: true },
    storageMapping: { todos: true }
  })
);

----------------------------------------

TITLE: Initializing Liveblocks Configuration File
DESCRIPTION: Command to create a liveblocks.config.ts file which can be used to define types for the application.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --init --framework javascript

----------------------------------------

TITLE: Combining Comments with useThreads Hook in React
DESCRIPTION: Demonstrates how to combine the Comment primitive with the useThreads hook to render all threads and their comments in a Liveblocks application.

LANGUAGE: tsx
CODE:
import { useThreads } from "../liveblocks.config";

function MyThreads() {
  const { threads } = useThreads();

  return (
    <>
      {threads.map((thread) => (
        <MyComments key={thread.id} comments={thread.comments} />
      ))}
    </>
  );
}

----------------------------------------

TITLE: Editing an Existing Comment in Liveblocks using TypeScript
DESCRIPTION: Uses the liveblocks.editComment method to update an existing comment. Requires roomId, threadId, commentId, and data containing the updated comment body, userId, and optional editedAt timestamp.

LANGUAGE: typescript
CODE:
const editedComment = await liveblocks.editComment({
  roomId: "my-room-id",
  threadId: "th_d75sF3...",
  commentId: "cm_agH76a...",

  data: {
    body: {
      version: 1,
      content: [
        /* The comment's body text goes here, see below */
      ],
    },
    userId: "alicia@example.com",
    createdAt: new Date(), // Optional
  },
});

// { type: "comment", threadId: "th_d75sF3...", ... }
console.log(editedComment);

----------------------------------------

TITLE: Using prepareTextMentionNotificationEmailAsHtml for Text Mention Notifications in TypeScript
DESCRIPTION: This snippet demonstrates how to use the prepareTextMentionNotificationEmailAsHtml function to process a text mention notification webhook event and prepare it for email delivery. It shows basic implementation for handling the webhook event and generating HTML content.

LANGUAGE: tsx
CODE:
import { prepareTextMentionNotificationEmailAsHtml } from "@liveblocks/emails";
import { isTextMentionNotificationEvent } from "@liveblocks/node";

// Get `liveblocks` and `event` (see "Setup" section)
// ...

if (isTextMentionNotificationEvent(event)) {
  // +++
  const emailData = await prepareTextMentionNotificationEmailAsHtml(
    liveblocks,
    event
  );
  // +++

  const email = (
    <div>
      <div>
        @{emailData.mention.author.id} at {emailData.mention.createdAt}
      </div>
      <div>{emailData.mention.htmlContent}</div>
    </div>
  );
}

// Send your email
// ...

----------------------------------------

TITLE: Setting up Liveblocks Extension with Tiptap Editor in React
DESCRIPTION: This code demonstrates how to set up a collaborative Tiptap editor by adding the useLiveblocksExtension to your editor's extension array. This is the basic setup required to enable collaboration features.

LANGUAGE: tsx
CODE:
import { useLiveblocksExtension } from "@liveblocks/react-tiptap";
import { useEditor, EditorContent } from "@tiptap/react";

function TextEditor() {
  // +++
  const liveblocks = useLiveblocksExtension();
  // +++

  const editor = useEditor({
    extensions: [
      // +++
      liveblocks,
      // +++
      // ...
    ],
  });

  return (
    <div>
      <EditorContent editor={editor} />
    </div>
  );
}

----------------------------------------

TITLE: Adding Reactions to Comments in Liveblocks
DESCRIPTION: This code shows how to add emoji reactions to comments in a Liveblocks thread. It specifies the room ID, thread ID, comment ID, emoji character, user ID who created the reaction, and optional timestamp.

LANGUAGE: typescript
CODE:
// The unique ID for the room
const roomId = "my-room-id";

// Create a room
const room = await liveblocks.createRoom(roomId, {
  defaultAccesses: [],
});

// Create a thread
const thread = await liveblocks.createThread({
  /* ... */
});

// Adding a comment to the existing thread
const comment = await liveblocks.createComment({
  /* ... */
});

// +++
// Add a reaction to a comment
const reaction = await liveblocks.addCommentReaction({
  roomId,
  threadId: thread.id,
  commentId: comment.id,

  data: {
    // The reaction emoji
    emoji: "✅",

    // ID of the user that reacted
    userId: "guillaume@example.com",

    // Optional, the time the reaction was added
    createdAt: new Date(),
  },
});
// +++

----------------------------------------

TITLE: Installing the Collaborative Text Editor Project with Create Liveblocks App
DESCRIPTION: Command to set up the collaborative text editor example using the create-liveblocks-app CLI tool. This automatically downloads the example project and assists with API key configuration.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-yjs-blocknote-advanced --api-key

----------------------------------------

TITLE: Optimizing Storage Performance with Selectors and Shallow Comparison
DESCRIPTION: Shows how to improve performance when using useStorage by utilizing the shallow comparison function. This prevents unnecessary rerenders when working with derived data that creates new objects.

LANGUAGE: typescript
CODE:
import { shallow } from "@liveblocks/react";

// ✅ Rerenders only when root.scientist.pets shallowly changes
const pets = useStorage(
  (root) => root.scientist.pets.map((pet) => pet + pet),
  shallow
);

----------------------------------------

TITLE: Using ClientSideSuspense with Thread Components
DESCRIPTION: Demonstrates how to wrap thread components with ClientSideSuspense to prevent rendering until threads have loaded. This pattern is useful for optimizing the loading experience in a React application.

LANGUAGE: tsx
CODE:
<div>
  <EditorContent editor={editor} />
  <FloatingComposer editor={editor} style={{ width: "350px" }} />
  // +++
  <ClientSideSuspense fallback={null}>
    <ThreadOverlay editor={editor} />
  </ClientSideSuspense>
  // +++
</div>

----------------------------------------

TITLE: Enabling Unsaved Changes Prevention in React LiveblocksProvider
DESCRIPTION: Code snippet demonstrating how to enable the preventUnsavedChanges option in the LiveblocksProvider component to prevent browser tabs from closing while changes are being synchronized.

LANGUAGE: tsx
CODE:
<LiveblocksProvider preventUnsavedChanges />

----------------------------------------

TITLE: Using useSyncStatus Hook with Smooth Option
DESCRIPTION: Example showing how to use the useSyncStatus hook with the smooth option to display a saving indicator in the UI when changes are being synchronized.

LANGUAGE: tsx
CODE:
useSyncStatus({ smooth: true })

----------------------------------------

TITLE: Using LiveblocksProvider instead of createClient
DESCRIPTION: Example showing the transition from using createClient to using the new LiveblocksProvider component in version 2.0, which simplifies the configuration process.

LANGUAGE: typescript
CODE:
// ❌ Before
const client = createClient(/* options */);

// ✅ After
<LiveblocksProvider /* options */>
  <App />
</LiveblocksProvider>

----------------------------------------

TITLE: Setting Up Liveblocks Client in React App
DESCRIPTION: React component setup for Liveblocks client with LiveblocksProvider and RoomProvider to create the foundation for real-time collaboration.

LANGUAGE: tsx
CODE:
"use client";

import {
  LiveblocksProvider,
  RoomProvider,
} from "@liveblocks/react/suspense";
import { Editor } from "./Editor";

export default function App() {
  return (
    <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>      <RoomProvider id="my-room">
        {/* ... */}
      </RoomProvider>
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Response Format for Room Users in Liveblocks
DESCRIPTION: Example JSON response when retrieving the list of users connected to a room, showing user properties including connectionId, id, and custom info.

LANGUAGE: json
CODE:
{
  "data": [
    {
      "type": "user",
      "connectionId": 0,
      "id": "customUserId",
      "info": {}
    }
  ]
}

----------------------------------------

TITLE: Using useSyncStatus Hook for Tracking Synchronization Status
DESCRIPTION: Demonstrates how to use the useSyncStatus hook to track the synchronization status of all Liveblocks components, including Storage, text editors, threads, and notifications.

LANGUAGE: ts
CODE:
import { useSyncStatus } from "@liveblocks/react";

const syncStatus = useSyncStatus();
// "synchronizing" | "synchronized"

----------------------------------------

TITLE: Using useSyncStatus Hook for Tracking Synchronization Status
DESCRIPTION: Demonstrates how to use the useSyncStatus hook to track the synchronization status of all Liveblocks components, including Storage, text editors, threads, and notifications.

LANGUAGE: ts
CODE:
import { useSyncStatus } from "@liveblocks/react";

const syncStatus = useSyncStatus();
// "synchronizing" | "synchronized"

----------------------------------------

TITLE: Updated authorize function with mandatory userId in @liveblocks/node
DESCRIPTION: Example of the updated authorize function in @liveblocks/node which now requires userId parameter. This change supports the new pricing model based on Monthly Active Users.

LANGUAGE: typescript
CODE:
import { authorize } from "@liveblocks/node";

// Replace this key with your secret key provided at
// https://liveblocks.io/dashboard/projects/{projectId}/apikeys
const secret = "sk_prod_xxxxxxxxxxxxxxxxxxxxxxxx";

export default async function auth(req, res) {
  /**
   * Implement your own security here.
   *
   * It's your responsibility to ensure that the caller of this endpoint
   * is a valid user by validating the cookies or authentication headers
   * and that it has access to the requested room.
   */
  const room = req.body.room;
  const response = await authorize({
    room,
    secret,
    // Corresponds to the UserMeta[id] type defined in liveblocks.config.ts
    userId: "123", // Required
    groupIds: ["456"], // Optional
    userInfo: {
      // Optional, corresponds to the UserMeta[info] type defined in liveblocks.config.ts
      name: "Ada Lovelace",
      color: "red",
    },
  });
  return res.status(response.status).end(response.body);
}

----------------------------------------

TITLE: Creating HTML Element for Monaco Editor
DESCRIPTION: Creates a div element with an ID of 'editor' where the Monaco editor will be mounted in the DOM.

LANGUAGE: html
CODE:
<div id="editor"></div>

----------------------------------------

TITLE: Detaching a Schema from a Room via REST API in TypeScript
DESCRIPTION: Example showing how to detach a schema from a room using the Liveblocks REST API. This removes validation constraints and allows any modifications to the room's storage.

LANGUAGE: typescript
CODE:
fetch("https://api.liveblocks.io/v2/rooms/{roomId}/schema", {
  method: "DELETE",
});

----------------------------------------

TITLE: Using the useNotificationSettings React Hook
DESCRIPTION: Shows how to use the useNotificationSettings hook to both retrieve and update user notification settings in a React component. The hook returns the current settings along with loading and error states.

LANGUAGE: tsx
CODE:
// A suspense version of this hook is available
import { useNotificationSettings } from "@liveblocks/react";

const [{ isLoading, error, settings }, updateSettings] =
  useNotificationSettings();
// { email: { thread: true, ... }, slack: { thread: false, ... }, ... }
console.log(settings);

const onSave = () => {
  updateSettings({
    slack: {
      textMention: true,
    },
  });
};

----------------------------------------

TITLE: Implementing collaborative cursor tracking with Liveblocks in React
DESCRIPTION: This code implements a collaborative cursor feature using Liveblocks in a React component. It tracks the user's cursor position and updates presence data, while also rendering other users' cursors.

LANGUAGE: javascript
CODE:
// Room.js
import { useMyPresence, useOthers } from "./liveblocks.config";

export default function Room() {
  const [myPresence, updateMyPresence] = useMyPresence();
  const others = useOthers();

  return (
    <div
      onPointerMove={(e) => {
        updateMyPresence({
          cursor: {
            x: e.clientX,
            y: e.clientY,
          },
        });
      }}
      onPointerLeave={() => {
        updateMyPresence({
          cursor: null,
        });
      }}
      style={{ position: "relative", width: "100vw", height: "100vh" }}
    >
      {others.map(({ connectionId, presence }) => {
        if (presence.cursor === null) {
          return null;
        }

        return (
          <div
            key={connectionId}
            style={{
              position: "absolute",
              left: presence.cursor.x,
              top: presence.cursor.y,
              width: 10,
              height: 10,
              borderRadius: "50%",
              backgroundColor: "black",
              transform: "translate(-50%, -50%)",
            }}
          />
        );
      })}
    </div>
  );
}

----------------------------------------

TITLE: Creating Liveblocks Client with API Key
DESCRIPTION: JavaScript code to create a Liveblocks client instance with a public API key for connecting to Liveblocks servers.

LANGUAGE: jsx
CODE:
import { createClient } from "@liveblocks/client";

const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

----------------------------------------

TITLE: Joining and Leaving a Liveblocks Room in React Component
DESCRIPTION: React component demonstrating how to join and leave a Liveblocks room using the Zustand store hooks within a useEffect.

LANGUAGE: tsx
CODE:
"use client";

import React, { useEffect } from "react";
import useStore from "./store";
import "./App.css";

const App = () => {
  const {
    liveblocks: { enterRoom, leaveRoom },
  } = useStore();

  useEffect(() => {
    enterRoom("room-id");
    return () => {
      leaveRoom("room-id");
    };
  }, [enterRoom, leaveRoom]);

  return <Room />;
};

export default App;

----------------------------------------

TITLE: Setting Component-Specific Overrides in Liveblocks
DESCRIPTION: Demonstrates how to override strings for specific components, which takes precedence over global settings. This example shows customizing placeholder and send button text for a reply composer.

LANGUAGE: tsx
CODE:
<Composer
  overrides={{
    COMPOSER_PLACEHOLDER: "Reply to thread…",
    COMPOSER_SEND: "Reply",
  }}
/>

----------------------------------------

TITLE: Using LiveblocksProvider Instead of createClient
DESCRIPTION: Demonstration of the transition from using createClient to the new LiveblocksProvider component in Liveblocks 2.0.

LANGUAGE: typescript
CODE:
// ❌ Before
const client = createClient(/* options */);

// ✅ After
<LiveblocksProvider /* options */>
  <App />
</LiveblocksProvider>

----------------------------------------

TITLE: Using room.history.clear() Method in @liveblocks/client
DESCRIPTION: New history API method that allows explicitly clearing the room history, which resets the ability to undo beyond the current state.

LANGUAGE: typescript
CODE:
room.history.clear()

----------------------------------------

TITLE: Installing Liveblocks, Yjs, and Monaco packages
DESCRIPTION: Command to install all the necessary dependencies for creating a collaborative Monaco code editor with Liveblocks and Yjs in a Svelte application.

LANGUAGE: bash
CODE:
npm install @liveblocks/client @liveblocks/yjs yjs monaco-editor y-monaco

----------------------------------------

TITLE: Customizing Comment Parts with Custom Components in React
DESCRIPTION: Demonstrates how to customize specific parts of a Comment by passing a custom component to the components property, here customizing links to be purple and bold.

LANGUAGE: tsx
CODE:
import { CommentData } from "@liveblocks/client";
import { Comment, CommentBodyLinkProps } from "@liveblocks/react-ui/primitives";

// Render a custom comment body
function MyComment({ comment }: { comment: CommentData }) {
  return (
    <div>
      <Comment.Body
        body={comment.body}
        // +++
        components={{
          Link,
        }}
        // +++
      />
    </div>
  );
}

// +++
// Render a purple link in the comment, e.g. "https://liveblocks.io"
function Link({ href, children }: CommentBodyLinkProps) {
  return (
    <Comment.Link href={href} style={{ color: "purple", fontWeight: 700 }}>
      {children}
    </Comment.Link>
  );
}
// +++

----------------------------------------

TITLE: Checking for TextMentionNotificationEvent with Type Guard
DESCRIPTION: The isTextMentionNotificationEvent function is a type guard that checks if a webhook event is a TextMentionNotificationEvent from the Text Editor, helpful for identifying text mentions for email notifications.

LANGUAGE: javascript
CODE:
import { isTextMentionNotificationEvent } from "@liveblocks/node";

const event = webhookHandler.verifyRequest({
  headers: req.headers,
  rawBody: req.body,
});

// +++
if (isTextMentionNotificationEvent(event)) {
  // Handle `TextMentionNotificationEvent`
}
// +++

----------------------------------------

TITLE: Example Structure of Unread Mention Return Value
DESCRIPTION: This code snippet shows the structure of the data returned by prepareThreadNotificationEmailAsReact when handling an unread mention notification. It includes room ID, comment data, and formatted React content in the body property.

LANGUAGE: js
CODE:
{
  type: "unreadMention",
  roomId: "my-room-id",

  // An unread mention has just one comment
  comment: {
    id: "cm_asfs8f...",
    threadId: "th_sj30as..."
    createdAt: Date <Fri Dec 15 2023 14:15:22 GMT+0000 (Greenwich Mean Time)>,

    // The formatted comment, pass it to React `children`
    body: { /* ... */},

    // Deprecated: the formatted comment, pass it to React `children` (use `body` instead)
    reactBody: { /* ... */ },

    author: {
      id: "aurélien@example.com",
      info: { /* Custom user info you have resolved */ },
    },
  },
}

----------------------------------------

TITLE: Rendering Community Links in JSX
DESCRIPTION: This JSX code creates a grid of cards with links to Liveblocks community resources including X (Twitter), Discord, and GitHub, with descriptions for each platform.

LANGUAGE: jsx
CODE:
<ListGrid columns={3}>
  <DocsCard
    title="X"
    href="https://x.com/liveblocks"
    description="Follow us on X for the latest news and updates."
    visual={<DocsXIcon />}
    openInNewWindow
  />
  <DocsCard
    title="Discord"
    href="https://liveblocks.io/discord"
    description="Join hundreds of developers building with Liveblocks."
    visual={<DocsDiscordIcon />}
    openInNewWindow
  />
  <DocsCard
    title="GitHub"
    href="https://github.com/liveblocks/liveblocks"
    description="Follow progress and contribute to the codebase."
    visual={<DocsGithubIcon />}
    openInNewWindow
  />
</ListGrid>

----------------------------------------

TITLE: Importing Stylesheets for Liveblocks React Lexical
DESCRIPTION: This snippet shows how to import the necessary stylesheets for using Liveblocks React Lexical. It requires importing styles from both @liveblocks/react-ui and @liveblocks/react-lexical packages.

LANGUAGE: tsx
CODE:
import "@liveblocks/react-ui/styles.css";
import "@liveblocks/react-lexical/styles.css";

----------------------------------------

TITLE: Building Custom Thread Components with Comment Primitives
DESCRIPTION: Example of creating fully custom Thread components within AnchoredThreads using Comment primitives from @liveblocks/react-ui/primitives. This allows for complete control over thread rendering and behavior.

LANGUAGE: tsx
CODE:
import { Comment } from "@liveblocks/react-ui/primitives";

<AnchoredThreads
  threads={threads}
  style={{ width: "350px" }}
  className="my-anchored-thread"
  components={{
    Thread: (props) => (
      // +++
      <div>
        {props.thread.comments.map((comment) => (
          <Comment.Body
            key={comment.id}
            body={comment.body}
            components={/* ... */}
          />
        ))}
      </div>
      // +++
    ),
  }}
/>;

----------------------------------------

TITLE: Running the Development Server
DESCRIPTION: Command to start the Next.js development server locally, making the application available at http://localhost:3000.

LANGUAGE: bash
CODE:
npm run dev

----------------------------------------

TITLE: Accessing isReadOnly flag on user instances
DESCRIPTION: Code showing how to access the new isReadOnly flag on user instances returned by getSelf() and getOthers(), which indicates if storage is read-only or if a user has limited permissions.

LANGUAGE: ts
CODE:
const me = room.getSelf();

me.isReadOnly; // boolean

const others = room.getOthers();
for (const other of others) {
  other.isReadOnly; // boolean
}

----------------------------------------

TITLE: Handling Null Notification Settings in TypeScript
DESCRIPTION: Shows how to handle the case where no notification kinds are enabled for a particular channel in a user's notification settings.

LANGUAGE: typescript
CODE:
const settings = await liveblocks.getNotificationSettings({
  userId: "guillaume@liveblocks.io",
});

// { email: null, ... }
console.log(settings);

----------------------------------------

TITLE: Initializing Liveblocks Config File
DESCRIPTION: Command to initialize the liveblocks.config.ts file which can be used to define types for the application.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --init --framework react

----------------------------------------

TITLE: Attaching Updated Schema via REST API in TypeScript
DESCRIPTION: Example of the API call to attach an updated schema version to a room. This enables validation against the new schema definition with the required checked field.

LANGUAGE: typescript
CODE:
POST https://api.liveblocks.io/v2/rooms/nextjs-todo-list-v2/schema
{
  "schema": "todo-list@1"
}

----------------------------------------

TITLE: Extending FloatingToolbar with Custom Buttons in React-TipTap
DESCRIPTION: Demonstrates how to customize the FloatingToolbar component by adding content before and after the default buttons using the before and after props. Custom elements can be added alongside built-in components like Toolbar.Button.

LANGUAGE: tsx
CODE:
import { Toolbar } from "@liveblocks/react-tiptap";
import { Icon } from "@liveblocks/react-ui";

<FloatingToolbar
  editor={editor}
  // +++
  before={<>I'm at the start</>}
  after={
    <Toolbar.Button
      name="Help"
      icon={<Icon.QuestionMark />}
      shortcut="CMD-H"
      onClick={() => console.log("help")}
    />
  }
  // +++
/>;

----------------------------------------

TITLE: Implementing Zustand Store Without Liveblocks Middleware in TypeScript
DESCRIPTION: Example of a Zustand store for a todo list application without using Liveblocks middleware. This shows the base implementation before integration with real-time collaboration features.

LANGUAGE: typescript
CODE:
import create from "zustand";

type State = {
  draft: string;
  isTyping: boolean;
  todos: Todo[];
  setDraft: (draft: string) => void;
  addTodo: () => void;
  deleteTodo: (index: number) => void;
};

create<State>(/* ... */);

----------------------------------------

TITLE: Using Composer.Suggestions Component in React
DESCRIPTION: Contains suggestions within Composer.Editor, serving as a container for suggestion-related UI elements.

LANGUAGE: tsx
CODE:
<Composer.Suggestions>{/* ... */}<Composer.Suggestions>

----------------------------------------

TITLE: Subscribing to Storage Status Changes with TypeScript
DESCRIPTION: Example of how to subscribe to storage status changes in a Liveblocks room. The callback function handles different possible status values: not-loaded, loading, synchronizing, and synchronized.

LANGUAGE: typescript
CODE:
room.subscribe("storage-status", (status) => {
  switch (status) {
    case "not-loaded":
      break;
    case "loading":
      break;
    case "synchronizing":
      break;
    case "synchronized":
      break;
    default:
      break;
  }
});

----------------------------------------

TITLE: Installing Liveblocks Zustand Integration
DESCRIPTION: Command for installing the required Liveblocks packages for Zustand integration. Installs both the client package and the Zustand middleware package.

LANGUAGE: bash
CODE:
npm install @liveblocks/client @liveblocks/zustand

----------------------------------------

TITLE: Implementing resolveUsers Function for LiveblocksProvider
DESCRIPTION: Shows the implementation of the resolveUsers function that takes user IDs and returns user information like name, color, and avatar. This function enables displaying user cursors in the Text Editor with proper identification.

LANGUAGE: tsx
CODE:
<LiveblocksProvider
  resolveUsers={async ({ userIds }) => {
    // ["marc@example.com", ...]
    console.log(userIds);

    // Return a list of users
    return [
      {
        name: "Marc",
        color: "#00ff00",
        avatar: "https://example.com/marc.png",

        // Your custom metadata
        // ...
      },
      // ...
    ];
  }}

  // ...
/>;

----------------------------------------

TITLE: Configuring Global Liveblocks Types in TypeScript (v2.0)
DESCRIPTION: Shows how to define global Liveblocks types in TypeScript. This method replaces the previous approach of passing types directly to createRoomContext, improving developer experience by allowing types to be defined once and shared across all Liveblocks APIs.

LANGUAGE: typescript
CODE:
// ❌ Before
export const {
  suspense: {
    RoomProvider,
    useRoom,
    // etc
  },
} = createRoomContext<Presence, Storage>(client);

// ✅ After
declare global {
  interface Liveblocks {
    Presence: Presence;
    Storage: Storage;
  }
}

----------------------------------------

TITLE: Running Codemod for RoomInfo to RoomData Type Rename
DESCRIPTION: Command to automatically update references to the renamed RoomInfo type in @liveblocks/node.

LANGUAGE: bash
CODE:
npx @liveblocks/codemod@latest room-info-to-room-data

----------------------------------------

TITLE: Using Query Language Example in JavaScript
DESCRIPTION: Example of a query string to filter rooms by ID prefix and metadata type. This query can be used with the Liveblocks REST API.

LANGUAGE: javascript
CODE:
roomId^'liveblocks:' AND metadata['roomType']:'whiteboard'

----------------------------------------

TITLE: Accessing User Notification Settings in Liveblocks Client
DESCRIPTION: Demonstrates how to use the createClient method to get and update user notification settings, showing the structure of notification settings object returned.

LANGUAGE: typescript
CODE:
import { createClient } from '@liveblocks/client'
const client = createClient({ ... })

const settings = await client.getNotificationSettings();
// { email: { thread: true, ... }, slack: { thread: false, ... }, ... }
console.log(settings);

const updatedSettings = await client.updateNotificationSettings({
  email: {
    thread: false,
  }
});

----------------------------------------

TITLE: Adding unstable_batchedUpdates to RoomProvider in React 17
DESCRIPTION: Code showing how to import and pass the unstable_batchedUpdates function to RoomProvider when using React 17 to prevent stale props/zombie child issues.

LANGUAGE: tsx
CODE:
// ⚠️ Only if you're using React 17 or lower
import { unstable_batchedUpdates } from "react-dom"; // 👈
<RoomProvider
  id="my-room"
  initialPresence={...}
  initialStorage={...}
  unstable_batchedUpdates={unstable_batchedUpdates}
>
  <App />
</RoomProvider>

----------------------------------------

TITLE: Installing Liveblocks, Yjs, and CodeMirror Dependencies
DESCRIPTION: Installs the necessary packages for implementing a collaborative code editor with Liveblocks, Yjs, and CodeMirror. All Liveblocks packages should use the same version for compatibility.

LANGUAGE: bash
CODE:
npm install @liveblocks/client @liveblocks/yjs yjs codemirror @codemirror/lang-javascript y-codemirror.next

----------------------------------------

TITLE: Creating liveblocks.config.ts Configuration File
DESCRIPTION: Template for the recommended liveblocks.config.ts file that centralizes client creation, type definitions, and hook exports for your Liveblocks application.

LANGUAGE: typescript
CODE:
import { createClient } from "@liveblocks/client";
import { createRoomContext } from "@liveblocks/react";

const client = createClient({
  /* client options */
});

// Presence represents the properties that will exist on every User in the Room
// and that will automatically be kept in sync. Accessible through the
// `user.presence` property. Must be JSON-serializable.
type Presence = {
  // cursor: { x: number, y: number } | null,
  // ...
};

// Optionally, Storage represents the shared document that persists in the
// Room, even after all Users leave. Fields under Storage typically are
// LiveList, LiveMap, LiveObject instances, for which updates are
// automatically persisted and synced to all connected clients.
type Storage = {
  // author: LiveObject<{ firstName: string, lastName: string }>,
  // ...
};

// Optionally, UserMeta represents static/readonly metadata on each User, as
// provided by your own custom auth backend (if used). Useful for data that
// will not change during a session, like a User's name or avatar.
// type UserMeta = {
//   id?: string,  // Accessible through `user.id`
//   info?: Json,  // Accessible through `user.info`
// };

// Optionally, the type of custom events broadcasted and listened for in this
// room. Must be JSON-serializable.
// type RoomEvent = {};

export const {
  RoomProvider,
  useMyPresence,
  useObject,
  /* ...all the other hooks you're using... */
} = createRoomContext<Presence, Storage /* UserMeta, RoomEvent */>(client);

----------------------------------------

TITLE: Configuring Liveblocks Types in TypeScript - Before and After v2.0
DESCRIPTION: Example demonstrating the improved developer experience in v2.0, where types can be specified globally rather than passing them to createRoomContext.

LANGUAGE: typescript
CODE:
// ❌ Before
export const {
  suspense: {
    RoomProvider,
    useRoom,
    // etc
  },
} = createRoomContext<Presence, Storage>(client);

// ✅ After
declare global {
  interface Liveblocks {
    Presence: Presence;
    Storage: Storage;
  }
}

----------------------------------------

TITLE: Accessing and Updating User Notification Settings with Liveblocks Client in TypeScript
DESCRIPTION: Example showing how to use the createClient method to get and update user notification settings. This code demonstrates fetching the current notification settings and updating email notifications for threads.

LANGUAGE: typescript
CODE:
import { createClient } from '@liveblocks/client'
const client = createClient({ ... })

const settings = await client.getNotificationSettings();
// { email: { thread: true, ... }, slack: { thread: false, ... }, ... }
console.log(settings);

const updatedSettings = await client.updateNotificationSettings({
  email: {
    thread: false,
  }
});

----------------------------------------

TITLE: Deploying Liveblocks Live Cursors Example to Vercel
DESCRIPTION: Command to download the Solid.js live cursors example and initiate the Vercel deployment process. This allows for both local development and deployment to Vercel's hosting platform.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example solidjs-live-cursors --vercel

----------------------------------------

TITLE: Setting up Liveblocks Client in Svelte
DESCRIPTION: Code to create a Liveblocks client instance with the public API key, which establishes the connection to Liveblocks backend services.

LANGUAGE: ts
CODE:
const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

----------------------------------------

TITLE: Using Composer.MarkToggle Component in React
DESCRIPTION: A toggle button which applies specific text formatting (like bold or italic), requiring the mark prop to specify the formatting type.

LANGUAGE: tsx
CODE:
<Composer.MarkToggle mark="bold">Bold</Composer.MarkToggle>

----------------------------------------

TITLE: Using the useUpdateNotificationSettings React Hook
DESCRIPTION: Demonstrates the useUpdateNotificationSettings hook for dedicated notification update functionality. This is useful for simpler cases like unsubscribe buttons where you only need to update settings without reading them.

LANGUAGE: tsx
CODE:
// A suspense version of this hook is available
import { useUpdateNotificationSettings } from "@liveblocks/react";

const updateSettings = useUpdateNotificationSettings();

const onUnsubscribe = () => {
  updateSettings({
    slack: {
      thread: false,
    },
  });
};

----------------------------------------

TITLE: Updating Resolver Type Imports - Before and After
DESCRIPTION: Changes to import statements for resolver types, which have moved from @liveblocks/react to @liveblocks/client in version 1.10.

LANGUAGE: tsx
CODE:
// ❌ Before - Liveblocks 1.9
import {
  ResolveUsersArgs,
  ResolveMentionSuggestionsArgs,
} from "@liveblocks/react";

// ✅ After - Liveblocks 1.10
import {
  ResolveUsersArgs,
  ResolveMentionSuggestionsArgs,
} from "@liveblocks/client";

----------------------------------------

TITLE: Creating Comment Threads with useCreateThread
DESCRIPTION: Example of using the useCreateThread hook with a custom Composer component to create new threads. The hook is called when the form is submitted with the comment body and optional metadata.

LANGUAGE: tsx
CODE:
import {
  Composer,
  ComposerSubmitComment,
} from "@liveblocks/react-ui/primitives";
import { useCreateThread } from "../liveblocks.config.ts";
import { FormEvent } from "react";

// A custom composer that creates a thread on submit
function MyComposer() {
  const createThread = useCreateThread();

  function handleComposerSubmit(
    { body }: ComposerSubmitComment,
    event: FormEvent<HTMLFormElement>
  ) {
    event.preventdefault();

    const thread = createThread({
      body,
      metadata: {},
    });
  }

  return (
    <Composer.Form onComposerSubmit={handleComposerSubmit}>
      <Composer.Editor />
      <Composer.Submit>Create thread</Composer.Submit>
    </Composer.Form>
  );
}

----------------------------------------

TITLE: Retrieving text content with custom options
DESCRIPTION: Get the text content from a ProseMirror document with customizable options like block separators and text serializers through the getText method.

LANGUAGE: typescript
CODE:
const textContent = await withProsemirrorDocument(
  { roomId: "my-room-id", client: liveblocks },
  async (api) => {
    // +++
    return api.getText({
      // Options
      // ...
    });
    // +++
  }
);

----------------------------------------

TITLE: Creating multiple BlockNote editors with Liveblocks
DESCRIPTION: Example showing how to create multiple collaborative editors on one page by specifying a unique field property for each editor instance.

LANGUAGE: tsx
CODE:
import { useCreateBlockNoteWithLiveblocks } from "@liveblocks/react-blocknote";

function TextEditor() {
  const editor = useCreateBlockNoteWithLiveblocks(
    {},
    {
      // +++
      field: "editor-one",
      // +++
    }
  );

  // ...
}

----------------------------------------

TITLE: Creating a Mixed Custom and Default FloatingToolbar in React-Lexical
DESCRIPTION: Shows how to create a FloatingToolbar that combines both default section components and custom buttons. Uses Lexical formatting commands to implement custom button functionality.

LANGUAGE: tsx
CODE:
import { FORMAT_TEXT_COMMAND } from "lexical";
import { useLexicalComposerContext } from "@lexical/react/LexicalComposerContext";
import { isTextFormatActive, FloatingToolbar } from "@liveblocks/react-lexical";
import { Icon } from "@liveblocks/react-ui";

function CustomToolbar() {
  const [editor] = useLexicalComposerContext();

  return (
    <FloatingToolbar>
      // +++
      <Toolbar.SectionHistory />
      <Toolbar.Separator />
      <Toolbar.Button
        name="Help"
        icon={<Icon.QuestionMark />}
        shortcut="CMD-H"
        onClick={() => console.log("help")}
      />
      <Toolbar.Toggle
        name="Bold"
        icon={<strong>B️</strong>}
        active={isTextFormatActive(editor, "bold")}
        onClick={() => editor.dispatchCommand(FORMAT_TEXT_COMMAND, "bold")}
      />
      // +++
    </FloatingToolbar>
  );
}

----------------------------------------

TITLE: Deploying the Project on Vercel
DESCRIPTION: Command to set up the collaborative text editor and deploy it to Vercel in one step using the create-liveblocks-app CLI tool with the vercel flag.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-yjs-blocknote-advanced --vercel

----------------------------------------

TITLE: Disconnecting from Liveblocks Server (TypeScript)
DESCRIPTION: Shows how to disconnect a local room instance from the Liveblocks server. The room instance remains functional for local operations but changes won't be persisted or synchronized until reconnected.

LANGUAGE: typescript
CODE:
room.disconnect();

----------------------------------------

TITLE: Enabling Experimental Offline Support in Liveblocks TipTap Editor
DESCRIPTION: This snippet shows how to enable experimental offline support by setting the offlineSupport_experimental option to true. This allows documents to be saved locally and loaded instantly on subsequent visits.

LANGUAGE: tsx
CODE:
import { useLiveblocksExtension } from "@liveblocks/react-tiptap";

function TextEditor() {
  const liveblocks = useLiveblocksExtension({
    offlineSupport_experimental: true,
  });

  // ...
}

----------------------------------------

TITLE: Subscribing to Storage Status Changes in TypeScript
DESCRIPTION: This code demonstrates how to subscribe to storage status changes using the room.subscribe method. It handles all possible status values: not-loaded, loading, synchronizing, and synchronized.

LANGUAGE: typescript
CODE:
room.subscribe("storage-status", (status) => {
  switch (status) {
    case "not-loaded":
      break;
    case "loading":
      break;
    case "synchronizing":
      break;
    case "synchronized":
      break;
    default:
      break;
  }
});

----------------------------------------

TITLE: Using userId and userInfo with useSelf
DESCRIPTION: Example of accessing both the user ID and user information in a React component using the useSelf hook. This shows how to log these values to the console.

LANGUAGE: typescript
CODE:
const self = useSelf();
console.log(self.id);
console.log(self.info);

----------------------------------------

TITLE: Using LiveList.set Method
DESCRIPTION: Example of using the LiveList.set method to update a single element at a specified index. This allows for efficient targeted updates to a LiveList without replacing the entire list.

LANGUAGE: typescript
CODE:
const list = new LiveList(["🦁", "🦊", "🐵"]);
list.set(0, "🐺");
list.toArray(); // equals ["🐺", "🦊", "🐵"]

----------------------------------------

TITLE: Using Suspense-Enabled Hooks Without Null Checks
DESCRIPTION: Example of using Suspense-enabled Liveblocks hooks to access storage data without needing null checks, as the component will only render after data is available.

LANGUAGE: tsx
CODE:
function Component() {
  const camera = useStorage((root) => root.camera);
  const items = useStorage((root) => root.items);
  // No more null checking! :)
}

----------------------------------------

TITLE: Filtering Rooms using Query Language Examples in JavaScript
DESCRIPTION: Examples of Liveblocks query language syntax for filtering rooms by room ID prefixes, metadata values, and combining multiple filters using AND logic. These queries can be used with the Get Rooms REST API or liveblocks.getRooms method.

LANGUAGE: javascript
CODE:
// Rooms with IDs that begin with "liveblocks:"
roomId^'liveblocks:'

// Rooms with { roomType: 'whiteboard' } string metadata
metadata['roomType']:'whiteboard'

// Combine queries with AND
roomId^'liveblocks:' AND metadata['roomType']:'whiteboard'

// Use multiple metadata filters at once
metadata['roomType']:'whiteboard' AND metadata['creator']:'florent'

----------------------------------------

TITLE: Filtering Threads by Absence of Metadata in Liveblocks React
DESCRIPTION: Shows how to filter threads by the absence of metadata using the useThreads hook in @liveblocks/react. The example filters for threads that are pinned but don't have a color attribute set.

LANGUAGE: ts
CODE:
useThreads({
  query: {
    // Filter any "pinned" threads that don't have a color set
    metadata: {
      pinned: true,
      color: null, // ✨
    },
  },
});

----------------------------------------

TITLE: Using useSyncStatus Hook with React for Tracking Synchronization Status
DESCRIPTION: Example of using the useSyncStatus hook to display a loading indicator while Liveblocks is synchronizing local changes to the server. The smooth option provides a debounced status to avoid UI flicker.

LANGUAGE: tsx
CODE:
const { threads, isLoading, error, fetchMore, isFetchingMore, hasFetchedAll, fetchMoreError } = useThreads({ query });

----------------------------------------

TITLE: Comments Overrides Configuration - After
DESCRIPTION: Updated implementation of Comments overrides in Liveblocks 1.10, using the new constant names and parameter orders.

LANGUAGE: tsx
CODE:
// ✅ After - Liveblocks 1.10
<CommentsConfig
  overrides={{
    USER_SELF: "you",
    USER_UNKNOWN: "Anon",
    LIST_REMAINING_USERS: (others) => `${others} people`,
    COMMENT_REACTION_LIST: (list, emoji, count) => (
      <>
        {list} reacted with {emoji}
      </>
    ),
  }}
/>

----------------------------------------

TITLE: Filtering Rooms using Query Language Examples in JavaScript
DESCRIPTION: Examples of Liveblocks query language syntax for filtering rooms by room ID prefixes, metadata values, and combining multiple filters using AND logic. These queries can be used with the Get Rooms REST API or liveblocks.getRooms method.

LANGUAGE: javascript
CODE:
// Rooms with IDs that begin with "liveblocks:"
roomId^'liveblocks:'

// Rooms with { roomType: 'whiteboard' } string metadata
metadata['roomType']:'whiteboard'

// Combine queries with AND
roomId^'liveblocks:' AND metadata['roomType']:'whiteboard'

// Use multiple metadata filters at once
metadata['roomType']:'whiteboard' AND metadata['creator']:'florent'

----------------------------------------

TITLE: Updating Composer Component with Attachments Support
DESCRIPTION: Example showing how to modify the Composer component's onComposerSubmit handler to properly handle attachments in Liveblocks 2.8.

LANGUAGE: tsx
CODE:
const createThread = useCreateThread();

// ❌ Before - Liveblocks 2.7
<Composer
  onComposerSubmit={({ body }, event) => {
    event.preventDefault();
    createThread({ body, metadata: {} });
  }}
/>

// ✅ After - Liveblocks 2.8
<Composer
// +++
  onComposerSubmit={({ body, attachments }, event) => {
    // +++
    event.preventDefault();
    // +++
    createThread({ body, attachments, metadata: {} });
    // +++
  }}
/>

----------------------------------------

TITLE: Deploying Liveblocks To-do List Example to Vercel
DESCRIPTION: Command to set up the Liveblocks collaborative to-do list example project and deploy it to Vercel hosting platform.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example redux-todo-list --vercel

----------------------------------------

TITLE: Installing @liveblocks/react v0.19 with npm
DESCRIPTION: Command to install version 0.19 of @liveblocks/client and @liveblocks/react packages using npm.

LANGUAGE: bash
CODE:
npm install @liveblocks/client@0.19 @liveblocks/react@0.19

----------------------------------------

TITLE: Installing Liveblocks, Yjs, and Quill dependencies
DESCRIPTION: Command to install all required npm packages for a Liveblocks project with Quill and Yjs integration. All Liveblocks packages should use the same version.

LANGUAGE: bash
CODE:
npm install @liveblocks/client @liveblocks/yjs yjs quill quill-cursors y-quill

----------------------------------------

TITLE: Comparing Old and New Client Room APIs in TypeScript
DESCRIPTION: Demonstrates the deprecated room entry/exit API alongside the newly recommended approach. The new API returns both the room instance and a leave function that can be called to exit the room.

LANGUAGE: typescript
CODE:
// Old APIs we'll no longer be recommending (but that will remain working)
const room = client.enter("my-room", options);
client.getRoom("my-room");
client.leave("my-room");

LANGUAGE: typescript
CODE:
// New API we'll be recommending instead
const { room, leave } = client.enterRoom("my-room", options);
leave();

----------------------------------------

TITLE: Defining process.env manually for Liveblocks client in browser environments
DESCRIPTION: Solution for 'process is not defined' error when loading @liveblocks/client directly via script tags without a bundler. This code defines the necessary process.env.NODE_ENV variable to make the library work in a browser environment.

LANGUAGE: typescript
CODE:
globalThis.process = { env: { NODE_ENV: "production" } };

----------------------------------------

TITLE: Joining a Liveblocks Room in Svelte
DESCRIPTION: Code snippet to enter a Liveblocks room, which is a virtual space where users collaborate. Returns the room object and a leave function for disconnecting.

LANGUAGE: js
CODE:
const { room, leave } = client.enterRoom("my-room");

----------------------------------------

TITLE: Creating Client with Unsaved Changes Prevention
DESCRIPTION: Example of creating a Liveblocks client with the preventUnsavedChanges option enabled, which prevents browser tabs from being closed while local changes are not yet synchronized.

LANGUAGE: JavaScript
CODE:
createClient({ preventUnsavedChanges: true })

----------------------------------------

TITLE: Customizing All Default Toolbar.BlockSelector Items
DESCRIPTION: Demonstrates how to customize all default items in the BlockSelector dropdown to visually represent their effect on the document. Each item is styled to match its formatting purpose.

LANGUAGE: tsx
CODE:
import { Toolbar } from "@liveblocks/react-lexical";

<Toolbar.BlockSelector
  items={(defaultItems) =>
    defaultItems.map((item) => {
      let label;

      if (item.name === "Text") {
        label = <span>Regular text</span>;
      }

      if (item.name === "Heading 1") {
        label = (
          <span style={{ fontSize: 18, fontWeight: "bold" }}>Heading 1</span>
        );
      }

      if (item.name === "Heading 2") {
        label = (
          <span style={{ fontSize: 16, fontWeight: "bold" }}>Heading 2</span>
        );
      }

      if (item.name === "Heading 3") {
        label = (
          <span style={{ fontSize: 15, fontWeight: "bold" }}>Heading 3</span>
        );
      }

      if (item.name === "Blockquote") {
        label = (
          <span style={{ borderLeft: "3px solid gray", paddingLeft: 8 }}>
            Blockquote
          </span>
        );
      }

      return {
        ...item,
        label,
        icon: null, // Hide all icons
      };
    })
  }
/>;

----------------------------------------

TITLE: Defining Global Liveblocks Types in TypeScript Configuration
DESCRIPTION: Example demonstrating the improved type definition approach in Liveblocks 2.0, where types are defined globally and shared across all Liveblocks APIs, including your Node backend.

LANGUAGE: typescript
CODE:
// ❌ Before
export const {
  suspense: {
    RoomProvider,
    useRoom,
    // etc
  },
} = createRoomContext<Presence, Storage>(client);

// ✅ After
declare global {
  interface Liveblocks {
    Presence: Presence;
    Storage: Storage;
  }
}

----------------------------------------

TITLE: Using LiveblocksProvider Instead of createClient (v2.0)
DESCRIPTION: Shows how to replace the createClient method with the new LiveblocksProvider component. This approach allows for better context management and simplifies the integration of Liveblocks within React applications.

LANGUAGE: typescript
CODE:
// ❌ Before
const client = createClient(/* options */);

// ✅ After
<LiveblocksProvider /* options */>
  <App />
</LiveblocksProvider>

----------------------------------------

TITLE: Installing Latest Liveblocks Packages with npm
DESCRIPTION: Command to upgrade all Liveblocks packages to their latest versions using npm. This is the first step in upgrading to Liveblocks 1.10.

LANGUAGE: bash
CODE:
npm install @liveblocks/client@latest @liveblocks/react@latest @liveblocks/react-ui@latest @liveblocks/node@latest

----------------------------------------

TITLE: Using Composer Component to Create Threads with Metadata
DESCRIPTION: Example of using the Composer component to create a new thread with custom metadata properties including priority, pinned status, and timestamp.

LANGUAGE: tsx
CODE:
import { Composer } from "@liveblocks/react-ui";

// Creates a new thread with custom metadata
function Component() {
  return (
    <Composer
      // +++
      metadata={{
        // Custom metadata here
        priority: "URGENT",
        pinned: false,
        timestamp: 1703073188013,
      }}
      // +++
    />
  );
}

----------------------------------------

TITLE: Unread Mention Email Response Structure Example
DESCRIPTION: This code snippet shows the expected response format for unread mention notifications from the prepareThreadNotificationEmailAsReact function. It returns thread information and the comment containing the mention.

LANGUAGE: js
CODE:
{
  type: "unreadMention",
  roomId: "my-room-id",
  comment: {/* Comment data */},
}

----------------------------------------

TITLE: Customizing Thread Positions with CSS Variables
DESCRIPTION: Using CSS variables to modify the spacing and behavior of threads within AnchoredThreads, controlling the gap between threads and the offset applied to active threads for better visual hierarchy.

LANGUAGE: css
CODE:
.lb-lexical-anchored-threads {
  /* Minimum gap between threads */
  --lb-lexical-anchored-threads-gap: 8px;

  /* How far the active thread is offset to the left */
  --lb-lexical-anchored-threads-active-thread-offset: 12px;
}

----------------------------------------

TITLE: Running localtunnel for Webhook Testing
DESCRIPTION: Command to run localtunnel to expose a local server (port 3000) to the internet. This creates a temporary public URL that can be used for webhook testing.

LANGUAGE: bash
CODE:
npx localtunnel --port 3000

----------------------------------------

TITLE: Managing Toolbar.Toggle State with React useState
DESCRIPTION: Demonstrates how to use React's useState hook to manage the active state of a Toolbar.Toggle component. This approach allows the toggle state to be controlled independently of the editor.

LANGUAGE: tsx
CODE:
import { Toolbar } from "@liveblocks/react-lexical";
import { useState } from "react";

function CustomToggle() {
  const [active, setActive] = useState(false);

  return (
    <Toolbar.Toggle
      name="Toggle options"
      active={active}
      onClick={() => setActive(!active)}
    />
  );
}

----------------------------------------

TITLE: Marking Single Notification as Read with Client.markInboxNotificationAsRead in TypeScript
DESCRIPTION: Shows how to mark a specific inbox notification as read for the current user. Requires the ID of the notification to be marked as read.

LANGUAGE: typescript
CODE:
await client.markAllInboxNotificationsAsRead("in_xxx");

----------------------------------------

TITLE: Deploying the Collaborative Text Editor on Vercel
DESCRIPTION: Command to deploy the collaborative text editor example on Vercel. This downloads the example and initiates the Vercel deployment process.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-yjs-quill --vercel

----------------------------------------

TITLE: Deploying the Multiplayer 3D Builder on Vercel
DESCRIPTION: Command to download the example and deploy it to Vercel. This uses the create-liveblocks-app CLI with the vercel flag to initiate the deployment process.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-3d-builder --vercel

----------------------------------------

TITLE: Previous Type Annotation Pattern in 0.16
DESCRIPTION: How type annotations were previously implemented in version 0.16, requiring generic parameters in multiple places.

LANGUAGE: tsx
CODE:
import { useMyPresence, RoomProvider } from "@liveblocks/react";

type Presence = {
  cursor: { x: number; y: number };
};

function Root() {
  return (
    <RoomProvider
      id="my-room-id"
      initialPresence={{ cursor: { x: 100, y: 100 } }}
    >
      <Component />
    </RoomProvider>
  );
}

function Component() {
  const [myPresence] = useMyPresence<Presence>();

  const cursor = myPresence.cursor; // Valid

  /* ... */
}

----------------------------------------

TITLE: Solving TypeScript Lson constraint error by extending JsonObject
DESCRIPTION: Solution 2 for the TypeScript error 'Type does not satisfy the constraint Lson'. This approach explicitly extends the interface from JsonObject to ensure compatibility with Liveblocks data structures.

LANGUAGE: typescript
CODE:
import { JsonObject } from "@liveblocks/client";

interface Person extends JsonObject {
  name: string;
  age: number;
}

const people = new LiveList<Person>();
//                          ^^^^^^ ✅ All good now

----------------------------------------

TITLE: Installing Liveblocks Package Dependencies
DESCRIPTION: Command to install the required Liveblocks packages for React applications. Both packages should use the same version for compatibility.

LANGUAGE: bash
CODE:
npm install @liveblocks/client @liveblocks/react

----------------------------------------

TITLE: Implementing FloatingComposer and FloatingThreads for comments
DESCRIPTION: Complete implementation showing how to add both FloatingComposer for comment creation and FloatingThreads for displaying comments in a BlockNote editor.

LANGUAGE: tsx
CODE:
import {
  // +++
  FloatingComposer,
  // +++
  FloatingThreads,
  useCreateBlockNoteWithLiveblocks,
} from "@liveblocks/react-blocknote";
import { BlockNoteView } from "@blocknote/mantine";

function TextEditor() {
  const editor = useCreateBlockNoteWithLiveblocks({});

  return (
    <div>
      <BlockNoteView editor={editor} />
      // +++
      <FloatingComposer editor={editor} style={{ width: "350px" }} />
      // +++
      <FloatingThreads editor={editor} style={{ width: "350px" }} />
    </div>
  );
}

----------------------------------------

TITLE: Basic Zustand Store Definition without Liveblocks Middleware
DESCRIPTION: Example of a typical Zustand store definition without Liveblocks integration, showing the standard pattern for creating a store with TypeScript.

LANGUAGE: typescript
CODE:
import create from "zustand";

type State = {
  draft: string;
  isTyping: boolean;
  todos: Todo[];
  setDraft: (draft: string) => void;
  addTodo: () => void;
  deleteTodo: (index: number) => void;
};

create<State>(/* ... */);

----------------------------------------

TITLE: Converting CommentBody to String Format in TypeScript
DESCRIPTION: The stringifyCommentBody function converts a CommentBody to a plain string format. This is useful for displaying comments in a simple text format without special formatting.

LANGUAGE: typescript
CODE:
import { stringifyCommentBody } from "@liveblocks/client";

const stringComment = await stringifyCommentBody(comment.body);

// "Hello marc@example.com from https://liveblocks.io"
console.log(stringComment);

----------------------------------------

TITLE: Deploying Live Cursors Example on Vercel
DESCRIPTION: Command to set up the JavaScript live cursors example with Vercel deployment integration. This downloads the example and initiates the Vercel deployment process.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example javascript-live-cursors --vercel

----------------------------------------

TITLE: Integrating Liveblocks Room into Next.js Page
DESCRIPTION: Demonstrates how to use the Room component to wrap collaborative components in a page.tsx file. The Editor component is placed inside the Room component.

LANGUAGE: tsx
CODE:
import { Room } from "./Room";
import { Editor } from "./Editor";

export default function Page() {
  return (
    <Room>\n      <Editor/>\n    </Room>
  );
}

----------------------------------------

TITLE: Basic Zustand Store without Liveblocks Middleware
DESCRIPTION: Example of a to-do list store in Zustand without Liveblocks middleware integration. Shows the standard pattern for creating a Zustand store with a State type containing draft, isTyping, todos, and related methods.

LANGUAGE: typescript
CODE:
import create from "zustand";

type State = {
  draft: string;
  isTyping: boolean;
  todos: Todo[];
  setDraft: (draft: string) => void;
  addTodo: () => void;
  deleteTodo: (index: number) => void;
};

create<State>(/* ... */);

----------------------------------------

TITLE: Comparing Old and New Room API in Liveblocks Client
DESCRIPTION: Shows the transition from the deprecated room entering/leaving API to the new recommended API in Liveblocks client. The new API returns both the room instance and a leave function for improved room management.

LANGUAGE: typescript
CODE:
// Old APIs we'll no longer be recommending (but that will remain working)
const room = client.enter("my-room", options);
client.getRoom("my-room");
client.leave("my-room");

LANGUAGE: typescript
CODE:
// New API we'll be recommending instead
const { room, leave } = client.enterRoom("my-room", options);
leave();

----------------------------------------

TITLE: Upgrading Liveblocks packages using npx command
DESCRIPTION: Command to automatically upgrade all Liveblocks packages to the latest version using create-liveblocks-app utility.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --upgrade

----------------------------------------

TITLE: Using Typed Presence with Liveblocks Zustand Middleware
DESCRIPTION: Example of using the TPresence generic argument with Liveblocks Zustand middleware to properly type the presence data of other users in the room.

LANGUAGE: typescript
CODE:
type Presence = {
  isTyping: true;
}

const useStore = create(
  middleware<State, Presence>(/* ... */, {
    client,
    presenceMapping: { isTyping: true },
    storageMapping: { todos: true }
  })
);

// In your component
useStore(state => state.liveblocks.others[0].presence?.isTyping)

----------------------------------------

TITLE: Configuring Liveblocks types globally in TypeScript
DESCRIPTION: Demonstrates the improved DX in Liveblocks 2.0 where you can specify types globally once rather than passing them to each component. This approach allows sharing types across all Liveblocks APIs.

LANGUAGE: typescript
CODE:
// ❌ Before
export const {
  suspense: {
    RoomProvider,
    useRoom,
    // etc
  },
} = createRoomContext<Presence, Storage>(client);

// ✅ After
declare global {
  interface Liveblocks {
    Presence: Presence;
    Storage: Storage;
  }
}

----------------------------------------

TITLE: Integrating Liveblocks Primitives with Custom Design System
DESCRIPTION: Shows how to use the asChild property to merge Liveblocks primitives with components from a custom design system. This preserves the functionality while using custom UI components.

LANGUAGE: tsx
CODE:
import { Composer } from "@liveblocks/react-ui/primitives";
import { Button } from "@/my-design-system";

function Component() {
  return (
    <Composer.Submit asChild>
      <Button variant="primary">Reply</Button>
    </Composer.Submit>
  );
}

----------------------------------------

TITLE: Installing @liveblocks/client package via npm
DESCRIPTION: Command to install the @liveblocks/client package using npm. This is the primary dependency required to integrate with Liveblocks collaborative features in your application.

LANGUAGE: bash
CODE:
npm install @liveblocks/client

----------------------------------------

TITLE: Joining a Liveblocks Room with ClientSideSuspense
DESCRIPTION: React component that joins a Liveblocks room and adds a ClientSideSuspense wrapper to handle loading states gracefully. This allows adding collaborative components inside the room.

LANGUAGE: tsx
CODE:
"use client";

import {
  LiveblocksProvider,
  RoomProvider,
  ClientSideSuspense,
} from "@liveblocks/react/suspense";
import { Editor } from "./Editor";

export default function App() {
  return (
    <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>      <RoomProvider id="my-room">
        <ClientSideSuspense fallback={<div>Loading…</div>}>
          <Editor />
        </ClientSideSuspense>
      </RoomProvider>
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Joining a Liveblocks Room
DESCRIPTION: Code that demonstrates how to enter a Liveblocks room, which is a virtual collaborative space. Returns the room object and a leave function for disconnecting from the room.

LANGUAGE: js
CODE:
const { room, leave } = client.enterRoom("my-room");

----------------------------------------

TITLE: Basic FloatingThreads Implementation in Lexical Editor
DESCRIPTION: Basic implementation showing how to integrate FloatingThreads in a LexicalComposer setup. Displays floating Thread components below text highlights in the editor.

LANGUAGE: tsx
CODE:
<LexicalComposer initialConfig={initialConfig}>
  <LiveblocksPlugin>
    <FloatingThreads threads={threads} />
  </LiveblocksPlugin>
</LexicalComposer>

----------------------------------------

TITLE: LiveblocksProvider vs. createClient in v2.0
DESCRIPTION: Showing the change from using createClient to using LiveblocksProvider component in Liveblocks v2.0, which simplifies the React integration.

LANGUAGE: typescript
CODE:
// ❌ Before
const client = createClient(/* options */);

// ✅ After
<LiveblocksProvider /* options */>
  <App />
</LiveblocksProvider>

----------------------------------------

TITLE: Installing Liveblocks Comments Notifications Example with CLI
DESCRIPTION: Command to download and set up the Liveblocks comments notifications example with an automatically generated API key from your Liveblocks account.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-comments-notifications --api-key

----------------------------------------

TITLE: Initializing Liveblocks Configuration File
DESCRIPTION: Command to create a liveblocks.config.ts file using the Liveblocks CLI. This file can be used to define types for the application later.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --init --framework javascript

----------------------------------------

TITLE: Adding a Standard Toolbar to Tiptap Editor
DESCRIPTION: Implements the basic Toolbar component from Liveblocks React Tiptap library, providing formatting controls for the text editor.

LANGUAGE: tsx
CODE:
<Toolbar editor={editor} />

----------------------------------------

TITLE: Next.js Route Handler Implementation for Thread Notification Emails
DESCRIPTION: A complete Next.js route handler example that processes Liveblocks webhook events, verifies them, and generates HTML email content for thread notifications using prepareThreadNotificationEmailAsHtml.

LANGUAGE: tsx
CODE:
import { isThreadNotificationEvent, WebhookHandler } from "@liveblocks/node";
import { Liveblocks } from "@liveblocks/node";
// +++
import { prepareThreadNotificationEmailAsHtml } from "@liveblocks/emails";
// +++

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

const webhookHandler = new WebhookHandler(
  process.env.LIVEBLOCKS_WEBHOOK_SECRET_KEY as string
);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // +++
  if (isThreadNotificationEvent(event)) {
    const emailData = await prepareThreadNotificationEmailAsHtml(
      liveblocks,
      event
    );
    let email;

    switch (emailData.type) {
      case "unreadMention": {
        email = `
        <div>
          <div>
            @${emailData.comment.author.id} at ${emailData.comment.createdAt}
          </div>
          <div>${emailData.comment.body}</div>
        </div>
      `;
        break;
      }

      case "unreadReplies": {
        email = `
        <div>
          ${emailData.comments
            .map(
              (comment) => `
                <div>
                  <div>
                    @${comment.author.id} at ${comment.createdAt}
                  </div>
                  <div>${comment.body}</div>
                </div>
              `
            )
            .join("")}
        </div>
      `;
        break;
      }
    }

    // Send your email
    // ...
  }
  // +++

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Extending the Default Toolbar with Custom Content
DESCRIPTION: Demonstrates how to extend the default Toolbar by adding custom content before the first button and after the last button using the 'before' and 'after' props. This example shows how to add a custom help button.

LANGUAGE: tsx
CODE:
import { Toolbar } from "@liveblocks/react-lexical";
import { Icon } from "@liveblocks/react-ui";

<Toolbar
  // +++
  before={<>I'm at the start</>}
  after={
    <Toolbar.Button
      name="Help"
      icon={<Icon.QuestionMark />}
      shortcut="CMD-H"
      onClick={() => console.log("help")}
    />
  }
  // +++
/>;

----------------------------------------

TITLE: Configuring Lexical Editor with liveblocksConfig
DESCRIPTION: Example showing how to use the liveblocksConfig function to prepare a Lexical editor configuration that's compatible with Liveblocks collaboration features. This configuration is passed to the LexicalComposer component.

LANGUAGE: tsx
CODE:
import { liveblocksConfig } from "@liveblocks/react-lexical";

const initialConfig = liveblocksConfig({
  namespace: "MyEditor",
  theme: {},
  nodes: [],
  onError: (err) => console.error(err),
});

----------------------------------------

TITLE: Installing the Collaborative Whiteboard Example Using Create-Liveblocks-App
DESCRIPTION: Command to download and install the collaborative whiteboard example locally without requiring an API key or Vercel deployment.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example redux-whiteboard --no-api-key --no-vercel

----------------------------------------

TITLE: Accessing User Data from a Liveblocks Room
DESCRIPTION: Demonstrates how to use the room.getSelf() method to retrieve the current user's data, including their connection ID, presence information, user ID, custom info, and permissions within the room.

LANGUAGE: typescript
CODE:
const { room, leave } = client.enterRoom("my-room-id");

// {
//   connectionId: 52,
//   +++
//   presence: {
//     cursor: { x: 263, y: 786 },
//   },
//   +++
//   id: "mislav.abha@example.com",
//   +++
//   info: {
//     name: "Mislav Abha",
//     avatar: "/mislav.png",
//   },
//   +++
//   canWrite: true,
//   canComment: true,
// }
const user = room.getSelf();

----------------------------------------

TITLE: Joining a Liveblocks Room
DESCRIPTION: Demonstrates how to connect to a Liveblocks room using Redux actions. Users join a room when the component mounts and leave when it unmounts.

LANGUAGE: tsx
CODE:
"use client";

import { useEffect } from "react";
import { useDispatch } from "react-redux";
import { actions } from "@liveblocks/redux";

export default function App() {
  const dispatch = useDispatch();

  useEffect(() => {
    dispatch(actions.enterRoom("room-id"));

    return () => {
      dispatch(actions.leaveRoom("room-id"));
    };
  }, [dispatch]);

  return <Room />;
}

----------------------------------------

TITLE: Adding a comment button to BlockNote toolbar
DESCRIPTION: Implementation of a custom toolbar button that triggers the FloatingComposer by calling the addPendingComment command in BlockNote editor.

LANGUAGE: tsx
CODE:
import { BlockNoteEditor } from "@blocknote/core";

function Toolbar({ editor }: { editor: BlockNoteEditor | null }) {
  if (!editor) {
    return null;
  }

  return (
    <button
      onClick={() => {
        // +++
        (editor._tiptapEditor as any).chain().focus().addPendingComment().run();
        // +++
      }}
      // +++
      data-active={(editor._tiptapEditor as any).isActive(
        "liveblocksCommentMark"
      )}
      // +++
    >
      💬 New comment
    </button>
  );
}

----------------------------------------

TITLE: Comparison of Hooks Import Methods in Liveblocks v2
DESCRIPTION: Demonstrates the improved method for importing hooks directly from @liveblocks/react packages instead of from a configuration file, as part of the v2.0 update.

LANGUAGE: typescript
CODE:
// ❌ Before: get hooks exported from your Liveblocks config
import { RoomProvider, useRoom, ... } from "./liveblocks.config";

// ✅ After: import hooks directly
import { RoomProvider, useRoom, ... } from "@liveblocks/react";
import { RoomProvider, useRoom, ... } from "@liveblocks/react/suspense";

----------------------------------------

TITLE: Editing a Comment in TypeScript
DESCRIPTION: Example of using room.editComment to update an existing comment's content. This requires specifying both the thread ID and comment ID along with the new comment body.

LANGUAGE: ts
CODE:
const comment = await room.editComment({
  threadId: "th_xxx",
  commentId: "cm_xxx"
  body: {
    version: 1,
    content: [{ type: "paragraph", children: [{ text: "Hello" }] }],
  },
});

----------------------------------------

TITLE: Comparing Old and New Client Room Entry APIs in Liveblocks
DESCRIPTION: Example showing the old API for entering/leaving rooms in Liveblocks that will remain working but is no longer recommended, compared to the new recommended API that supports entering/leaving the same room multiple times.

LANGUAGE: typescript
CODE:
// Old APIs we'll no longer be recommending (but that will remain working)
const room = client.enter("my-room", options);
client.getRoom("my-room");
client.leave("my-room");

----------------------------------------

TITLE: Retrieving User Notification Settings with Liveblocks Client
DESCRIPTION: Code showing how to get user notification settings using the client. Returns settings for all notification channels like email, Slack, etc.

LANGUAGE: tsx
CODE:
import { createClient } from '@liveblocks/client'
const client = createClient({ ... })

const settings = await client.getNotificationSettings();
// { email: { thread: true, ... }, slack: { thread: false, ... }, ... }
console.log(settings);

const updatedSettings = await client.updateNotificationSettings({
  email: {
    thread: false,
  }
});

----------------------------------------

TITLE: Using useComposer Hook for Form Control in React
DESCRIPTION: Demonstrates how to use the useComposer hook within a Composer.Form to check if the composer input is empty and to control form submission, useful for creating custom buttons.

LANGUAGE: tsx
CODE:
import { Composer, useComposer } from "@liveblocks/react-ui/primitives";

function MyComposer() {
  return (
    <Composer.Form onComposerSubmit={/* handle submit */}>
      <Composer.Editor components={/* Your custom component parts */} />
      <MyComposerButton />
    </Composer.Form>
  );
}

// Button that submits the form, and is disabled when the input is empty
function MyComposerButton() {
  const { isEmpty, submit } = useComposer();

  return (
    <button onClick={submit} disabled={isEmpty}>
      Create thread
    </button>
  );
}

----------------------------------------

TITLE: Implementing Extended User Type in getUser.ts
DESCRIPTION: Updating the getUser database function to return the new property added to the User type.

LANGUAGE: typescript
CODE:
return { randomNumber: Math.random() /* ... */ };

----------------------------------------

TITLE: Subscribing to Lost Connection Events in @liveblocks/client
DESCRIPTION: High-level API to get informed when Liveblocks' automatic reconnection process is taking longer than usual, so you can show a toast message on screen.

LANGUAGE: typescript
CODE:
room.subscribe("lost-connection")

----------------------------------------

TITLE: Installing the Collaborative Whiteboard Example with Liveblocks CLI
DESCRIPTION: Command to download and install the collaborative whiteboard example using the Liveblocks CLI without configuring API keys or Vercel deployment.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example zustand-whiteboard --no-api-key --no-vercel

----------------------------------------

TITLE: Using useSyncStatus Hook with Smooth Option
DESCRIPTION: Example showing how to use the useSyncStatus hook with the smooth option to display a 'Saving...' spinner when Liveblocks is synchronizing local changes to the server.

LANGUAGE: typescript
CODE:
useSyncStatus({ smooth: true })

----------------------------------------

TITLE: Importing Liveblocks and Custom Styles
DESCRIPTION: Import statements for adding default Liveblocks styles and custom global styles to the application. These styles can be imported into the root layout or directly into a CSS file.

LANGUAGE: tsx
CODE:
import "@liveblocks/react-ui/styles.css";
import "@liveblocks/react-lexical/styles.css";
import "./globals.css";

----------------------------------------

TITLE: Deploying Liveblocks Multiplayer Form to Vercel
DESCRIPTION: Command to download the example and deploy it to Vercel. This sets up both the deployment pipeline and local development environment.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-form --vercel

----------------------------------------

TITLE: Initializing Liveblocks Configuration File
DESCRIPTION: Creates a liveblocks.config.ts file using the Liveblocks CLI. This file can later be used to define types for the application.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --init --framework javascript

----------------------------------------

TITLE: Creating a Complete Notification Settings Panel with Multiple Channels
DESCRIPTION: This example demonstrates building a full notification settings panel with support for multiple notification kinds across different channels (email and Slack). It conditionally renders controls based on which notification channels are available.

LANGUAGE: tsx
CODE:
import { useNotificationSettings } from "@liveblocks/react";

function NotificationSettings() {
  const [{ isLoading, error, settings }, updateSettings] =
    useNotificationSettings();

  if (isLoading || error) {
    return null;
  }

  return (
    <>
      {settings.email ? (
        <>
          <label>
            Receive document invites notifications by email
            <input
              type="checkbox"
              checked={settings.email.$documentInvite}
              onChange={(e) =>
                updateSettings({ email: { $documentInvite: e.target.checked } })
              }
            />
          </label>
          <label>
            Receive thread notifications by email
            <input
              type="checkbox"
              checked={settings.email.thread}
              onChange={(e) =>
                updateSettings({ email: { thread: e.target.checked } })
              }
            />
          </label>
          <label>
            Receive text mentions notifications by email
            <input
              type="checkbox"
              checked={settings.email.textMention}
              onChange={(e) =>
                updateSettings({ email: { textMention: e.target.checked } })
              }
            />
          </label>
        </>
      ) : null}

      {settings.slack ? (
        <>
          <label>
            Receive document invites notifications on Slack
            <input
              type="checkbox"
              checked={settings.slack.$documentInvite}
              onChange={(e) =>
                updateSettings({ slack: { $documentInvite: e.target.checked } })
              }
            />
          </label>
          <label>
            Receive thread notifications on Slack
            <input
              type="checkbox"
              checked={settings.slack.thread}
              onChange={(e) =>
                updateSettings({ slack: { thread: e.target.checked } })
              }
            />
          </label>
          <label>
            Receive text mentions notifications on Slack
            <input
              type="checkbox"
              checked={settings.slack.textMention}
              onChange={(e) =>
                updateSettings({ slack: { textMention: e.target.checked } })
              }
            />
          </label>
        </>
      ) : null}
    </>
  );
}

----------------------------------------

TITLE: Managing Notification Settings with useNotificationSettings Hook
DESCRIPTION: Example of using the useNotificationSettings hook to get current user notification settings and update them. Returns both the settings and an update function.

LANGUAGE: tsx
CODE:
// A suspense version of this hook is available
import { useNotificationSettings } from "@liveblocks/react";

const [{ isLoading, error, settings }, updateSettings] =
  useNotificationSettings();
// { email: { thread: true, ... }, slack: { thread: false, ... }, ... }
console.log(settings);

const onSave = () => {
  updateSettings({
    slack: {
      textMention: true,
    },
  });
};

----------------------------------------

TITLE: Using useThreads before pagination implementation in React
DESCRIPTION: Previous implementation of useThreads hook that fetches all threads without pagination support.

LANGUAGE: tsx
CODE:
import { useThreads } from "@liveblocks/react/suspense";

function Threads() {
  const { threads } = useThreads();

  return (
    <div>
      {threads.map((thread) => (
        <Thread key={thread.id} thread={thread} />
      ))}
    </div>
  );
}

----------------------------------------

TITLE: Setting Up Authentication Endpoint in Remix
DESCRIPTION: Implementation of a Remix action function that handles authentication for Liveblocks. This endpoint identifies users and returns the appropriate authentication tokens.

LANGUAGE: typescript
CODE:
import type { ActionFunction } from "@remix-run/node";
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export const action: ActionFunction = async ({ request }) => {
  // Get the current user from your database
  const user = __getUserFromDB__(request);

  // Identify the user and return the result
  const { status, body } = await liveblocks.identifyUser(
    {
      userId: user.id,
      groupIds, // Optional
    },
    { userInfo: user.metadata },
  );

  return new Response(body, { status });
}

----------------------------------------

TITLE: Recommended ThreadOverlay Implementation with Responsive Design
DESCRIPTION: A recommended approach for displaying threads using both FloatingThreads and AnchoredThreads components with Tailwind CSS classes for responsive design. This example filters out resolved threads and optimizes display for different screen sizes.

LANGUAGE: tsx
CODE:
import { useThreads } from "@liveblocks/react/suspense";
import { AnchoredThreads, FloatingThreads } from "@liveblocks/react-lexical";

function ThreadOverlay() {
  const { threads } = useThreads({ query: { resolved: false } });

  return (
    <>
      <FloatingThreads
        threads={threads}
        className="w-[350px] block md:hidden"
      />
      <AnchoredThreads
        threads={threads}
        className="w-[350px] hidden sm:block"
      />
    </>
  );
}

----------------------------------------

TITLE: Filtering Threads by Absence of Metadata in React
DESCRIPTION: Shows how to filter threads using the useThreads hook to find threads that don't have specific metadata attributes, such as filtering for pinned threads without a color value.

LANGUAGE: ts
CODE:
useThreads({
  query: {
    // Filter any "pinned" threads that don't have a color set
    metadata: {
      pinned: true,
      color: null, // ✨
    },
  },
});

----------------------------------------

TITLE: Passing User Properties to Liveblocks Authorize Function
DESCRIPTION: How to pass the user properties to the Liveblocks authorize function for use in presence.

LANGUAGE: typescript
CODE:
// Get Liveblocks access token
const { data, error } = await authorize({
  userInfo: { randomNumber /* ... */ },
  // ...
});

----------------------------------------

TITLE: Configuring User Info for Real-time Cursors
DESCRIPTION: Defines userInfo properties including name and color to display cursor information for authenticated users in real-time collaborative editing.

LANGUAGE: js
CODE:
userInfo: {
  name: "Marie",
  color: "#00ff00",
}

----------------------------------------

TITLE: Response Format for Room Storage Data in Liveblocks
DESCRIPTION: Example of the JSON response format when retrieving room storage data, showing the structure of LiveObject, LiveList, and LiveMap data types.

LANGUAGE: json
CODE:
{
  "liveblocksType": "LiveObject",
  "data": {
    "aLiveObject": {
      "liveblocksType": "LiveObject",
      "data": {
        "a": 1
      }
    },
    "aLiveList": {
      "liveblocksType": "LiveList",
      "data": ["a", "b"]
    },
    "aLiveMap": {
      "liveblocksType": "LiveMap",
      "data": {
        "a": 1,
        "b": 2
      }
    }
  }
}

----------------------------------------

TITLE: Opening the AI Toolbar with askAi Command
DESCRIPTION: Shows how to open the AiToolbar using the askAi command provided by Liveblocks. This can be triggered from a button click or other user interaction.

LANGUAGE: tsx
CODE:
import { Editor } from "@tiptap/react";

function Toolbar({ editor }: { editor: Editor | null }) {
  if (!editor) {
    return null;
  }

  return (
    <button
      onClick={() => {
        // +++
        editor.chain().focus().askAi().run();
        // +++
      }}
    >
      ✨ Ask AI
    </button>
  );
}

----------------------------------------

TITLE: Enabling Synchronization Status Protection with createClient
DESCRIPTION: Code snippet showing how to enable the preventUnsavedChanges option when using createClient to prevent browser tabs from being closed while local changes are not yet synchronized.

LANGUAGE: typescript
CODE:
createClient({ preventUnsavedChanges: true })

----------------------------------------

TITLE: Basic FloatingThreads Implementation in React with BlockNote
DESCRIPTION: Example of how to implement the FloatingThreads component with a custom class to display threads in a BlockNote editor.

LANGUAGE: tsx
CODE:
<FloatingThreads
  editor={editor}
  threads={threads}
  className="my-floating-thread"
/>

----------------------------------------

TITLE: Retrieving Other Users' Cursor Positions in Liveblocks with Redux
DESCRIPTION: Shows how to access the cursor positions of other users in the room using the Redux selector and mapping through the others array to extract presence data.

LANGUAGE: jsx
CODE:
import { useSelector } from "react-redux";

function OthersCursors() {
  const others = useSelector((state) => state.liveblocks.others);

  const othersCursors = others.map((user) => user.presence?.cursor);

  // Render cursors with custom SVGs based on x and y
}

----------------------------------------

TITLE: Installing Liveblocks To-do List Example via CLI
DESCRIPTION: Command to set up the Liveblocks collaborative to-do list example project locally without requiring an API key or Vercel deployment.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example redux-todo-list --no-api-key --no-vercel

----------------------------------------

TITLE: Managing Notification Settings with Liveblocks Node.js Client
DESCRIPTION: Demonstrates how to use the Node.js client to manage user notification settings, including getting, updating, and deleting notification settings for a user. The example shows the three new methods exposed by the Liveblocks Node.js client.

LANGUAGE: tsx
CODE:
import { Liveblocks } from "@liveblocks/node";
const liveblocks = new Liveblocks({ secret: "sk_xxx" });

const settings = await liveblocks.getNotificationSettings({ userId });
// { email: { thread: true, ... }, slack: { thread: false, ... }, ... }
console.log(settings);

const updatedSettings = await liveblocks.updateNotificationSettings({
  userId,
  data: {
    teams: {
      $fileUploaded: true,
    },
  },
});
await liveblocks.deleteNotificationSettings({ userId });

----------------------------------------

TITLE: Polling for Notification Updates with Client.getInboxNotificationsSince in TypeScript
DESCRIPTION: Demonstrates how to fetch notifications that have been updated or deleted since a specified time. This is useful for implementing polling to keep notifications current without refetching all data.

LANGUAGE: typescript
CODE:
const initial = await client.getInboxNotifications();

const { inboxNotifications, threads, requestedAt } =
  await client.getInboxNotificationsSince({ since: initial.requestedAt });

// { updated: [{ id: "in_ds83hs...", kind: "thread", }, ...], deleted: [...] }
console.log(inboxNotifications);

// { updated: [{ id: "th_s4368s...", type: "thread" }, ...], deleted: [...] }
console.log(threads);

----------------------------------------

TITLE: Configuring atob Polyfill with Liveblocks Client
DESCRIPTION: Code example showing how to import the decode function from base-64 and configure it as the atob polyfill when creating a Liveblocks client. This allows the client to function in environments without native atob support.

LANGUAGE: typescript
CODE:
import { decode } from "base-64";

const client = createClient({
  /* ... your other client's options */
  polyfills: {
    atob: decode,
  },
});

----------------------------------------

TITLE: Creating a Custom Thread Component with Comment Primitives
DESCRIPTION: Demonstrates how to build a fully custom Thread component using the Comment primitives from Liveblocks React UI.

LANGUAGE: tsx
CODE:
import { Comment } from "@liveblocks/react-ui/primitives";

<FloatingThreads
  editor={editor}
  threads={threads}
  className="my-floating-thread"
  components={{
    Thread: (props) => (
      // +++
      <div>
        {props.thread.comments.map((comment) => (
          <Comment.Body
            key={comment.id}
            body={comment.body}
            components={/* ... */}
          />
        ))}
      </div>
      // +++
    ),
  }}
/>;

----------------------------------------

TITLE: Creating Liveblocks Client with Unsaved Changes Prevention
DESCRIPTION: Example showing how to create a Liveblocks client with the preventUnsavedChanges option to prevent browser tabs from being closed while local changes are not yet synchronized.

LANGUAGE: typescript
CODE:
createClient({ preventUnsavedChanges: true })

----------------------------------------

TITLE: Using map Method with LiveList in TypeScript
DESCRIPTION: Demonstrates how to use the map method to create an array populated with the results of calling a provided function on every element in the LiveList.

LANGUAGE: typescript
CODE:
const list = new LiveList(["apple", "lemon", "tomato"]);

// ["APPLE", "LEMON", "TOMATO"]
list.map((value, index) => value.toUpperCase());

----------------------------------------

TITLE: Installing Live Cursors Example with Liveblocks CLI in Bash
DESCRIPTION: Command to create a new Liveblocks application using the nextjs-live-cursors-scroll example template. This automatically sets up the project and retrieves an API key from your Liveblocks account.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-live-cursors-scroll --api-key

----------------------------------------

TITLE: Initializing Liveblocks configuration file
DESCRIPTION: Command to create the liveblocks.config.ts file which can be used to define types for the application.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --init --framework javascript

----------------------------------------

TITLE: Implementing User Presence Indicator with useOthers Hook
DESCRIPTION: Adding the WhoIsHere component that displays how many other users are currently online in the room using the useOthers hook from Liveblocks.

LANGUAGE: tsx
CODE:
import {
  LiveblocksProvider,
  RoomProvider,
  ClientSideSuspense,
  useOthers,
} from "@liveblocks/react/suspense";

function WhoIsHere() {
  const userCount = useOthers((others) => others.length);

  return (
    <div className="who_is_here">There are {userCount} other users online</div>
  );
}

function TodoList() {
  return (
    <div className="container">
      <WhoIsHere />
    </div>
  );
}

/* Page */

----------------------------------------

TITLE: Using Threads Pagination in React with TypeScript
DESCRIPTION: Example of using pagination with the useThreads hook to incrementally load thread data. This approach allows for faster initial load and better user experience by loading additional data as needed.

LANGUAGE: tsx
CODE:
const {
  threads,
  isLoading,
  error,

  // ✨ New in Liveblocks 2.9
  fetchMore,
  isFetchingMore,
  hasFetchedAll,
  fetchMoreError,
} = useThreads({ query });

----------------------------------------

TITLE: Authorizing User and Returning Authentication Response
DESCRIPTION: This code completes the authentication process by finalizing the session and returning the authorization response with appropriate status code and body.

LANGUAGE: tsx
CODE:
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "sk_prod_xxxxxxxxxxxxxxxxxxxxxxxx",
});

export async function POST(request) {
  const user = { id: "olivier@example.com", info: { name: "Olivier" }};

  const session = liveblocks.prepareSession(
    user.id,
    { userInfo: user.info } // Optional
  );

  const { room } = await request.json();
  session.allow(room, session.FULL_ACCESS);

  const { status, body } = await session.authorize();
  return new Response(body, { status });
}

----------------------------------------

TITLE: Type Checking Command for Document Extensions
DESCRIPTION: Command to check for type errors after extending the Document type.

LANGUAGE: bash
CODE:
npm run typecheck

----------------------------------------

TITLE: Using useUpdateNotificationSettings Hook for Unsubscribe Functionality
DESCRIPTION: Example showing how to use the useUpdateNotificationSettings hook to implement an unsubscribe button or similar functionality.

LANGUAGE: tsx
CODE:
// A suspense version of this hook is available
import { useUpdateNotificationSettings } from "@liveblocks/react";

const updateSettings = useUpdateNotificationSettings();

const onUnsubscribe = () => {
  updateSettings({
    slack: {
      thread: false,
    },
  });
};

----------------------------------------

TITLE: Defining Global Types in Liveblocks 2.0
DESCRIPTION: Shows the improved developer experience in Liveblocks 2.0 by allowing global type definitions instead of passing types to createRoomContext. This demonstrates the before and after pattern for global type configuration.

LANGUAGE: typescript
CODE:
// ❌ Before
export const {
  suspense: {
    RoomProvider,
    useRoom,
    // etc
  },
} = createRoomContext<Presence, Storage>(client);

// ✅ After
declare global {
  interface Liveblocks {
    Presence: Presence;
    Storage: Storage;
  }
}

----------------------------------------

TITLE: Enabling Unsaved Changes Prevention in Client Creation
DESCRIPTION: Code snippet showing how to enable the preventUnsavedChanges option when creating a client to prevent browser tabs from closing while changes are being synchronized without React.

LANGUAGE: typescript
CODE:
createClient({ preventUnsavedChanges: true })

----------------------------------------

TITLE: Obtaining JWT Token with Secret Key in Liveblocks
DESCRIPTION: How to get a JWT token by calling the Liveblocks authorization endpoint using your secret key. The token will be valid for one hour.

LANGUAGE: bash
CODE:
curl https://liveblocks.io/api/authorize \
  -H "Authorization: Bearer YOUR_SECRET_KEY"

----------------------------------------

TITLE: Installing Liveblocks Notification Settings Example with CLI
DESCRIPTION: Command to set up the Liveblocks notification settings example project locally using the create-liveblocks-app CLI tool. This automatically downloads the example and helps configure the API key from your Liveblocks account.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-notification-settings --api-key

----------------------------------------

TITLE: Configuring LiveblocksProvider with Custom Headers
DESCRIPTION: Advanced setup for LiveblocksProvider using a callback to pass custom headers and body to the authentication endpoint. This allows for more complex authentication scenarios.

LANGUAGE: tsx
CODE:
<LiveblocksProvider
  authEndpoint={async (room) => {
    // Passing custom headers and body to your endpoint
    const headers = {
      // Custom headers
      // ...

      "Content-Type": "application/json",
    };

    const body = JSON.stringify({
      // Custom body
      // ...

      room,
    });

    const response = await fetch("/api/liveblocks-auth", {
      method: "POST",
      headers,
      body,
    });

    return await response.json();
  }}
/>

----------------------------------------

TITLE: Setting Up Liveblocks Room Provider in Next.js Index Page
DESCRIPTION: Implementation of the main page component with LiveblocksProvider and RoomProvider to set up the collaborative workspace. This creates the foundation for the to-do list application.

LANGUAGE: tsx
CODE:
"use client";

import { ReactNode } from "react";
import {
  LiveblocksProvider,
  RoomProvider,
  ClientSideSuspense,
} from "@liveblocks/react/suspense";

export default function Page() {
  return (
    <LiveblocksProvider publicApiKey={"{{SECRET_KEY}}"}>
      <RoomProvider id="my-room">
        <ClientSideSuspense fallback={<div>Loading…</div>}>
          <ToDoList />
        </ClientSideSuspense>
      </RoomProvider>
    </LiveblocksProvider>
  );
}

function TodoList() {
  return (
    <div>
      {/* We're starting to implement the to-do list in the next section */}
    </div>
  );
}

----------------------------------------

TITLE: Building a Custom Toolbar with Mixed Components
DESCRIPTION: Shows how to create a custom toolbar by mixing default section components with custom buttons. This example adds history controls and custom formatting buttons using Toolbar.Button and Toolbar.Toggle components.

LANGUAGE: tsx
CODE:
import { FORMAT_TEXT_COMMAND } from "lexical";
import { useLexicalComposerContext } from "@lexical/react/LexicalComposerContext";
import { isTextFormatActive, Toolbar } from "@liveblocks/react-lexical";
import { Icon } from "@liveblocks/react-ui";

function CustomToolbar() {
  const [editor] = useLexicalComposerContext();

  return (
    <Toolbar>
      // +++
      <Toolbar.SectionHistory />
      <Toolbar.Separator />
      <Toolbar.Button
        name="Help"
        icon={<Icon.QuestionMark />}
        shortcut="CMD-H"
        onClick={() => console.log("help")}
      />
      <Toolbar.Toggle
        name="Bold"
        icon={<strong>B️</strong>}
        active={isTextFormatActive(editor, "bold")}
        onClick={() => editor.dispatchCommand(FORMAT_TEXT_COMMAND, "bold")}
      />
      // +++
    </Toolbar>
  );
}

----------------------------------------

TITLE: Using LiveblocksProvider Instead of createClient
DESCRIPTION: Shows the transition from using createClient directly to using the new LiveblocksProvider component for configuring the Liveblocks client, which improves the React integration pattern.

LANGUAGE: typescript
CODE:
// ❌ Before
const client = createClient(/* options */);

// ✅ After
<LiveblocksProvider /* options */>
  <App />
</LiveblocksProvider>

----------------------------------------

TITLE: Subscribing to Storage Status Changes with TypeScript
DESCRIPTION: Example of using room.subscribe to monitor storage status changes. The snippet demonstrates how to handle the four possible status values: not-loaded, loading, synchronizing, and synchronized.

LANGUAGE: typescript
CODE:
room.subscribe("storage-status", (status) => {
  switch (status) {
    case "not-loaded":
      break;
    case "loading":
      break;
    case "synchronizing":
      break;
    case "synchronized":
      break;
    default:
      break;
  }
});

----------------------------------------

TITLE: RoomDeletedEvent Schema in TypeScript
DESCRIPTION: TypeScript schema and example for the RoomDeletedEvent webhook. This event is triggered when a room is deleted from the Liveblocks system.

LANGUAGE: typescript
CODE:
// Schema
type RoomDeletedEvent = {
  type: "roomDeleted";
  data: {
    projectId: string;
    roomId: string;
    deletedAt: string;
  };
};

// Example
const roomDeletedEvent = {
  type: "roomDeleted",
  data: {
    projectId: "my-project-id",
    roomId: "my-room-id",
    deletedAt: "2021-10-06T01:45:56.558Z",
  },
};

----------------------------------------

TITLE: LiveMap Updates with Validation
DESCRIPTION: Demonstrates valid and invalid updates to LiveMap fields. Shows how LiveMap validates both the structure of the map and the values it contains.

LANGUAGE: typescript
CODE:
// ✅
root.set(
  "shapes",
  new LiveMap([["shapeId", { x: 100, y: 100, fill: "blue" }]])
);

// ❌ Required field 'fill' is missing
root.set("shapes", new LiveMap([["shapeId", { x: 100, y: 100 }]]));

----------------------------------------

TITLE: Editor loading state implementation with useIsEditorReady
DESCRIPTION: Example showing how to handle the loading state of the editor using the useIsEditorReady hook, displaying a loading message until the editor is fully initialized.

LANGUAGE: tsx
CODE:
import { useLiveblocksExtension } from "@liveblocks/react-tiptap";
// +++
import { useIsEditorReady, useEditor, EditorContent } from "@tiptap/react";
// +++

function TextEditor() {
  const liveblocks = useLiveblocksExtension();
  // +++
  const ready = useIsEditorReady();
  // +++

  const editor = useEditor({
    extensions: [
      liveblocks,
      // ...
    ],
  });

  return (
    <div>
      // +++
      {!ready ? <div>Loading...</div> : <EditorContent editor={editor} />}
      // +++
    </div>
  );
}

----------------------------------------

TITLE: Initializing WebhookHandler for Liveblocks Webhooks
DESCRIPTION: The WebhookHandler class helps handle webhook requests from Liveblocks. It's initialized with a signing secret from your project's webhook page.

LANGUAGE: javascript
CODE:
const webhookHandler = new WebhookHandler(process.env.WEBHOOK_SECRET);

----------------------------------------

TITLE: Using ClientSideSuspense with thread components
DESCRIPTION: Implementation showing how to wrap thread components with ClientSideSuspense to prevent rendering until threads have loaded from the Liveblocks backend.

LANGUAGE: tsx
CODE:
<div>
  <BlockNoteView editor={editor} />
  <FloatingComposer editor={editor} style={{ width: "350px" }} />
  // +++
  <ClientSideSuspense fallback={null}>
    <ThreadOverlay editor={editor} />
  </ClientSideSuspense>
  // +++
</div>

----------------------------------------

TITLE: Running Local Development Server with Nuxt.js
DESCRIPTION: Command to start the local development server after manual setup, which will run the application on port 3000.

LANGUAGE: bash
CODE:
npm run dev

----------------------------------------

TITLE: Granting Room Access to a User
DESCRIPTION: This snippet shows how to give a user access to a specific room with full access permissions. The room name is extracted from the request JSON payload.

LANGUAGE: tsx
CODE:
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "sk_prod_xxxxxxxxxxxxxxxxxxxxxxxx",
});

export async function POST(request) {
  const user = { id: "olivier@example.com", info: { name: "Olivier" }};

  const session = liveblocks.prepareSession(
    user.id,
    { userInfo: user.info } // Optional
  );

  const { room } = await request.json();
  session.allow(room, session.FULL_ACCESS);
}

----------------------------------------

TITLE: Running Local Development Server with Nuxt.js
DESCRIPTION: Command to start the local development server after manual setup, which will run the application on port 3000.

LANGUAGE: bash
CODE:
npm run dev

----------------------------------------

TITLE: Creating Threads with useCreateThread in Liveblocks
DESCRIPTION: Demonstrates how to use useCreateThread hook to create a new thread with an initial comment and optional metadata.

LANGUAGE: tsx
CODE:
import { useCreateThread } from "@liveblocks/react/suspense";

const createThread = useCreateThread();
const thread = createThread({ body: {}, attachments: [], metadata: {} });

----------------------------------------

TITLE: Configuring Composer.Form with onComposerSubmit Callback
DESCRIPTION: Shows how to set up the Composer.Form component with an onComposerSubmit callback to handle form submissions with body and attachments data.

LANGUAGE: tsx
CODE:
<Composer.Form
  onComposerSubmit={({ body, attachments }) => {
    // Mutate your comments
    // ...
  }}
>
  {/* ... */}
</Composer.Form>

----------------------------------------

TITLE: Configuring RoomProvider with unstable_batchedUpdates for React 17 or Lower
DESCRIPTION: Code example showing how to fix the "zombie-child" problem in React 17 or lower by passing the unstable_batchedUpdates prop to RoomProvider. This helps prevent stale props issues that can occur with older React versions.

LANGUAGE: tsx
CODE:
// ⚠️  Only if you're using React 17 or lower
import { unstable_batchedUpdates } from "react-dom";  // 👈

<RoomProvider
  id="my-room"
  initialPresence={...}
  initialStorage={...}
  unstable_batchedUpdates={unstable_batchedUpdates}  // 👈
>
  <App />
</RoomProvider>

----------------------------------------

TITLE: Using some Method with LiveList in TypeScript
DESCRIPTION: Demonstrates how to use the some method to test whether at least one element in the LiveList passes the test implemented by the provided function.

LANGUAGE: typescript
CODE:
const list = new LiveList(["apple", "lemon", "tomato"]);

// true
list.some((value, index) => value.startsWith("l"));

// false
list.some((value, index) => value.startsWith("x"));

----------------------------------------

TITLE: Deploying Custom Notifications Example to Vercel
DESCRIPTION: Command to download the custom notifications example and deploy it to Vercel. This streamlines the process of both setting up the project locally and deploying it to production.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-notifications-custom --vercel

----------------------------------------

TITLE: Installing Liveblocks Node Package for Webhooks
DESCRIPTION: Command to install the @liveblocks/node package which is required for webhook verification and handling.

LANGUAGE: bash
CODE:
npm install @liveblocks/node

----------------------------------------

TITLE: Defining Global Liveblocks Types in TypeScript
DESCRIPTION: Example of defining global Liveblocks types in a liveblocks.config.ts file. This shows how to declare interfaces for Presence and Storage types globally, which is a new approach introduced in Liveblocks 2.0.

LANGUAGE: typescript
CODE:
// ❌ Before
export const {
  suspense: {
    RoomProvider,
    useRoom,
    // etc
  },
} = createRoomContext<Presence, Storage>(client);

// ✅ After
declare global {
  interface Liveblocks {
    Presence: Presence;
    Storage: Storage;
  }
}

----------------------------------------

TITLE: Using SyncStatus Hook with TypeScript in React
DESCRIPTION: Example of using the useSyncStatus hook introduced in version 2.12.0 to display synchronization status with smooth transition, useful for showing a 'Saving...' indicator in applications.

LANGUAGE: tsx
CODE:
useSyncStatus({ smooth: true })

----------------------------------------

TITLE: Subscribing to Storage Status Changes in Liveblocks Client
DESCRIPTION: Demonstrates how to subscribe to storage status changes using the Liveblocks client. The code shows how to handle different status states: not-loaded, loading, synchronizing, and synchronized.

LANGUAGE: typescript
CODE:
room.subscribe("storage-status", (status) => {
  switch (status) {
    case "not-loaded":
      break;
    case "loading":
      break;
    case "synchronizing":
      break;
    case "synchronized":
      break;
    default:
      break;
  }
});

----------------------------------------

TITLE: Creating a Custom Link Component for Composer.Editor
DESCRIPTION: Shows how to implement a custom Link component to display hyperlinks within the Composer.Editor.

LANGUAGE: tsx
CODE:
<Composer.Editor
  components={{
    Link: ({ href, children }) => <Composer.Link>{children}</Composer.Link>,
  }}
/>

----------------------------------------

TITLE: Installing Liveblocks Packages for Zustand Integration
DESCRIPTION: Command to install the required Liveblocks packages with the same version to ensure compatibility.

LANGUAGE: bash
CODE:
npm install @liveblocks/client @liveblocks/zustand

----------------------------------------

TITLE: Resolving User and Room Data for Personalized Email Notifications
DESCRIPTION: This code snippet demonstrates how to use resolver functions with prepareTextMentionNotificationEmailAsReact to transform user IDs into display names and fetch room information. This enables more personalized and context-rich email notifications.

LANGUAGE: tsx
CODE:
// ...

emailData = await prepareTextMentionNotificationEmailAsReact(
  liveblocks,
  event,
  {
    // +++
    resolveUsers: async ({ userIds }) => {
      const usersData = await __getUsersFromDB__(userIds);

      return usersData.map((userData) => ({
        name: userData.name, // "Chris"
        avatar: userData.avatar.src, // "https://example.com/chris.jpg"
      }));
    },
    resolveRoomInfo: async ({ roomId }) => {
      const roomData = await __getRoomFromDB__(roomId);

      return {
        name: roomData.name, // "Untitled document"
        url: roomData.url, //`https://example.com/my-room-id`
      };
    },
    // +++
  }
);

// ...

----------------------------------------

TITLE: Using LiveblocksProvider with Unsaved Changes Prevention (JSX)
DESCRIPTION: Implementation of the preventUnsavedChanges option in LiveblocksProvider to prevent browser tabs from closing while local changes are not yet synchronized.

LANGUAGE: jsx
CODE:
<LiveblocksProvider preventUnsavedChanges />

----------------------------------------

TITLE: Updated Authentication with Optional Room Parameter
DESCRIPTION: In Liveblocks 1.10, the room parameter in the authEndpoint callback can be undefined when using useInboxNotifications, allowing for cross-room functionality.

LANGUAGE: typescript
CODE:
const client = createClient({
  authEndpoint: (room) => {
    // The `room` argument will be `undefined` if you're using `useInboxNotifications`
  },
});

----------------------------------------

TITLE: Defining User Metadata Types
DESCRIPTION: TypeScript interface definition for user metadata in Liveblocks configuration. This allows for type-safe access to user information throughout the application.

LANGUAGE: typescript
CODE:
declare global
  interface Liveblocks {
    UserMeta: {
      id: string;

      // Example, use any JSON-compatible data in your metadata
      info: {
        name: string;
        avatar: string;
        colors: string[];
      }
    }

    // Other type definitions
    // ...
  }
}

----------------------------------------

TITLE: Customizing Toolbar.Toggle with Icons and Shortcuts
DESCRIPTION: Shows various ways to customize Toolbar.Toggle components by adding icons, keyboard shortcuts, custom styling, and event handlers. The examples demonstrate different visual representations of the toggle button.

LANGUAGE: tsx
CODE:
import { Toolbar } from "@liveblocks/react-lexical";
import { Icon } from "@liveblocks/react-ui";

// Button says "Highlight"
<Toolbar.Toggle
  name="Highlight"
  active={/* ... */}
  onClick={/* ... */}
/>

// Tooltip says "Highlight [⌘+H]"
<Toolbar.Toggle
  name="Highlight"
  shortcut="CMD+H"
  active={/* ... */}
  onClick={/* ... */}
/>

// Custom icon, replaces the name in the button
<Toolbar.Toggle
  name="Highlight"
  icon={<div>🖊</div>}
  active={/* ... */}
  onClick={/* ... */}
/>

// Using a Liveblocks icon, replaces the name in the button
<Toolbar.Toggle
  name="Highlight"
  icon={<Icon.QuestionMark />}
  active={/* ... */}
  onClick={/* ... */}
/>

// Passing children visually replaces the `name` and `icon`
<Toolbar.Toggle
  name="Highlight"
  active={/* ... */}
  onClick={/* ... */}
>
  🖊️Highlight
</Toolbar.Toggle>

// Props are passed to the inner `button`
<Toolbar.Toggle
  name="Highlight"
  active={/* ... */}
  onClick={/* ... */}
  style={{ marginLeft: 10 }}
  className="custom-toggle"
  onMouseOver={() => console.log("Hovered")}
/>

----------------------------------------

TITLE: Getting and Updating User Notification Settings with Liveblocks Client
DESCRIPTION: Example of how to use the Liveblocks client to get and update user notification settings. This code creates a client and then retrieves the current notification settings, followed by updating email thread notifications.

LANGUAGE: typescript
CODE:
import { createClient } from '@liveblocks/client'
const client = createClient({ ... })

const settings = await client.getNotificationSettings();
// { email: { thread: true, ... }, slack: { thread: false, ... }, ... }
console.log(settings);

const updatedSettings = await client.updateNotificationSettings({
  email: {
    thread: false,
  }
});

----------------------------------------

TITLE: Running ngrok for Webhook Testing
DESCRIPTION: Command to run ngrok to expose a local server (port 3000) to the internet. This creates a temporary public URL that can be used for webhook testing.

LANGUAGE: bash
CODE:
ngrok http 3000

----------------------------------------

TITLE: Using .astro Components with Liveblocks
DESCRIPTION: Example of importing and using a vanilla .astro component in an Astro application. When using .astro components, the client:only directive is not necessary because script tags in these components always run on the client side.

LANGUAGE: astro
CODE:
---
import VanillaInput from "../components/VanillaInput.astro";
---

<main>
  <VanillaInput />
</main>

----------------------------------------

TITLE: Setting up Local Tunnel for Webhook Testing with bash
DESCRIPTION: Command to create a temporary public URL that forwards to your localhost server for webhook testing. This allows external services to reach your local development environment.

LANGUAGE: bash
CODE:
npx localtunnel --port 3000

----------------------------------------

TITLE: Using Toolbar.Button Component in React-Lexical
DESCRIPTION: Demonstrates how to use the Toolbar.Button component for triggering actions within a Toolbar. The button displays its name in a tooltip and can be clicked to perform actions.

LANGUAGE: tsx
CODE:
import { Toolbar } from "@liveblocks/react-lexical";

<Toolbar>
  <Toolbar.Button name="Question" onClick={(e) => console.log("Clicked")} />
</Toolbar>;

----------------------------------------

TITLE: Removing a Reaction from a Comment in Liveblocks
DESCRIPTION: Uses the liveblocks.removeCommentReaction method to remove a specific emoji reaction from a comment. Requires roomId, threadId, commentId, and data containing the emoji, userId, and optional removedAt timestamp.

LANGUAGE: typescript
CODE:
await liveblocks.removeCommentReaction({
  roomId: "my-room-id",
  threadId: "th_d75sF3...",
  commentId: "cm_agH76a...",

  data: {
    emoji: "👨‍👩‍👧",
    userId: "steven@example.com",
    removedAt: new Date(), // Optional, the time the reaction is to be removed
  },
});

----------------------------------------

TITLE: Typing Presence with Liveblocks Zustand Middleware in TypeScript
DESCRIPTION: Advanced example showing how to type the presence data in Liveblocks Zustand middleware. This enables proper typing of the presence data from other users in the room.

LANGUAGE: typescript
CODE:

type Presence = {
  isTyping: true;
}

const useStore = create(
  middleware<State, Presence>(/* ... */, {
    client,
    presenceMapping: { isTyping: true },
    storageMapping: { todos: true }
  })
);

// In your component
useStore(state => state.liveblocks.others[0].presence?.isTyping)

----------------------------------------

TITLE: Adding FloatingComposer to the BlockNote editor
DESCRIPTION: Implementation showing how to add the FloatingComposer component to enable comment creation in the BlockNote editor with Liveblocks.

LANGUAGE: tsx
CODE:
import {
  useCreateBlockNoteWithLiveblocks,
  // +++
  FloatingComposer,
  // +++
} from "@liveblocks/react-blocknote";
import { BlockNoteView } from "@blocknote/mantine";

function TextEditor() {
  const editor = useCreateBlockNoteWithLiveblocks({});

  return (
    <div>
      <BlockNoteView editor={editor} />
      // +++
      <FloatingComposer editor={editor} style={{ width: "350px" }} />
      // +++
    </div>
  );
}

----------------------------------------

TITLE: CSS Styling for Cursors in Collaborative Editor
DESCRIPTION: CSS module defining styles for rendering live cursors, carets, and text selections in the collaborative editor. Positions elements absolutely to ensure cursors appear correctly over the text content.

LANGUAGE: css
CODE:
.cursors {
  position: relative;
}

.caretMarker {
  position: absolute;
  width: 2px;
}

.caret {
  position: absolute;
  font-size: 14px;
  color: #fff;
  white-space: nowrap;
  top: 0;
  border-radius: 6px;
  border-bottom-left-radius: 0;
  padding: 2px 6px;
  pointer-events: none;
}

.selection {
  position: absolute;
  pointer-events: none;
  opacity: 0.2;
}

----------------------------------------

TITLE: Installing the Collaborative Whiteboard Example with Liveblocks CLI
DESCRIPTION: Command to download and set up the whiteboard example using the Liveblocks CLI tool. This command installs the necessary dependencies and helps configure your API key automatically.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-whiteboard --api-key

----------------------------------------

TITLE: Using useThreads Hook with Pagination
DESCRIPTION: Example of using the useThreads hook with pagination support in version 2.9, showing how to access pagination-related properties and methods when querying threads.

LANGUAGE: TSX
CODE:
const {
  threads,
  isLoading,
  error,

  // ✨ New in Liveblocks 2.9
  fetchMore,
  isFetchingMore,
  hasFetchedAll,
  fetchMoreError,
} = useThreads({ query });

----------------------------------------

TITLE: Using isBlockNodeActive to Check Active Block Types in Liveblocks Lexical
DESCRIPTION: This snippet demonstrates how to use the isBlockNodeActive utility to check if a specific block node type is active in the current selection. It works with Lexical's node type checking functions like $isTextNode.

LANGUAGE: tsx
CODE:
import { isBlockNodeActive } from "@liveblocks/react-lexical";
import { $isTextNode } from "lexical";

// Checking if text node is currently active
const isActive = isBlockNodeActive(editor, $isTextNode);

----------------------------------------

TITLE: Implementing a FloatingToolbar for Text Formatting in Composer.Editor
DESCRIPTION: Demonstrates how to create a floating toolbar that appears when text is selected, providing formatting options like bold and italic.

LANGUAGE: tsx
CODE:
<Composer.Editor
  components={{
    FloatingToolbar: () => (
      <Composer.FloatingToolbar>
        <Composer.MarkToggle mark="bold">Bold</Composer.MarkToggle>
        <Composer.MarkToggle mark="italic">Italic</Composer.MarkToggle>
      </Composer.FloatingToolbar>
    ),
  }}
/>

----------------------------------------

TITLE: Rendering Comment Bodies in a Thread with Comment Primitive in React
DESCRIPTION: Shows how to render a list of comments in a thread using the Comment primitive, transforming each comment's body object into text, mentions, and links.

LANGUAGE: tsx
CODE:
import { Comment } from "@liveblocks/react-ui/primitives";
import { CommentData } from "@liveblocks/client";

// Render custom comments in a thread.
function MyComments({ comments }: { comments: CommentData[] }) {
  return (
    <>
      {comments.map((comment) => (
        <div key={comment.id}>
          <Comment.Body
            body={comment.body}
            components={/* Your custom component parts */}
          />
        </div>
      ))}
    </>
  );
}

----------------------------------------

TITLE: Constructing Signed Content for Manual Webhook Verification
DESCRIPTION: Shows how to manually create the signed content by concatenating the webhook id, timestamp, and body for verification purposes.

LANGUAGE: typescript
CODE:
const crypto = require("crypto");

// webhookId comes from the `webhook-id` header
// webhookTimestamp comes from the `webhook-timestamp` header
// body is the request body
signedContent = `${webhookId}.${webhookTimestamp}.${body}`;

----------------------------------------

TITLE: Using Event Listener Hook with User Property in @liveblocks/react
DESCRIPTION: Example of the updated useEventListener hook in the React package that now includes a user property to indicate which user sent the event.

LANGUAGE: tsx
CODE:
useEventListener(({ event, user }) => {
  //                       ^^^^ New!
});

----------------------------------------

TITLE: Configuring LiveblocksProvider for React Native environment
DESCRIPTION: Example showing how to provide the atob polyfill to the LiveblocksProvider when using Liveblocks in a React Native environment.

LANGUAGE: ts
CODE:
import { LiveblocksProvider } from "@liveblocks/react/suspense";
import { decode } from "base-64";

function App() {
  return (
    <LiveblocksProvider
      polyfills={{
        atob: decode,
      }}

      // Other props
      // ...
    >
      {/* children */}
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Retrieving Liveblocks Storage Data with REST API
DESCRIPTION: A TypeScript implementation of a webhook handler that retrieves the current room's Storage data using the Liveblocks REST API. This code verifies webhook requests and fetches Storage document data when a 'storageUpdated' event is received.

LANGUAGE: typescript
CODE:
import { WebhookHandler } from "@liveblocks/node";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When Storage document data has been updated
  if (event.type === "storageUpdated") {
    const { roomId } = event.data;

    // Get Storage data from Liveblocks REST API
    const url = `https://api.liveblocks.io/v2/rooms/${roomId}/storage`;
    const response = await fetch(url, {
      headers: { Authorization: `Bearer ${API_SECRET}` },
    });

    if (!response.ok) {
      return new Response("Problem accessing Liveblocks REST APIs", {
        status: 500,
      });
    }

    // Your JSON Storage document data as a string
    const storageData = await response.text();

    // Update database
    // ...
  }

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Using useSyncStatus Hook with Smooth Option (TSX)
DESCRIPTION: Implementation of the useSyncStatus hook with the smooth option to display a saving indicator while Liveblocks is synchronizing local changes to the server.

LANGUAGE: tsx
CODE:
useSyncStatus({ smooth: true })

----------------------------------------

TITLE: New Method: Guaranteed Referential Equality
DESCRIPTION: Improved approach with useStorage hook that guarantees referential equality for unchanged data, ensuring proper behavior with React effect dependencies.

LANGUAGE: tsx
CODE:
function Component() {
  const scientist = useStorage((root) => root.scientist);

  useEffect(() => {
    // Effect triggered every time scientist (or their pets list) changes! :)
    // But not more often than that!
  }, [scientist]);
}

----------------------------------------

TITLE: Replacing Localhost URL with LocalTunnel URL for Webhook Testing
DESCRIPTION: Example showing how to replace the localhost domain with the LocalTunnel-generated domain to create a publicly accessible webhook endpoint URL for testing.

LANGUAGE: shell
CODE:
# Take your local URL
http://localhost:3000/api/liveblocks-database-sync

# Replace localhost with the generated domain, then copy it
https://my-localtunnel-url.loca.lt/api/liveblocks-database-sync

----------------------------------------

TITLE: Replacing useList/useObject/useMap with useStorage
DESCRIPTION: Demonstrates how to replace the older hooks that access Live structures (useObject, useList, useMap) with the newer useStorage hook when only reading data from Storage.

LANGUAGE: tsx
CODE:
// ❌
const obj = useObject("a");
const list = useObject("b");
const map = useMap("c");

LANGUAGE: tsx
CODE:
// ✅
const obj = useStorage((root) => root.a);
const list = useStorage((root) => root.b);
const map = useStorage((root) => root.c);

----------------------------------------

TITLE: Integrating Zustand Store with Liveblocks Middleware in TypeScript
DESCRIPTION: Implementation of a Zustand store using Liveblocks middleware to enable real-time collaboration. This example shows how to map local state to presence and storage for synchronization.

LANGUAGE: typescript
CODE:
import create from "zustand";
import { createClient } from "@liveblocks/client";
import { middleware } from "@liveblocks/zustand";

const client = createClient({ /*...*/ });

type State = {
  draft: string;
  isTyping: boolean;
  todos: Todo[];
  setDraft: (draft: string) => void;
  addTodo: () => void;
  deleteTodo: (index: number) => void;
};

create(
  middleware<State>(/* ... */, {
    client,
    presenceMapping: { isTyping: true },
    storageMapping: { todos: true }
  })
);

----------------------------------------

TITLE: Updating Yjs Provider Import and Usage
DESCRIPTION: Shows how to update imports and constructor usage after the default export in @liveblocks/yjs was changed to a named export LiveblocksYjsProvider.

LANGUAGE: tsx
CODE:
// ❌ Before
import LiveblocksProvider from "@liveblocks/yjs";
const yDoc = new Y.Doc();
const yProvider = new LiveblocksProvider(room, yDoc);

----------------------------------------

TITLE: Adding Input Field to HTML Structure
DESCRIPTION: Adds an input field to the HTML structure that will be used for typing todo items. The input has an ID of 'todo_input' which will be referenced in JavaScript to track typing events.

LANGUAGE: html
CODE:
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Liveblocks - Todo list</title>
    <link rel="stylesheet" href="index.css" />
  </head>
  <body>
    <div class="container">
      <div id="who_is_here" class="who_is_here"></div>
      <input id="todo_input" type="text" placeholder="What needs to be done?" />
    </div>
    <script src="app.js"></script>
  </body>
</html>

----------------------------------------

TITLE: Rendering a List of Comments from a Thread
DESCRIPTION: Example showing how to map through thread.comments to render each comment in a thread using the Comment component. The thread data is retrieved with the useThreads hook.

LANGUAGE: tsx
CODE:
import { Comment } from "@liveblocks/react-ui";
import { ThreadData } from "@liveblocks/client";

// Renders a list of comments attach to the specified `thread`
function Component({ thread }: { thread: ThreadData }) {
  return (
    <>
      {thread.comments.map((comment) => (
        <Comment key={comment.id} comment={comment} />
      ))}
    </>
  );
}

----------------------------------------

TITLE: Resolving User Information with resolveUsers Function
DESCRIPTION: This snippet shows how to implement the resolveUsers function in the liveblocks.config.ts file to provide custom user data when fetching user information.

LANGUAGE: ts
CODE:
async function resolveUsers({ userIds }) {
  // ["olivier@example.com"]
  console.log(userIds);

  return [
    {
      name: "Olivier",
      avatar: "https://example.com/olivier.png",
      color: "red",
    },
  ];
}

----------------------------------------

TITLE: Handling Storage Update Events in Webhook Handler
DESCRIPTION: Extends the webhook handler to specifically process storageUpdated events. When Storage document data is updated, the code extracts the roomId from the event data, which can then be used to retrieve the latest document and update the database.

LANGUAGE: typescript
CODE:
import { WebhookHandler } from "@liveblocks/node";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When Storage document data has been updated
  if (event.type === "storageUpdated") {
    const { roomId } = event.data;

    // Update database
    // ...
  }

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Creating a Typed Zustand Store with Liveblocks Middleware
DESCRIPTION: Example of creating a Zustand store with Liveblocks middleware integration for TypeScript. Shows how to define a state type and use it with the middleware to create a collaborative store with presence and storage mapping.

LANGUAGE: ts
CODE:
import create from "zustand";
import { createClient } from "@liveblocks/client";
import { middleware } from "@liveblocks/zustand";

const client = createClient({ /*...*/ });

type State = {
  draft: string;
  isTyping: boolean;
  todos: Todo[];
  setDraft: (draft: string) => void;
  addTodo: () => void;
  deleteTodo: (index: number) => void;
};

create(
  middleware<State>(/* ... */, {
    client,
    presenceMapping: { isTyping: true },
    storageMapping: { todos: true }
  })
);

----------------------------------------

TITLE: Old Method: Referential Equality Issues
DESCRIPTION: Previous approach with useObject hook that had issues with referential equality, leading to unexpected behavior with React effect dependencies.

LANGUAGE: tsx
CODE:
function Component() {
  const scientist = useObject("scientist");

  useEffect(() => {
    // Effect never triggered when scientist (or their pets list) changes! :(
  }, [scientist]);
}

----------------------------------------

TITLE: Setting Room Permissions with Liveblocks Node
DESCRIPTION: Demonstrates how to create a room with specific permission settings. This code configures default access levels and provides different permissions to specific groups and users.

LANGUAGE: typescript
CODE:
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

const room = await liveblocks.createRoom("my-room-id", {
  defaultAccesses: ["room:read", "room:presence:write"],
  groupsAccesses: {
    "my-group-id": ["room:write"],
  },
  usersAccesses: {
    "my-user-id": ["room:write"],
  },
});

----------------------------------------

TITLE: Customizing Thread Components in FloatingThreads
DESCRIPTION: Shows how to customize the Thread component within FloatingThreads by passing a custom component to modify width and styling.

LANGUAGE: tsx
CODE:
import { Thread } from "@liveblocks/react-ui";

<FloatingThreads
  editor={editor}
  threads={threads}
  className="my-floating-thread"
  // +++
  components={{
    Thread: (props) => (
      <Thread {...props} className="border shadow" style={{ width: "300px" }} />
    ),
  }}
  // +++
/>;

----------------------------------------

TITLE: Comparing Old and New Room Entry APIs in Liveblocks Client
DESCRIPTION: Demonstrates the shift from the deprecated client.enter/leave/getRoom APIs to the new recommended client.enterRoom pattern. The new API returns both the room and a leave function, supporting multiple connections to the same room.

LANGUAGE: typescript
CODE:
// Old APIs we'll no longer be recommending (but that will remain working)
const room = client.enter("my-room", options);
client.getRoom("my-room");
client.leave("my-room");

LANGUAGE: typescript
CODE:
// New API we'll be recommending instead
const { room, leave } = client.enterRoom("my-room", options);
leave();

----------------------------------------

TITLE: Running remove-liveblocks-config-contexts with Suspense Flag in Shell
DESCRIPTION: Executes the codemod with the --suspense flag to update all imports to @liveblocks/react/suspense instead, for cases where Suspense versions of hooks are exported.

LANGUAGE: shell
CODE:
npx @liveblocks/codemod@latest remove-liveblocks-config-contexts --suspense

----------------------------------------

TITLE: New Recommended Room Enter/Leave API Pattern in Liveblocks 1.5
DESCRIPTION: The new preferred pattern for entering and leaving rooms in Liveblocks 1.5. This approach returns both the room and a leave function, enabling better resource management and support for advanced use cases.

LANGUAGE: tsx
CODE:
// ✅ Prefer this API instead
const { room, leave } = client.enterRoom("my-room", options);

// Then later, when unmounting
leave();

----------------------------------------

TITLE: Customizing Toolbar.Button with Icons and Shortcuts
DESCRIPTION: Shows various ways to customize Toolbar.Button components by adding icons, keyboard shortcuts, custom styling, and event handlers. The examples demonstrate different visual representations of the button.

LANGUAGE: tsx
CODE:
import { Toolbar } from "@liveblocks/react-lexical";
import { Icon } from "@liveblocks/react-ui";

// Button says "Question"
<Toolbar.Toggle name="Question" onClick={/* ... */} />

// Tooltip says "Question [⌘+Q]"
<Toolbar.Button name="Question" shortcut="CMD+Q" onClick={/* ... */} />

// Custom icon, replaces the name in the button
<Toolbar.Button name="Question" icon={<div>?</div>} onClick={/* ... */} />

// Using a Liveblocks icon, replaces the name in the button
<Toolbar.Button name="Question" icon={<Icon.QuestionMark />} onClick={/* ... */} />

// Passing children visually replaces the `name` and `icon`
<Toolbar.Button name="Question" onClick={/* ... */}>
  ? Ask a question
</Toolbar.Button>

// Props are passed to the inner `button`
<Toolbar.Button
  name="Question"
  style={{ marginLeft: 10 }}
  className="custom-button"
  onMouseOver={() => console.log("Hovered")}
/>

----------------------------------------

TITLE: Upsert Room with Liveblocks in TypeScript
DESCRIPTION: Updates a room's properties by ID or creates it if it doesn't exist. The defaultAccesses parameter is required to set permissions. Returns the room object with its properties.

LANGUAGE: typescript
CODE:
const room = await liveblocks.upsertRoom("my-room-id", {
  // These fields will get updated when the room exists, or will be created
  update: {
    metadata: { color: "red" },
  },
  // These fields will only be set when the room will get created
  create: {
    defaultAccesses: ["room:write"],
  },
});

// { type: "room", id: "my-room-id", metadata: {...}, ... }
console.log(room);

----------------------------------------

TITLE: Retrieving Notification Settings with getNotificationSettings in TypeScript
DESCRIPTION: Shows how to retrieve a user's notification settings for the current project, which controls which notification webhook events will be sent for the user.

LANGUAGE: typescript
CODE:
const settings = await liveblocks.getNotificationSettings({
  userId: "guillaume@liveblocks.io",
});

// { email: { thread: true, ... }, slack: { thread: false, ... }, ... }
console.log(settings);

----------------------------------------

TITLE: Installing the Collaborative To-do List Example with Liveblocks CLI
DESCRIPTION: Command to set up the collaborative to-do list example using the Liveblocks CLI. This automatically downloads the example and helps you connect your Liveblocks API key.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-todo-list --api-key

----------------------------------------

TITLE: Implementing User Notifications for Connection Issues in Liveblocks
DESCRIPTION: Example of implementing user-friendly toast notifications for connection issues using the lost-connection event. Handles lost, restored, and failed connection states.

LANGUAGE: typescript
CODE:
import { toast } from "my-preferred-toast-library";

const unsubscribe = room.subscribe("lost-connection", (event) => {
  switch (event) {
    case "lost":
      toast.warn("Still trying to reconnect...");
      break;

    case "restored":
      toast.success("Successfully reconnected again!");
      break;

    case "failed":
      toast.error("Could not restore the connection");
      break;
  }
});

----------------------------------------

TITLE: Defining ThreadMarkedAsUnresolvedEvent Schema and Example in TypeScript
DESCRIPTION: TypeScript definition for ThreadMarkedAsUnresolvedEvent which is triggered when a thread is marked as unresolved. This event includes information about who marked the thread as unresolved and when.

LANGUAGE: typescript
CODE:
// Schema
type ThreadMarkedAsUnresolvedEvent = {
  type: "threadMarkedAsUnresolved";
  data: {
    projectId: string;
    roomId: string;
    threadId: string;
    updatedAt: string;
    updatedBy: string;
  };
};

// Example
const ThreadMarkedAsUnresolvedEvent = {
  type: "threadMarkedAsUnresolved",
  data: {
    projectId: "my-project-id",
    roomId: "my-room-id",
    threadId: "my-thread-id",
    updatedAt: "2021-10-06T01:45:56.558Z",
    updatedBy: "my-user-id",
  },
};

----------------------------------------

TITLE: Managing User Notification Settings with @liveblocks/node
DESCRIPTION: Demonstrates how to use the Node.js client to manage user notification settings server-side, including getting, updating, and deleting settings for specific users.

LANGUAGE: tsx
CODE:
import { Liveblocks } from "@liveblocks/node";
const liveblocks = new Liveblocks({ secret: "sk_xxx" });

const settings = await liveblocks.getNotificationSettings({ userId });
// { email: { thread: true, ... }, slack: { thread: false, ... }, ... }
console.log(settings);

const updatedSettings = await liveblocks.updateNotificationSettings({
  userId,
  data: {
    teams: {
      $fileUploaded: true,
    },
  },
});
await liveblocks.deleteNotificationSettings({ userId });

----------------------------------------

TITLE: Equivalent Pattern for Accessing and Updating Presence
DESCRIPTION: Shows an alternative implementation equivalent to useMyPresence using a combination of useSelf and useUpdateMyPresence hooks.

LANGUAGE: tsx
CODE:
const myPresence = useSelf((me) => me.presence);
const updateMyPresence = useUpdateMyPresence();

----------------------------------------

TITLE: Installing @liveblocks/node Package via npm
DESCRIPTION: Command to install the @liveblocks/node package using npm. This package provides server-side utilities for setting up Liveblocks authentication endpoints.

LANGUAGE: bash
CODE:
npm install @liveblocks/node

----------------------------------------

TITLE: Displaying Notifications in a Collaborative App
DESCRIPTION: Implements notification UI components that show inbox notifications to users, particularly useful for displaying mention notifications.

LANGUAGE: tsx
CODE:
export function CollaborativeApp() {
  const { inboxNotifications } = useInboxNotifications();

  return (
    <InboxNotificationList>
      {inboxNotifications.map((inboxNotification) => (
        <InboxNotification
          key={inboxNotification.id}
          inboxNotification={inboxNotification}
        />
      ))}
    </InboxNotificationList>
  );
}

----------------------------------------

TITLE: Creating a Next.js API Endpoint for Webhook Handling
DESCRIPTION: Basic Next.js route handler that receives webhook POST requests, extracts the headers and body, and returns a 200 status code. This serves as the foundation for the webhook endpoint.

LANGUAGE: typescript
CODE:
export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Handle webhooks and database
  // ...

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Basic Zustand Store Without Liveblocks Middleware in TypeScript
DESCRIPTION: Example of a simple Zustand store for a To-do list application without using Liveblocks middleware. Defines a State type with properties for managing a draft, typing status, todos array, and methods for manipulating todos.

LANGUAGE: typescript
CODE:
import create from "zustand";

type State = {
  draft: string;
  isTyping: boolean;
  todos: Todo[];
  setDraft: (draft: string) => void;
  addTodo: () => void;
  deleteTodo: (index: number) => void;
};

create<State>(/* ... */);

----------------------------------------

TITLE: Implementing Zustand Store with Liveblocks Middleware
DESCRIPTION: Shows how to integrate Liveblocks middleware with a Zustand store. This example demonstrates moving the State type parameter to the middleware level and configuring presence and storage mappings for real-time collaboration.

LANGUAGE: typescript
CODE:
import create from "zustand";
import { createClient } from "@liveblocks/client";
import { middleware } from "@liveblocks/zustand";

const client = createClient({ /*...*/ });

type State = {
  draft: string;
  isTyping: boolean;
  todos: Todo[];
  setDraft: (draft: string) => void;
  addTodo: () => void;
  deleteTodo: (index: number) => void;
};

create(
  middleware<State>(/* ... */, {
    client,
    presenceMapping: { isTyping: true },
    storageMapping: { todos: true }
  })
);

----------------------------------------

TITLE: Problematic Component State Initialization Pattern in 0.16
DESCRIPTION: Example of the now-deprecated pattern where two components initialize the same storage key with different values, leading to unpredictable behavior.

LANGUAGE: tsx
CODE:
function ComponentA() {
  const author = useObject("author", {
    firstName: "Ada",
    lastName: "Lovelace",
  });

  /* ... */
}

function ComponentB() {
  const author = useObject("author", {
    firstName: "Margaret",
    lastName: "Hamilton",
  });

  /* ... */
}

----------------------------------------

TITLE: Simplifying Component Imports and Type Annotations in Liveblocks React
DESCRIPTION: Shows how to update component imports and remove explicit type annotations. The new pattern imports hooks directly from a configuration file instead of the library and removes unnecessary type parameters.

LANGUAGE: tsx
CODE:
import { useMyPresence, useOthers, useObject } from "@liveblocks/react";
import { Author } from "./types";

type MyPresence = {
  cursor: { x: number; y: number } | null;
};

function Component() {
  const author = useObject<Author>("author");
  const [{ cursor }] = useMyPresence<MyPresence>();
  const others = useOthers<Presence>();
}

LANGUAGE: tsx
CODE:
import { useMyPresence, useOthers, useObject } from "./liveblocks.config";

function Component() {
  const author = useObject("author");
  const [{ cursor }] = useMyPresence();
  const others = useOthers();
}

----------------------------------------

TITLE: Using LiveblocksProvider Instead of createClient
DESCRIPTION: Example showing how to use the new LiveblocksProvider component introduced in version 2.0, which replaces the createClient approach for setting up Liveblocks.

LANGUAGE: typescript
CODE:
// ❌ Before
const client = createClient(/* options */);

// ✅ After
<LiveblocksProvider /* options */>
  <App />
</LiveblocksProvider>

----------------------------------------

TITLE: Retrieving the ProseMirror editor state
DESCRIPTION: Access the raw ProseMirror editor state from a document using the getEditorState method, allowing for advanced manipulations using the ProseMirror API.

LANGUAGE: typescript
CODE:
const editorState = await withProsemirrorDocument(
  { roomId: "my-room-id", client: liveblocks },
  async (api) => {
    // +++
    return api.getEditorState();
    // +++
  }
);

----------------------------------------

TITLE: Configuring Liveblocks Client with Authentication Endpoint
DESCRIPTION: Sets up the Liveblocks client to use the authentication endpoint instead of a public API key for secure access control.

LANGUAGE: typescript
CODE:
import { createClient } from "@liveblocks/client";

const client = createClient({
  authEndpoint: "/api/liveblocks-auth",
});

----------------------------------------

TITLE: Defining User Metadata Types in Liveblocks Config
DESCRIPTION: Type definitions for user metadata in the Liveblocks configuration file. This defines the structure of the user information that will be attached to each user.

LANGUAGE: typescript
CODE:
declare global
  interface Liveblocks {
    UserMeta: {
      id: string;

      // Example, use any JSON-compatible data in your metadata
      info: {
        name: string;
        avatar: string;
        colors: string[];
      }
    }

    // Other type definitions
    // ...
  }
}

----------------------------------------

TITLE: Accessing Liveblocks Room Storage
DESCRIPTION: Shows how to get the Storage of a Liveblocks room asynchronously. The promise resolves once the root LiveObject is loaded and available.

LANGUAGE: typescript
CODE:
const { root } = await room.getStorage();

----------------------------------------

TITLE: Implementing Data Synchronization with Supabase
DESCRIPTION: Complete implementation of a webhook handler that retrieves Storage document data from Liveblocks and inserts it into a Supabase Postgres database. Includes verification, error handling, and database operations.

LANGUAGE: typescript
CODE:
import { WebhookHandler } from "@liveblocks/node";
import { createClient } from "@supabase/supabase-js";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";

// Create a Supabase client
const supabase = createClient(
  "YOUR_SUPABASE_PROJECT_URL",
  "YOUR_SUPABASE_PUBLIC_ANON_KEY"
);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When Storage document data has been updated
  if (event.type === "storageUpdated") {
    const { roomId } = event.data;

    // Get Storage data from Liveblocks REST API
    const url = `https://api.liveblocks.io/v2/rooms/${roomId}/storage`;
    const response = await fetch(url, {
      headers: { Authorization: `Bearer ${API_SECRET}` },
    });

    if (!response.ok) {
      return new Response("Problem accessing Liveblocks REST APIs", {
        status: 500,
      });
    }

    // Your JSON Storage document data as a string
    const storageData = await response.text();

    // Update database
    const { data, error } = await supabase
      .from("documents")
      .insert({ roomid: roomId, storagedata: storageData })
      .select();

    if (error) {
      return new Response("Problem inserting data into database", {
        status: 500,
      });
    }
  }

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Displaying threads with FloatingThreads using useThreads hook
DESCRIPTION: Implementation showing how to retrieve threads with the useThreads hook and display them using the FloatingThreads component in a BlockNote editor.

LANGUAGE: tsx
CODE:
// +++
import { useThreads } from "@liveblocks/react/suspense";
// +++
import {
  FloatingComposer,
  // +++
  FloatingThreads,
  // +++
  useCreateBlockNoteWithLiveblocks,
} from "@liveblocks/react-blocknote";
import { BlockNoteView } from "@blocknote/mantine";

function TextEditor() {
  const editor = useCreateBlockNoteWithLiveblocks({});

  // +++
  const { threads } = useThreads();
  // +++

  return (
    <div>
      <BlockNoteView editor={editor} />
      <FloatingComposer editor={editor} style={{ width: "350px" }} />
      // +++
      <FloatingThreads
        editor={editor}
        threads={threads}
        style={{ width: "350px" }}
      />
      // +++
    </div>
  );
}

----------------------------------------

TITLE: Subscribing to Storage Status Changes in TypeScript
DESCRIPTION: Example of using room.subscribe() to listen for storage status changes. The code demonstrates how to handle different storage states including not-loaded, loading, synchronizing, and synchronized.

LANGUAGE: typescript
CODE:
room.subscribe("storage-status", (status) => {
  switch (status) {
    case "not-loaded":
      break;
    case "loading":
      break;
    case "synchronizing":
      break;
    case "synchronized":
      break;
    default:
      break;
  }
});

----------------------------------------

TITLE: Accessing User Information in Svelte Component
DESCRIPTION: Example of how to access the authenticated user's ID and custom information in a Svelte component using the Liveblocks room object.

LANGUAGE: typescript
CODE:
const self = room.getSelf();
console.log(self.id);
console.log(self.info.color);

----------------------------------------

TITLE: Converting Local URL to Localtunnel URL for Webhooks
DESCRIPTION: Example of how to transform a localhost URL into a publicly accessible URL using localtunnel for testing Liveblocks webhooks in a development environment.

LANGUAGE: shell
CODE:
# Take your local URL
http://localhost:3000/api/liveblocks-notifications

# Replace localhost with the generated domain, then copy it
https://my-localtunnel-url.loca.lt/api/liveblocks-notifications

----------------------------------------

TITLE: Configuring Environment Variables for Liveblocks E2E Tests
DESCRIPTION: Essential environment variables needed in the .env.local file to connect to Liveblocks API for testing. Includes the secret key, public key, and base URL for the Liveblocks API.

LANGUAGE: dotenv
CODE:
LIVEBLOCKS_SECRET_KEY=YOUR_SECRET_KEY
NEXT_PUBLIC_LIVEBLOCKS_PUBLIC_KEY=YOUR_PUBLIC_KEY
NEXT_PUBLIC_LIVEBLOCKS_BASE_URL=https://api.liveblocks.io/v7

----------------------------------------

TITLE: Starting an Authentication Session for a User
DESCRIPTION: This code initiates an authentication session for a user with a unique ID. It optionally includes user information that will be available to other clients in the room.

LANGUAGE: tsx
CODE:
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "sk_prod_xxxxxxxxxxxxxxxxxxxxxxxx",
});

export async function POST(request) {
  const user = { id: "olivier@example.com", info: { name: "Olivier" }};

  const session = liveblocks.prepareSession(
    user.id,
    { userInfo: user.info } // Optional
  );
}

----------------------------------------

TITLE: Configuring allowOutsideRoom Option in useRoom Hook
DESCRIPTION: Example showing the usage of the optional allowOutsideRoom parameter in useRoom hook, which returns null when used outside a room instead of throwing an error.

LANGUAGE: typescript
CODE:
useRoom({ allowOutsideRoom: true })

----------------------------------------

TITLE: Installing Liveblocks Comments Email Notification Example with CLI
DESCRIPTION: Command to set up the Liveblocks comments notification email example project with automatic API key configuration. This creates a new project with all the necessary dependencies configured.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-comments-emails-resend --api-key

----------------------------------------

TITLE: Subscribing to Storage Status Changes in TypeScript
DESCRIPTION: Example of using room.subscribe() to listen for storage status changes. The code demonstrates how to handle different storage states including not-loaded, loading, synchronizing, and synchronized.

LANGUAGE: typescript
CODE:
room.subscribe("storage-status", (status) => {
  switch (status) {
    case "not-loaded":
      break;
    case "loading":
      break;
    case "synchronizing":
      break;
    case "synchronized":
      break;
    default:
      break;
  }
});

----------------------------------------

TITLE: Authorizing a Liveblocks Session
DESCRIPTION: Finalizes the session by making an HTTP call to Liveblocks servers to get a signed access token that can be returned to the client.

LANGUAGE: typescript
CODE:
// Requests the Liveblocks servers to authorize this session
const { body, status } = await session.authorize();
return new Response(body, { status });

----------------------------------------

TITLE: Setting Initial Presence in RoomProvider
DESCRIPTION: Configuration of RoomProvider in App.tsx to set an initial presence value with cursor set to null, indicating users start with cursors off-screen.

LANGUAGE: tsx
CODE:
<RoomProvider id={roomId} initialPresence={{ cursor: null }}>

----------------------------------------

TITLE: Optional Field Updates Example
DESCRIPTION: Shows valid and invalid operations with optional fields. Demonstrates that optional fields can be deleted while required fields cannot be removed.

LANGUAGE: typescript
CODE:
// ✅
root.delete("age");

// ❌ Field 'name' is not optional
root.delete("name");

----------------------------------------

TITLE: Installing the Collaborative Text Editor Example with Liveblocks CLI
DESCRIPTION: Command to set up the collaborative text editor example using the Liveblocks CLI. This automatically downloads the example and helps set up your API key from your Liveblocks account.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-yjs-quill --api-key

----------------------------------------

TITLE: Creating Liveblocks Client with preventUnsavedChanges Option
DESCRIPTION: Shows how to create a Liveblocks client with the preventUnsavedChanges option that prevents browser tabs from being closed while changes are pending synchronization.

LANGUAGE: javascript
CODE:
createClient({ preventUnsavedChanges: true })

----------------------------------------

TITLE: Adding a LiveObject to Liveblocks Storage
DESCRIPTION: Shows how to add a new LiveObject to Storage using the root LiveObject's set method. This example creates a person object and adds it to the Storage root.

LANGUAGE: typescript
CODE:
import { LiveObject } from "@liveblocks/client";

const { root } = await room.getStorage();

const person = new LiveObject({ name: "Alicia" });
root.set("person", person);

----------------------------------------

TITLE: Updating Lexical Documents with doc.update Function
DESCRIPTION: Shows how to use the doc.update method to modify Lexical documents. This function is similar to Lexical's editor.update and allows for making changes that will be persisted and shared in realtime.

LANGUAGE: typescript
CODE:
await withLexicalDocument(
  { roomId: "my-room-id", client: liveblocks },
  async (doc) => {
    await doc.update(() => {
      // Make your modifications
      // ...
    });
  }
);

----------------------------------------

TITLE: Defining CustomNotificationEvent Schema and Example in TypeScript
DESCRIPTION: TypeScript definition for CustomNotificationEvent which is triggered 30 minutes after a user has been notified of a custom event and has not seen it. Custom notification kinds are prefixed with '$' and manually triggered by the developer on the server.

LANGUAGE: typescript
CODE:
// Schema
type CustomNotificationEvent = {
  type: "notification";
  data: {
    channel: "email";
    kind: "$yourKind"; // Can be any string starting with "$" as defined by the user
    projectId: string;
    roomId: string | null;
    userId: string;
    inboxNotificationId: string;
    createdAt: string;
  };
};

// Example
const customNotificationEvent = {
  type: "notification",
  data: {
    channel: "email",
    kind: "$fileUpload",
    projectId: "my-project-id",
    roomId: "my-room-id",
    userId: "my-user-id",
    inboxNotificationId: "my-inbox-notification-id",
    createdAt: "2021-10-06T01:45:56.558Z",
  },
};

----------------------------------------

TITLE: Using massMutateStorage Method for Multiple Rooms
DESCRIPTION: Shows how to use the new massMutateStorage method which can modify Storage for multiple rooms simultaneously.

LANGUAGE: javascript
CODE:
.massMutateStorage()

----------------------------------------

TITLE: Creating a Public Room in Liveblocks
DESCRIPTION: This snippet shows how to create a new room with public access levels using liveblocks.createRoom() with the defaultAccesses property set to allow writing.

LANGUAGE: typescript
CODE:
const room = await liveblocks.createRoom("a32wQXid4A9", {
  defaultAccesses: ["room:write"],
});

----------------------------------------

TITLE: Debugging Technique for Finding JSON Type Errors in TypeScript
DESCRIPTION: This code snippet shows a technique for identifying the root cause of JSON type errors by explicitly attempting to assign your custom Presence type to JsonObject, which will reveal specific type errors.

LANGUAGE: typescript
CODE:
import type { JsonObject } from "@liveblocks/client";

declare global {
  interface Liveblocks {
    Presence: MyPresence;
  }
}

// Quick debugging snippet to find root cause
const xxx: JsonObject = {} as MyPresence;
//    ^?
//    The error will appear here

----------------------------------------

TITLE: Accessing User Metadata with useSelf Hook
DESCRIPTION: Example of accessing user metadata in a React component using the useSelf hook from Liveblocks. This demonstrates how to retrieve the user information set in the authentication endpoint.

LANGUAGE: tsx
CODE:
export { useSelf } from "@liveblocks/react/suspense";

function Component() {
  const { name, avatar, colors } = useSelf((me) => me.info);
}

----------------------------------------

TITLE: Adding Redux Provider to React Application
DESCRIPTION: Wraps the React application with Redux Provider to make the store available throughout the component tree, enabling Redux state and actions in all components.

LANGUAGE: javascript
CODE:
import React from "react";
import ReactDOM from "react-dom";
import "./index.css";
import App from "./App";

import { Provider } from "react-redux";
import store from "./store";

ReactDOM.render(
  <React.StrictMode>
    <Provider store={store}>
      <App />
    </Provider>
  </React.StrictMode>,
  document.getElementById("root")
);

----------------------------------------

TITLE: Installing Liveblocks Node Package
DESCRIPTION: Command to install the @liveblocks/node package which is required for server-side authentication.

LANGUAGE: bash
CODE:
npm install @liveblocks/node

----------------------------------------

TITLE: Installing Liveblocks, Yjs, and Quill Packages
DESCRIPTION: Command to install all required dependencies for a collaborative text editor, including Liveblocks client packages, Yjs, Quill, and related integration libraries.

LANGUAGE: bash
CODE:
npm install @liveblocks/client @liveblocks/react @liveblocks/yjs yjs quill quill-cursors react-quill y-quill

----------------------------------------

TITLE: Importing Hooks Directly in Liveblocks 2.0
DESCRIPTION: Shows the improved approach for importing Liveblocks hooks directly from the package rather than from a configuration file, demonstrating the simplified import pattern in version 2.0.

LANGUAGE: typescript
CODE:
// ❌ Before: get hooks exported from your Liveblocks config
import { RoomProvider, useRoom, ... } from "./liveblocks.config";

// ✅ After: import hooks directly
import { RoomProvider, useRoom, ... } from "@liveblocks/react";
import { RoomProvider, useRoom, ... } from "@liveblocks/react/suspense";

----------------------------------------

TITLE: Using useUpdateNotificationSettings Hook in React
DESCRIPTION: Shows how to use the useUpdateNotificationSettings hook to update notification settings such as unsubscribing from notifications.

LANGUAGE: tsx
CODE:
// A suspense version of this hook is available
import { useUpdateNotificationSettings } from "@liveblocks/react";

const updateSettings = useUpdateNotificationSettings();

const onUnsubscribe = () => {
  updateSettings({
    slack: {
      thread: false,
    },
  });
};

----------------------------------------

TITLE: Using Scalar Types in Liveblocks Schema
DESCRIPTION: Shows how to define a schema using basic scalar types (string, number, boolean, null). This example creates a Storage type with name, age, hasSiblings and an optional favoritePet field.

LANGUAGE: typescript
CODE:
type Storage {
  name: string
  age: number
  hasSiblings: boolean
  favoritePet: string | null
}

----------------------------------------

TITLE: Using iterInboxNotifications Method for Automatic Pagination
DESCRIPTION: Shows how to use the new iterInboxNotifications method which handles pagination automatically compared to getInboxNotifications.

LANGUAGE: javascript
CODE:
.iterInboxNotifications()

----------------------------------------

TITLE: Using useIsThreadActive Hook with Liveblocks Lexical
DESCRIPTION: This snippet shows how to use the useIsThreadActive hook to determine if a thread annotation is selected in the Lexical editor. The hook takes a thread ID and must be used within a component nested inside LiveblocksPlugin.

LANGUAGE: typescript
CODE:
import { useIsThreadActive } from "@liveblocks/react-lexical";

const isActive = useIsThreadActive(thread.id);

----------------------------------------

TITLE: Implementing Live Avatars Component with Liveblocks
DESCRIPTION: This component displays avatars for all users currently online in the collaborative editor. It uses Liveblocks' useOthers and useSelf hooks to retrieve user information and render avatars with tooltips showing user names.

LANGUAGE: tsx
CODE:
import { useOthers, useSelf } from "@/liveblocks.config";
import styles from "./Avatars.module.css";

export function Avatars() {
  const users = useOthers();
  const currentUser = useSelf();

  return (
    <div className={styles.avatars}>
      {users.map(({ connectionId, info }) => {
        return (
          <Avatar key={connectionId} picture={info.picture} name={info.name} />
        );
      })}

      {currentUser && (
        <div className="relative ml-8 first:ml-0">
          <Avatar
            picture={currentUser.info.picture}
            name={currentUser.info.name}
          />
        </div>
      )}
    </div>
  );
}

export function Avatar({ picture, name }: { picture: string; name: string }) {
  return (
    <div className={styles.avatar} data-tooltip={name}>
      <img
        src={picture}
        className={styles.avatar_picture}
        data-tooltip={name}
      />
    </div>
  );
}

----------------------------------------

TITLE: Using Suspense with Liveblocks Hooks
DESCRIPTION: Example of using Suspense version of Liveblocks hooks that simplifies error and loading state management. The component shows how to wrap your components with ErrorBoundary and ClientSideSuspense components.

LANGUAGE: tsx
CODE:
import { ClientSideSuspense } from "@liveblocks/react";
import { ErrorBoundary } from "react-error-boundary";

// Handle errors and loading state in the component above
function Component() {
  return (
    <ErrorBoundary fallback={<div>Error</div>}>
      <ClientSideSuspense fallback={<div>Loading...</div>}>
        <MyThreads />
      </ClientSideSuspense>
    </ErrorBoundary>
  );
}

----------------------------------------

TITLE: Implementing Text Mention Notification Emails with Resend Integration
DESCRIPTION: This snippet shows a complete implementation of a webhook handler that processes text mention notifications and sends emails using Resend. It includes verifying webhook requests, checking user access, preparing email content with customized components, and sending the email notification.

LANGUAGE: tsx
CODE:
import {
  Liveblocks,
  WebhookHandler,
  isTextMentionNotificationEvent,
} from "@liveblocks/node";
import { prepareTextMentionNotificationEmailAsReact } from "@liveblocks/emails";
// +++
import { Resend } from "resend";
// +++

// +++
// Create Resend client (add your API key)
const resend = new Resend("re_123456789");
// +++

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";
const liveblocks = new Liveblocks({ secret: API_SECRET });

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When an inbox notification has been created on the email channel
  if (isTextMentionNotificationEvent(event) && event.data.channel === "email") {
    // Check if user has access to room
    if (!__hasRoomAccess__(event.userId, event.roomId)) {
      return new Response(null, { status: 200 });
    }

    // The user to send the email to
    const emailAddress = __getEmailAddressFromDB__(event.userId);

    let emailData;

    try {
      emailData = await prepareTextMentionNotificationEmailAsReact(
        liveblocks,
        event,
        {
          resolveUsers: async ({ userIds }) => {
            const usersData = await __getUsersFromDB__(userIds);

            return usersData.map((userData) => ({
              name: userData.name, // "Chris"
              avatar: userData.avatar.src, // "https://example.com/chris.jpg"
            }));
          },
          resolveRoomInfo: async ({ roomId }) => {
            const roomData = await __getRoomFromDB__(roomId);

            return {
              name: roomData.name, // "Untitled document"
              url: roomData.url, //`https://example.com/my-room-id`
            };
          },
          components: {
            Container: ({ children }) => (
              <main style={{ margin: "12px 0" }}>{children}</main>
            ),

            // `user` is the optional data returned from `resolveUsers`
            Mention: ({ element, user }) => (
              <span style={{ color: "red" }}>@{user?.name ?? element.id}</span>
            ),
          },
        }
      );
    } catch (err) {
      console.log(err);
      return new Response("Could not fetch text mention notification data", {
        status: 500,
      });
    }

    // The text mention has already been read
    if (!emailData) {
      return new Response(null, { status: 200 });
    }

    const email = (
      <div>
        <div>
          @{emailData.mention.author.id} at {emailData.mention.createdAt}
        </div>
        <div>{emailData.mention.reactContent}</div>
      </div>
    );

    // +++
    // Send email to the user's email address
    try {
      const data = await resend.emails.send({
        from: "My company <hello@my-company.com>",
        to: emailAddress,
        subject: "New text mention",
        react: email,
      });
    } catch (err) {
      console.error(err);
    }
    // +++
  }

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Corrected RoomInfo Type Definition in TypeScript
DESCRIPTION: The fixed version of the RoomInfo type definition that uses string instead of URL for the url field, making it valid according to Liveblocks requirements for JSON-serializable values.

LANGUAGE: tsx
CODE:
declare global {
  interface Liveblocks {
    RoomInfo: {
      // Your custom fields go here...
      name: string;
      url: string; // ✅ Valid
      geo: {
        city: string;
        country: string;
      };
    };
  }
}

----------------------------------------

TITLE: Installing Liveblocks, Yjs, and Tiptap Packages
DESCRIPTION: Command to install all necessary packages for implementing a collaborative text editor with Liveblocks, Yjs, and Tiptap. Includes core dependencies and collaboration extensions.

LANGUAGE: bash
CODE:
npm install @liveblocks/client @liveblocks/yjs yjs @tiptap/core @tiptap/pm @tiptap/starter-kit @tiptap/extension-collaboration @tiptap/extension-collaboration-cursor y-prosemirror

----------------------------------------

TITLE: Installing @liveblocks/node 1.0.0 with npm
DESCRIPTION: Command to update the @liveblocks/node package to version 1.0.0 using npm package manager.

LANGUAGE: bash
CODE:
npm install @liveblocks/node@1.0.0

----------------------------------------

TITLE: TypeScript Room Status Type Example
DESCRIPTION: Example of the connection status types returned by room.getStatus() method, showing the mapping between old deprecated status codes and new status codes.

LANGUAGE: typescript
CODE:
| ❌ Old statuses | ✅ New statuses |
| --------------- | --------------- |
| closed          | initial         |
| authenticating  | connecting      |
| connecting      | connecting      |
| open            | connected       |
| unavailable     | reconnecting    |
| failed          | disconnected    |

----------------------------------------

TITLE: Deploying Liveblocks Comments with OpenAI on Vercel
DESCRIPTION: Command to download the example project and deploy it directly to Vercel. This opens your browser to complete the Vercel deployment process and links it to your Liveblocks account.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-comments-ai --vercel

----------------------------------------

TITLE: Styling HTML Elements in Liveblocks Thread Notification Emails
DESCRIPTION: Demonstration of how to apply custom CSS styles to different elements in the comment body of notification emails. This allows customization of paragraphs, code blocks, strong text, mentions, and links to match your application's design.

LANGUAGE: tsx
CODE:
const emailData = await prepareThreadNotificationEmailAsHtml(
  liveblocks,
  webhookEvent,
  {
    // +++
    styles: {
      paragraph: { margin: "12px 0" },

      mention: {
        fontWeight: "bold",
        color: "red",
      },

      link: {
        textDecoration: "underline",
      },
    },
    // +++
  }
);

// { type: "unreadMention", comment: { ... }, ... }
console.log(emailData);

// The elements in the comment body are now styled
console.log(emailData.comment.body);

----------------------------------------

TITLE: Installing the Collaborative Text Editor Example with create-liveblocks-app
DESCRIPTION: Command to set up the collaborative text editor example project locally. It downloads the example and helps configure your Liveblocks API key through an interactive process.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-yjs-slate --api-key

----------------------------------------

TITLE: Updating Cursor Position with Liveblocks Presence in React Component
DESCRIPTION: React component that enters a Liveblocks room and updates the cursor position in the store when the pointer moves. This enables real-time sharing of cursor position with other users.

LANGUAGE: tsx
CODE:
import React, { useEffect } from "react";
import useStore from "./store";

import "./App.css";

const App = () => {
  const {
    liveblocks: { enterRoom, leaveRoom },
  } = useStore();

  useEffect(() => {
    enterRoom("room-id");
    return () => {
      leaveRoom("room-id");
    };
  }, [enterRoom, leaveRoom]);

  const setCursor = useStore((state) => state.setCursor);
  return (
    <div
      style={{ width: "100vw", height: "100vh" }}
      onPointerMove={(e) => setCursor({ x: e.clientX, y: e.clientY })}
    />
  );
};

export default App;

----------------------------------------

TITLE: Attaching User Metadata in Authentication
DESCRIPTION: Updated authentication endpoint code that includes user metadata in the identifyUser call. This makes user information available to client-side components.

LANGUAGE: typescript
CODE:
// Get the current user from your database
const user = __getUserFromDB__(request);

// Identify the user and return the result
const { status, body } = await liveblocks.identifyUser(
  {
    userId: user.id,
    groupIds, // Optional
  },
  {
    userInfo: {
      name: user.name,
      avatar: user.avatarUrl,
      colors: user.colorArray,
    }
  },
);

----------------------------------------

TITLE: Importing Required Styles in Next.js Layout
DESCRIPTION: Importing all necessary stylesheets for BlockNote and Liveblocks in the Next.js layout file, including fonts, core styles, and theme-specific styles.

LANGUAGE: tsx
CODE:
import "@blocknote/core/fonts/inter.css";
import "@blocknote/mantine/style.css";
import "@liveblocks/react-ui/styles.css";
import "@liveblocks/react-ui/styles/dark/media-query.css";
import "@liveblocks/react-tiptap/styles.css";
import "./globals.css";

----------------------------------------

TITLE: Using upsertRoom Method in Node SDK
DESCRIPTION: Shows how to use the new upsertRoom method which optimizes to only make a single round-trip to the server.

LANGUAGE: javascript
CODE:
.upsertRoom()

----------------------------------------

TITLE: Updating Room with Group Access Permissions in Liveblocks
DESCRIPTION: This snippet shows how to update a room to give read-only access with presence writing capabilities to the 'engineering' group using liveblocks.updateRoom().

LANGUAGE: typescript
CODE:
const room = await liveblocks.updateRoom("a32wQXid4A9", {
  groupsAccesses: {
    engineering: ["room:read", "room:presence:write"],
  },
});

----------------------------------------

TITLE: Installing Dependencies for React Redux Whiteboard
DESCRIPTION: Commands to create a new React application and install necessary dependencies including Redux and Liveblocks packages for building a collaborative whiteboard.

LANGUAGE: bash
CODE:
npx create-react-app redux-whiteboard

LANGUAGE: bash
CODE:
npm install redux react-redux @reduxjs/toolkit @liveblocks/client @liveblocks/redux

----------------------------------------

TITLE: Simplifying Component Imports in Liveblocks 2.0
DESCRIPTION: Shows how component imports have been simplified in Liveblocks 2.0. Instead of importing hooks from a local config file, they can now be imported directly from the Liveblocks packages.

LANGUAGE: tsx
CODE:
// ❌ Before
import { RoomProvider, useRoom, useThreads } from "./liveblocks.config.ts";

// ✅ After
import { RoomProvider, useRoom, useThreads } from "@liveblocks/react/suspense";
// or
import { RoomProvider, useRoom, useThreads } from "@liveblocks/react";

----------------------------------------

TITLE: Defining Documentation Hero Component in JSX
DESCRIPTION: This JSX code renders a hero section for the documentation homepage with a title, description, and action buttons for getting started and browsing examples.

LANGUAGE: jsx
CODE:
<DocsHomepageHero
  title="Documentation"
  description="Liveblocks is the platform for adding collaborative editing, comments, and notifications into your application."
  actions={[
    {
      title: "Get started",
      href: "/docs/get-started",
      appearance: "primary",
    },
    {
      title: "Browse examples",
      href: "/examples",
    },
  ]}
/>

----------------------------------------

TITLE: Optimizing History with Pause and Resume
DESCRIPTION: Enhances the undo/redo functionality by pausing history during drag operations and resuming it after completion. This prevents intermediate positions from being added to the history stack, creating a smoother undo experience where shapes return to their starting position.

LANGUAGE: javascript
CODE:
import { useEffect } from "react";
import "./App.css";
import { useDispatch, useSelector } from "react-redux";
import { actions } from "@liveblocks/redux";

import {
  insertRectangle,
  onShapePointerDown,
  deleteShape,
  onCanvasPointerUp,
  onCanvasPointerMove,
  client,
} from "./store";

const roomId = "redux-whiteboard";

export default function App() {
  const shapes = useSelector((state) => state.shapes);
  const isLoading = useSelector((state) => state.liveblocks.isStorageLoading);
  const selectedShape = useSelector((state) => state.selectedShape);
  const others = useSelector((state) => state.liveblocks.others);

  const dispatch = useDispatch();

  /* ... */

  return (
    <>
      <div
        className="canvas"
        onPointerMove={(e) => {
          /* ... */
        }}
        onPointerUp={() => {
          dispatch(onCanvasPointerUp());
          client.getRoom(roomId).history.resume();
        }}
      >
        {/* ... */}
      </div>
      <div className="toolbar">{/* ... */}</div>
    </>
  );
}

const Rectangle = ({ shape, selectionColor, id }) => {
  const dispatch = useDispatch();

  return (
    <div
      className="rectangle"
      style={{
        transform: `translate(${shape.x}px, ${shape.y}px)`,
        backgroundColor: shape.fill ? shape.fill : "#CCC",
        borderColor: selectionColor,
      }}
      onPointerDown={(e) => {
        e.stopPropagation();
        client.getRoom(roomId).history.pause();
        dispatch(onShapePointerDown(id));
      }}
    ></div>
  );
};

----------------------------------------

TITLE: Using Pagination with useInboxNotifications Hook in React
DESCRIPTION: Example of using the pagination features added in version 2.9.0 with the useInboxNotifications hook, showing all available properties including fetchMore and status indicators.

LANGUAGE: tsx
CODE:
const {
  inboxNotifications,
  isLoading,
  error,

  // ✨ New in Liveblocks 2.9
  fetchMore,
  isFetchingMore,
  hasFetchedAll,
  fetchMoreError,
} = useInboxNotifications();

----------------------------------------

TITLE: Using useStatus Hook to Monitor WebSocket Connection Status
DESCRIPTION: Demonstrates how to use the useStatus hook to monitor the WebSocket connection status of a Liveblocks room. This hook re-renders the component whenever the connection status changes.

LANGUAGE: ts
CODE:
import { useStatus } from "@liveblocks/react/suspense";

const status = useStatus();

----------------------------------------

TITLE: Pagination Support in getInboxNotifications Method
DESCRIPTION: Shows how to use the pagination support added to the getInboxNotifications method in the Node SDK.

LANGUAGE: javascript
CODE:
.getInboxNotifications()

----------------------------------------

TITLE: ThreadOverlay with ClientSideSuspense
DESCRIPTION: Implementation showing how to wrap ThreadOverlay in ClientSideSuspense to prevent it from rendering until threads have loaded, providing a smoother user experience with proper loading state handling.

LANGUAGE: tsx
CODE:
<LexicalComposer initialConfig={initialConfig}>
  <LiveblocksPlugin>
    <FloatingComposer />
    // +++
    <ClientSideSuspense fallback={null}>
      <ThreadOverlay />
    </ClientSideSuspense>
    // +++
  </LiveblocksPlugin>
</LexicalComposer>

----------------------------------------

TITLE: Finding Mismatched Liveblocks Package Versions with npm
DESCRIPTION: This command lists all installed Liveblocks packages and their versions, allowing you to identify version mismatches across different @liveblocks packages in your project.

LANGUAGE: bash
CODE:
npm ls | grep @liveblocks

----------------------------------------

TITLE: Implementing New Room API in Liveblocks Client
DESCRIPTION: Demonstrates the new recommended API for entering and leaving rooms in Liveblocks client. This supports multiple connections to the same room from different parts of an application.

LANGUAGE: typescript
CODE:
// New API we'll be recommending instead
const { room, leave } = client.enterRoom("my-room", options);
leave();

----------------------------------------

TITLE: CSS Styling for Text Editor Toolbar
DESCRIPTION: CSS module for styling the formatting toolbar in the Slate editor. Defines styles for the toolbar container and buttons, including hover, focus, and active states.

LANGUAGE: css
CODE:
.toolbar {
  display: flex;
  padding: 1em;
  gap: 6px;
}

.button {
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  border-radius: 6px;
  height: 32px;
  width: 32px;
  background: #fff;
  color: #1f2937;
  border: none;
  box-shadow:
    rgba(0, 0, 0, 0.12) 0 4px 8px 0,
    rgba(0, 0, 0, 0.02) 0 0 0 1px;
}

.button:hover {
  color: #111827;
  box-shadow:
    rgba(0, 0, 0, 0.16) 0 5px 8px 0,
    rgba(0, 0, 0, 0.04) 0 0 0 1px;
}

.button:focus-visible {
  outline-offset: 2px;
}

.button:active {
  box-shadow:
    rgba(0, 0, 0, 0.16) 0 2px 3px 0,
    rgba(0, 0, 0, 0.04) 0 0 0 1px;
}

.button[data-active] {
  background: #fafafa;
}

----------------------------------------

TITLE: Updating RoomInfo to RoomData Type References
DESCRIPTION: Shows how to update code after the RoomInfo type in @liveblocks/node was renamed to RoomData to avoid confusion with the new custom RoomInfo type.

LANGUAGE: tsx
CODE:
// ❌ Before
import { RoomInfo } from "@liveblocks/node";
const rooms: RoomInfo[] = [];

// ✅ After
import { RoomData } from "@liveblocks/node";
const rooms: RoomData[] = [];

----------------------------------------

TITLE: Initializing Liveblocks Configuration File
DESCRIPTION: Creates a liveblocks.config.ts file that can be used for defining types and configuring the Liveblocks environment. This is done using the create-liveblocks-app utility.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --init --framework javascript

----------------------------------------

TITLE: Using the useIsEditorReady Hook
DESCRIPTION: Basic usage of the useIsEditorReady hook to check if the Lexical editor content has been loaded, useful for implementing loading states or skeletons during content initialization.

LANGUAGE: ts
CODE:
import { useIsEditorReady } from "@liveblocks/react-lexical";

const status = useIsEditorReady();

----------------------------------------

TITLE: Configuring Suspense Hooks in Liveblocks Config File
DESCRIPTION: Example of how to export Suspense versions of hooks from the Liveblocks config file. This configuration enables the use of Suspense-compatible hooks in your components.

LANGUAGE: tsx
CODE:
// ...

export const {
  suspense: {
    // Export from here to use Suspense hooks
    useThreads,
    useUser,
  },
} = createRoomContext(client, {});

----------------------------------------

TITLE: Listening for Revalidation Events with Liveblocks
DESCRIPTION: Using Liveblocks' useEventListener hook to listen for REVALIDATE events and trigger SWR's mutate function to refresh data. When the custom event is received, the component will fetch fresh data from the API.

LANGUAGE: tsx
CODE:
const { data: users, mutate } = useSWR("/api/users", fetcher);

useEventListener(({ event }) => {
  if (event.type === "REVALIDATE") {
    mutate();
  }
});

----------------------------------------

TITLE: Initializing Liveblocks Configuration
DESCRIPTION: Command to initialize the Liveblocks configuration file for a React application using the Liveblocks CLI tool.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --init --framework react

----------------------------------------

TITLE: Using shouldInitiallyConnect with RoomProvider
DESCRIPTION: Code showing how to use the new shouldInitiallyConnect prop with RoomProvider to control whether the room connects to Liveblocks servers, useful for SSR environments.

LANGUAGE: tsx
CODE:
<RoomProvider
  id="room"
  initialPresence={{}}
  shouldInitiallyConnect={false} // 👈 control initial connection to Liveblocks
>
  <App />
</RoomProvider>

----------------------------------------

TITLE: Integrating Zustand with Liveblocks Middleware in TypeScript
DESCRIPTION: Example showing how to integrate a Zustand store with Liveblocks middleware. Demonstrates moving the State type parameter to the middleware level and configuring presence and storage mappings for real-time collaboration.

LANGUAGE: typescript
CODE:
import create from "zustand";
import { createClient } from "@liveblocks/client";
import { middleware } from "@liveblocks/zustand";

const client = createClient({ /*...*/ });

type State = {
  draft: string;
  isTyping: boolean;
  todos: Todo[];
  setDraft: (draft: string) => void;
  addTodo: () => void;
  deleteTodo: (index: number) => void;
};

create(
  middleware<State>(/* ... */, {
    client,
    presenceMapping: { isTyping: true },
    storageMapping: { todos: true }
  })
);

----------------------------------------

TITLE: Installing Liveblocks Canvas Comments Example
DESCRIPTION: Command to set up the Next.js Canvas Comments example with Liveblocks, which will download the project and prompt for API key authorization.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-comments-canvas --api-key

----------------------------------------

TITLE: Integrating Zustand Store with Liveblocks Middleware
DESCRIPTION: Example of integrating Liveblocks middleware with a Zustand store, showing how to move the State type parameter to the middleware level and configure presence and storage mappings.

LANGUAGE: typescript
CODE:
import create from "zustand";
import { createClient } from "@liveblocks/client";
import { middleware } from "@liveblocks/zustand";

const client = createClient({ /*...*/ });

type State = {
  draft: string;
  isTyping: boolean;
  todos: Todo[];
  setDraft: (draft: string) => void;
  addTodo: () => void;
  deleteTodo: (index: number) => void;
};

create(
  middleware<State>(/* ... */, {
    client,
    presenceMapping: { isTyping: true },
    storageMapping: { todos: true }
  })
);

----------------------------------------

TITLE: Using prepareThreadNotificationEmailAsHtml to Generate HTML Email Content in TypeScript
DESCRIPTION: This snippet demonstrates how to use prepareThreadNotificationEmailAsHtml to convert thread notification webhook events into HTML content for email notifications. It handles both unreadMention and unreadReplies notification types.

LANGUAGE: typescript
CODE:
import { prepareThreadNotificationEmailAsHtml } from "@liveblocks/emails";
import { isThreadNotificationEvent } from "@liveblocks/node";

// Get `liveblocks` and `event` (see "Setup" section)
// ...

if (isThreadNotificationEvent(event)) {
  // +++
  const emailData = await prepareThreadNotificationEmailAsHtml(
    liveblocks,
    event
  );
  // +++
  let email;

  switch (emailData.type) {
    case "unreadMention": {
      email = `
        <div>
          <div>
            @${emailData.comment.author.id} at ${emailData.comment.createdAt}
          </div>
          <div>${emailData.comment.body}</div>
        </div>
      `;
      break;
    }

    case "unreadReplies": {
      email = `
        <div>
          ${emailData.comments
            .map(
              (comment) => `
                <div>
                  <div>
                    @${comment.author.id} at ${comment.createdAt}
                  </div>
                  <div>${comment.body}</div>
                </div>
              `
            )
            .join("")}
        </div>
      `;
      break;
    }
  }
}

// Send your email
// ...

----------------------------------------

TITLE: Adding Rectangle Button to App Component
DESCRIPTION: Updates the App component to display shapes and adds a button that triggers insertRectangle function from the store when clicked. This allows users to add new rectangles to the whiteboard.

LANGUAGE: tsx
CODE:
import { useEffect } from "react";
import useStore from "./store";

import "./App.css";

export default function App() {
  const shapes = useStore((state) => state.shapes);
  const insertRectangle = useStore((state) => state.insertRectangle);

  /* ... */

  return (
    <>
      <div className="canvas">
        {Object.entries(shapes).map(([shapeId, shape]) => {
          return <Rectangle key={shapeId} shape={shape} />;
        })}
      </div>
      <div className="toolbar">
        <button onClick={insertRectangle}>Rectangle</button>
      </div>
    </>
  );
}

/* Rectangle */

----------------------------------------

TITLE: Installing Dependencies for Manual Setup
DESCRIPTION: Command to install all required dependencies for the project when setting up manually.

LANGUAGE: bash
CODE:
npm install

----------------------------------------

TITLE: Deploying to Vercel with Liveblocks
DESCRIPTION: Command to create a new Liveblocks application with the SvelteKit live avatars example and set up deployment to Vercel.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example sveltekit-live-avatars --vercel

----------------------------------------

TITLE: Handling Storage Update Events from Liveblocks Webhooks
DESCRIPTION: Extended webhook handler that checks for the 'storageUpdated' event type and extracts the roomId from the event data. This forms the foundation for database synchronization when Storage document changes occur.

LANGUAGE: typescript
CODE:
import { WebhookHandler } from "@liveblocks/node";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When Storage document data has been updated
  if (event.type === "storageUpdated") {
    const { roomId } = event.data;

    // Update database
    // ...
  }

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: CSS Variable Customization for AnchoredThreads
DESCRIPTION: CSS variables that can be used to modify the gap between threads and the horizontal offset applied when a thread is selected.

LANGUAGE: css
CODE:
.lb-tiptap-anchored-threads {
  /* Minimum gap between threads */
  --lb-tiptap-anchored-threads-gap: 8px;

  /* How far the active thread is offset to the left */
  --lb-tiptap-anchored-threads-active-thread-offset: 12px;
}

----------------------------------------

TITLE: Adding ClientSideSuspense for Loading State
DESCRIPTION: Extended React setup adding ClientSideSuspense to handle loading states while connecting to a Liveblocks room and rendering the collaborative editor component.

LANGUAGE: tsx
CODE:
"use client";

import {
  LiveblocksProvider,
  RoomProvider,
  ClientSideSuspense,
} from "@liveblocks/react/suspense";
import { Editor } from "./Editor";

export default function App() {
  return (
    <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>      <RoomProvider id="my-room">
        <ClientSideSuspense fallback={<div>Loading…</div>}>
          <Editor />
        </ClientSideSuspense>
      </RoomProvider>
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Basic Zustand Store Without Liveblocks Middleware
DESCRIPTION: Example of a basic Zustand store setup for a to-do list application without Liveblocks integration. It shows the typical pattern for defining state types and creating a store.

LANGUAGE: typescript
CODE:
import create from "zustand";

type State = {
  draft: string;
  isTyping: boolean;
  todos: Todo[];
  setDraft: (draft: string) => void;
  addTodo: () => void;
  deleteTodo: (index: number) => void;
};

create<State>(/* ... */);

----------------------------------------

TITLE: Accessing User Metadata with useSelf Hook
DESCRIPTION: Example of accessing user metadata in a React component using the useSelf hook from Liveblocks. This allows components to display user-specific information.

LANGUAGE: tsx
CODE:
export { useSelf } from "@liveblocks/react/suspense";

function Component() {
  const { name, avatar, colors } = useSelf((me) => me.info);
}

----------------------------------------

TITLE: Initializing Liveblocks Configuration File
DESCRIPTION: Command to create the initial Liveblocks configuration file which can be used later to define types for the application.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --init --framework javascript

----------------------------------------

TITLE: Managing User Notification Settings with Liveblocks Node.js Client
DESCRIPTION: Example showing how to use the Liveblocks Node.js client to manage user notification settings. The code demonstrates getting current settings, updating specific notification settings, and deleting notification settings for a user.

LANGUAGE: tsx
CODE:
import { Liveblocks } from "@liveblocks/node";
const liveblocks = new Liveblocks({ secret: "sk_xxx" });

const settings = await liveblocks.getNotificationSettings({ userId });
// { email: { thread: true, ... }, slack: { thread: false, ... }, ... }
console.log(settings);

const updatedSettings = await liveblocks.updateNotificationSettings({
  userId,
  data: {
    teams: {
      $fileUploaded: true,
    },
  },
});
await liveblocks.deleteNotificationSettings({ userId });

----------------------------------------

TITLE: Initializing Liveblocks Config File
DESCRIPTION: Command to initialize the Liveblocks configuration file with the React framework, creating the necessary setup for the client.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --init --framework react

----------------------------------------

TITLE: Deprecated Room Enter/Leave API Pattern in Liveblocks
DESCRIPTION: The old pattern for entering and leaving rooms in Liveblocks that is now deprecated but still supported. This shows how to manually enter a room with the client and then leave it.

LANGUAGE: tsx
CODE:
// ❌ We recommend you stop using this API
const room = client.enter("my-room", options);

// Then later, when unmounting
client.leave("my-room");

----------------------------------------

TITLE: Importing Liveblocks Default Styles
DESCRIPTION: Import statement for including the default CSS styles for Liveblocks React UI components in your application.

LANGUAGE: tsx
CODE:
import "@liveblocks/react-ui/styles.css";

----------------------------------------

TITLE: Installing Dependencies for Collaborative Text Editor
DESCRIPTION: Command to install all required packages including Tiptap, Yjs, and Liveblocks for building a collaborative text editor.

LANGUAGE: bash
CODE:
npm install @liveblocks/client @liveblocks/react @liveblocks/yjs yjs @tiptap/extension-collaboration @tiptap/extension-collaboration-cursor @tiptap/pm @tiptap/react @tiptap/starter-kit

----------------------------------------

TITLE: Using useNotificationSettings Hook in React
DESCRIPTION: Example demonstrating how to use the useNotificationSettings hook from @liveblocks/react to get and update user notification settings. This hook returns current settings and a function to update them.

LANGUAGE: tsx
CODE:
// A suspense version of this hook is available
import { useNotificationSettings } from "@liveblocks/react";

const [{ isLoading, error, settings }, updateSettings] =
  useNotificationSettings();
// { email: { thread: true, ... }, slack: { thread: false, ... }, ... }
console.log(settings);

const onSave = () => {
  updateSettings({
    slack: {
      textMention: true,
    },
  });
};

----------------------------------------

TITLE: Updating a ProseMirror document with transactions
DESCRIPTION: Use the api.update method to modify a ProseMirror document by applying a transaction. This example inserts "Hello world" text into the document.

LANGUAGE: typescript
CODE:
await withProsemirrorDocument(
  {
    client,
    roomId: "test-room",
  },
  async (api) => {
    // +++
    await api.update((doc, tr) => {
      return tr.insertText("Hello world");
    });
    // +++
  }
);

----------------------------------------

TITLE: Installing the Collaborative To-do List Example using create-liveblocks-app
DESCRIPTION: Command to download and set up the React Native to-do list example locally using the create-liveblocks-app CLI tool. This installation doesn't require an API key or Vercel setup initially.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example react-native-todo-list --no-api-key --no-vercel

----------------------------------------

TITLE: Importing React Tiptap and Liveblocks UI Stylesheets
DESCRIPTION: This code demonstrates how to import the required stylesheets for using React Tiptap with Liveblocks. Both the Liveblocks React UI stylesheet and the React Tiptap stylesheet must be imported for proper styling.

LANGUAGE: tsx
CODE:
import "@liveblocks/react-ui/styles.css";
import "@liveblocks/react-tiptap/styles.css";

----------------------------------------

TITLE: New Method: Accessing Nested Data with useStorage Selector
DESCRIPTION: Improved approach to access nested data using the new useStorage hook with a selector function, which returns normal JavaScript data structures.

LANGUAGE: tsx
CODE:
function Component() {
  const pets = useStorage((root) => root.scientist.pets);
  // ["🐶", "🐈"]
}

----------------------------------------

TITLE: Updating Notification Settings with useUpdateNotificationSettings
DESCRIPTION: Example of using the useUpdateNotificationSettings hook for simple notification preference updates, like creating an unsubscribe button functionality.

LANGUAGE: tsx
CODE:
// A suspense version of this hook is available
import { useUpdateNotificationSettings } from "@liveblocks/react";

const updateSettings = useUpdateNotificationSettings();

const onUnsubscribe = () => {
  updateSettings({
    slack: {
      thread: false,
    },
  });
};

----------------------------------------

TITLE: Defining Arrays in Liveblocks Schema
DESCRIPTION: Shows how to define array types in a Liveblocks schema. Defines an array of strings using the standard array syntax from TypeScript.

LANGUAGE: typescript
CODE:
type Storage {
  animals: string[]
}

----------------------------------------

TITLE: Configuring Liveblocks Types in TypeScript
DESCRIPTION: Example showing the improved DX by allowing global type specification in Liveblocks v2.0. This demonstrates the transition from explicitly passing types to each context creation to using global interface declarations.

LANGUAGE: typescript
CODE:
// ❌ Before
export const {
  suspense: {
    RoomProvider,
    useRoom,
    // etc
  },
} = createRoomContext<Presence, Storage>(client);

// ✅ After
declare global {
  interface Liveblocks {
    Presence: Presence;
    Storage: Storage;
  }
}

----------------------------------------

TITLE: Integrating Toolbar into Quill Editor Component
DESCRIPTION: This code snippet shows how to integrate the Toolbar component into the main Quill editor component. It includes a getQuill function that retrieves the current Quill editor instance and passes it to the Toolbar.

LANGUAGE: tsx
CODE:
import { Toolbar } from "./Toolbar";
// ...

function QuillEditor({ yText, provider }: EditorProps) {
  // ...

  // Function to get the current Quill editor
  const getQuill = useCallback(() => {
    if (!reactQuillRef.current) {
      return null;
    }

    return reactQuillRef.current.getEditor();
  }, []);

  return (
    <div className={styles.container}>
      <div className={styles.editorHeader}>
        <Toolbar getQuill={getQuill} />
      </div>
      <div className={styles.editorContainer}>{/* ... */}</div>
    </div>
  );
}

----------------------------------------

TITLE: StorageUpdatedEvent Schema in TypeScript
DESCRIPTION: TypeScript schema and example for the StorageUpdatedEvent webhook. This event is triggered when storage is updated, and is throttled to fire at most once every five seconds, consolidating multiple writes.

LANGUAGE: typescript
CODE:
// Schema
type StorageUpdatedEvent = {
  type: "storageUpdated";
  data: {
    roomId: string;
    projectId: string;
    updatedAt: string;
  };
};

// Example
const storageUpdatedEvent = {
  type: "storageUpdated",
  data: {
    projectId: "my-project-id",
    roomId: "my-room-id",
    updatedAt: "2021-10-06T01:45:56.558Z", // 👈 time of the last write
  },
};

----------------------------------------

TITLE: Configuring Liveblocks Client in Frontend
DESCRIPTION: Updates the frontend configuration to point to the new authentication endpoint for ID token verification.

LANGUAGE: ts
CODE:
import { createClient } from "@liveblocks/client";

const client = createClient({
  authEndpoint: "/api/liveblocks-auth",
});

----------------------------------------

TITLE: Setting Default Content in Tiptap with Yjs Using useEffect
DESCRIPTION: This solution shows the proper way to set default content in Tiptap when using Yjs by waiting for the provider to sync, checking if the editor is empty, and only then setting the default content.

LANGUAGE: tsx
CODE:
function Editor({ doc, provider }: EditorProps) {
  const editor = useEditor({
    // Options
    // ...
  });

  // Set default state
  useEffect(() => {
    function setDefault() {
      if (!editor) {
        return;
      }

      if (editor.getText() === "") {
        editor.commands.setContent(`
          <h1>Default content</h1>
          <p>
            My <strong>paragraph</strong>
          </p>
        `);
      }
    }

    setDefault();
    provider.on("sync", setDefault);
    return () => provider.off("sync", setDefault);
  }, [provider, editor]);

  return <EditorContent editor={editor} />;
}

----------------------------------------

TITLE: Running LocalTunnel for Testing Webhooks Locally
DESCRIPTION: Command to create a temporary public URL that forwards to your localhost server, allowing you to test webhooks during development without deploying.

LANGUAGE: bash
CODE:
npx localtunnel --port 3000

----------------------------------------

TITLE: Importing Required Styles in React Layout
DESCRIPTION: Sets up style imports in the application layout file, including BlockNote core fonts, Mantine styles, Liveblocks UI styles, and custom global styles for the collaborative text editor.

LANGUAGE: tsx
CODE:
import "@blocknote/core/fonts/inter.css";
import "@blocknote/mantine/style.css";
import "@liveblocks/react-ui/styles.css";
import "@liveblocks/react-ui/styles/dark/media-query.css";
import "@liveblocks/react-tiptap/styles.css";
import "./globals.css";

----------------------------------------

TITLE: Running room-info-to-room-data Codemod in Shell
DESCRIPTION: Executes the codemod that renames RoomInfo type from @liveblocks/node to RoomData.

LANGUAGE: shell
CODE:
npx @liveblocks/codemod@latest room-info-to-room-data

----------------------------------------

TITLE: Installing Live Form Selection Example with Liveblocks
DESCRIPTION: Command to create a new Liveblocks application with the live form selection example. This automatically downloads the example and helps set up your API key.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-live-form-selection --api-key

----------------------------------------

TITLE: Example Structure of Unread Replies Return Value
DESCRIPTION: This code snippet shows the structure of the data returned by prepareThreadNotificationEmailAsReact when handling unread replies notifications. It includes room ID and an array of comments, each with its formatted React content.

LANGUAGE: js
CODE:
{
  type: "unreadReplies",
  roomId: "my-room-id",

  // Unread replies means multiple comments
  comments: [
    {
      id: "cm_asfs8f...",
      threadId: "th_sj30as..."
      createdAt: Date <Fri Dec 15 2023 14:15:22 GMT+0000 (Greenwich Mean Time)>,

      // The formatted comment, pass it to React `children`
      body: { /* ... */},

      // Deprecated: the formatted comment, pass it to React `children` (use `body` instead)
      reactBody: { /* ... */ },

      author: {
        id: "aurélien@example.com",
        info: { /* Custom user info you have resolved */ },
      },
    },

    // More comments
    //...
  ],
}

----------------------------------------

TITLE: Using useInboxNotifications Hook with Pagination
DESCRIPTION: Example of using the useInboxNotifications hook with pagination support in version 2.9, showing how to access pagination-related properties and methods.

LANGUAGE: TSX
CODE:
const {
  inboxNotifications,
  isLoading,
  error,

  // ✨ New in Liveblocks 2.9
  fetchMore,
  isFetchingMore,
  hasFetchedAll,
  fetchMoreError,
} = useInboxNotifications();

----------------------------------------

TITLE: Invalid UserMeta Type Example with Date Field
DESCRIPTION: An example showing a common error in UserMeta type definition where a Date field is used, which is invalid because it's not a valid JSON type.

LANGUAGE: typescript
CODE:
declare global {
  interface Liveblocks {
    UserMeta: {
      id: string;
      info: {
        name: string;
        color: string;
        picture: string;
        lastLogin: Date; // ❌ The issue is here
      };
    };
  }
}

----------------------------------------

TITLE: Using useInboxNotifications Hook with Pagination
DESCRIPTION: Example of using the useInboxNotifications hook with pagination support in version 2.9, showing how to access pagination-related properties and methods.

LANGUAGE: TSX
CODE:
const {
  inboxNotifications,
  isLoading,
  error,

  // ✨ New in Liveblocks 2.9
  fetchMore,
  isFetchingMore,
  hasFetchedAll,
  fetchMoreError,
} = useInboxNotifications();

----------------------------------------

TITLE: Using authEndpoint as a Callback with Custom Headers
DESCRIPTION: Advanced configuration for the Liveblocks client that uses a callback function for the authEndpoint, allowing for custom headers and request body to be sent to the authentication endpoint.

LANGUAGE: typescript
CODE:
import { createClient } from "@liveblocks/client";

// Passing custom headers and body to your endpoint
const client = createClient({
  authEndpoint: async (room) => {
    const headers = {
      // Custom headers
      // ...

      "Content-Type": "application/json",
    };

    const body = JSON.stringify({
      // Custom body
      // ...

      room,
    });

    const response = await fetch("/api/liveblocks-auth", {
      method: "POST",
      headers,
      body,
    });

    return await response.json();
  },
});

----------------------------------------

TITLE: Joining a Liveblocks Room in Vue.js
DESCRIPTION: Code to enter a specific Liveblocks room, which is a virtual space where users collaborate. The function returns the room object and a leave function.

LANGUAGE: javascript
CODE:
const { room, leave } = client.enterRoom("my-room");

----------------------------------------

TITLE: Configuring Liveblocks Types in TypeScript
DESCRIPTION: Example showing the improved DX by allowing global type specification in Liveblocks v2.0. This demonstrates the transition from explicitly passing types to each context creation to using global interface declarations.

LANGUAGE: typescript
CODE:
// ❌ Before
export const {
  suspense: {
    RoomProvider,
    useRoom,
    // etc
  },
} = createRoomContext<Presence, Storage>(client);

// ✅ After
declare global {
  interface Liveblocks {
    Presence: Presence;
    Storage: Storage;
  }
}

----------------------------------------

TITLE: Initializing Liveblocks Configuration with CLI
DESCRIPTION: Creates a liveblocks.config.ts file that can be used to define types for the application. This is done using the Liveblocks CLI tool.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --init --framework react

----------------------------------------

TITLE: Creating a Room with User Permissions Using REST API
DESCRIPTION: Example of using the Liveblocks REST API to create a room and set user-specific access permissions.

LANGUAGE: ts
CODE:
fetch("https://api.liveblocks.io/v2/rooms", {
  method: "POST",
  body: JSON.stringify({
    id: "my-room-name",
    defaultAccesses: [],
    usersAccesses: {
      "olivier@example.com": ["room:write"]
    }
  }),
});

----------------------------------------

TITLE: Retrieving Room Storage Data from Liveblocks API in TypeScript
DESCRIPTION: Code that handles webhook events and retrieves the current room's Storage document data using the Liveblocks REST API. This snippet verifies the webhook request and handles the 'storageUpdated' event type.

LANGUAGE: typescript
CODE:
import { WebhookHandler } from "@liveblocks/node";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When Storage document data has been updated
  if (event.type === "storageUpdated") {
    const { roomId } = event.data;

    // Get Storage data from Liveblocks REST API
    const url = `https://api.liveblocks.io/v2/rooms/${roomId}/storage`;
    const response = await fetch(url, {
      headers: { Authorization: `Bearer ${API_SECRET}` },
    });

    if (!response.ok) {
      return new Response("Problem accessing Liveblocks REST APIs", {
        status: 500,
      });
    }

    // Your JSON Storage document data as a string
    const storageData = await response.text();

    // Update database
    // ...
  }

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Defining TextMentionNotificationEvent Schema and Example in TypeScript
DESCRIPTION: TypeScript definition for TextMentionNotificationEvent which is triggered 30 minutes after a user has been mentioned in a text and has not seen the mention. This notification can be identified using the isTextMentionNotificationEvent type guard.

LANGUAGE: typescript
CODE:
// Schema
type TextMentionNotificationEvent = {
  type: "notification";
  data: {
    channel: "email";
    kind: "textMention";
    projectId: string;
    roomId: string;
    userId: string;
    mentionId: string;
    inboxNotificationId: string;
    createdAt: string;
  };
};

// Example
const textMentionNotificationEvent = {
  type: "notification",
  data: {
    channel: "email",
    kind: "textMention",
    projectId: "my-project-id",
    roomId: "my-room-id",
    userId: "my-user-id",
    mentionId: "my-mention-id",
    inboxNotificationId: "my-inbox-notification-id",
    createdAt: "2021-10-06T01:45:56.558Z",
  },
};

----------------------------------------

TITLE: Deleting a Schema via REST API in TypeScript
DESCRIPTION: Example showing how to delete a schema using the Liveblocks REST API. This operation is only possible when the schema is not attached to any rooms and not frozen.

LANGUAGE: typescript
CODE:
fetch("https://api.liveblocks.io/v2/schemas/{id}", {
  method: "DELETE",
});

----------------------------------------

TITLE: Installing the Collaborative Text Editor Example with Liveblocks CLI
DESCRIPTION: Command to set up the Liveblocks collaborative text editor example project with automatic API key configuration. This initializes a new project based on the Next.js Yjs Lexical template.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-yjs-lexical --api-key

----------------------------------------

TITLE: Extending Toolbar with Custom Buttons in Tiptap Editor
DESCRIPTION: This example shows how to extend the default Toolbar by adding custom content before and after the default buttons using the 'before' and 'after' props, including a custom help button with an icon.

LANGUAGE: tsx
CODE:
import { Toolbar } from "@liveblocks/react-tiptap";
import { Icon } from "@liveblocks/react-ui";

<Toolbar
  editor={editor}
  // +++
  before={<>I'm at the start</>}
  after={
    <Toolbar.Button
      name="Help"
      icon={<Icon.QuestionMark />}
      shortcut="CMD-H"
      onClick={() => console.log("help")}
    />
  }
  // +++
/>;

----------------------------------------

TITLE: Basic Zustand Store Implementation Without Liveblocks Middleware
DESCRIPTION: Example of a basic Zustand store implementation for a to-do list application without using Liveblocks middleware. Shows the standard approach to creating a Zustand store with typed state.

LANGUAGE: typescript
CODE:
import create from "zustand";

type State = {
  draft: string;
  isTyping: boolean;
  todos: Todo[];
  setDraft: (draft: string) => void;
  addTodo: () => void;
  deleteTodo: (index: number) => void;
};

create<State>(/* ... */);

----------------------------------------

TITLE: Creating a React App with TypeScript
DESCRIPTION: Command to create a new React application with TypeScript template using create-react-app.

LANGUAGE: bash
CODE:
npx create-react-app zustand-todo-app --template typescript

----------------------------------------

TITLE: Old Method: Subscribing to Nested Data Updates
DESCRIPTION: Previous complex approach to subscribe to updates on nested data, requiring helper components, manual subscriptions, and state management.

LANGUAGE: tsx
CODE:
function Component() {
  const scientist = useObject("scientist");
  if (scientist == null) {
    return null;
  }

  return <Pets livePets={scientist.get("pets")} />;
}

function Pets({ livePets }) {
  const room = useRoom();
  const [pets, setPets] = useState(livePets.toArray());

  useEffect(() => {
    return room.subscribe(livePets, () => {
      setPets(livePets.toArray());
    });
  }, [room, livePets]);
}

----------------------------------------

TITLE: Incorrect ActivitiesData Type Definition in TypeScript
DESCRIPTION: Example of an invalid ActivitiesData type definition with two errors: using a complex Date type instead of a simple value, and missing the required $ prefix for custom notification kinds.

LANGUAGE: typescript
CODE:
declare global {
  interface Liveblocks {
    ActivitiesData: {
      // Your custom notification kinds go here...
      $error: {
        code: number;
        date: Date; // ❌ Values must simple
      };
      // ❌ Custom notification kinds must start with $
      success: {
        message: string;
      };
    };
  }
}

----------------------------------------

TITLE: Array Updates with Validation
DESCRIPTION: Demonstrates valid and invalid updates to array fields. Shows how arrays are type-checked to ensure they contain the specified element type.

LANGUAGE: typescript
CODE:
// ✅
root.set("animals", ["🦁", "🦊", "🐵"]));

// ❌ Should contain strings
root.set("animals", [1, 2, 2]);

----------------------------------------

TITLE: Defining ThreadDeletedEvent Schema and Example in TypeScript
DESCRIPTION: TypeScript definition for ThreadDeletedEvent which is triggered when a thread is deleted. This event is not throttled and includes project, room, and thread identification, along with a timestamp.

LANGUAGE: typescript
CODE:
// Schema
type ThreadDeletedEvent = {
  type: "threadDeleted";
  data: {
    projectId: string;
    roomId: string;
    threadId: string;
    deletedAt: string;
  };
};

// Example
const threadDeletedEvent = {
  type: "threadDeleted",
  data: {
    projectId: "my-project-id",
    roomId: "my-room-id",
    threadId: "my-thread-id",
    deletedAt: "2021-10-06T01:45:56.558Z",
  },
};

----------------------------------------

TITLE: Deploying Liveblocks Live Cursors Example to Vercel
DESCRIPTION: Command to set up the example project and deploy it directly to Vercel. This creates a new Liveblocks application and opens the browser to facilitate Vercel deployment.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-live-cursors-chat --vercel

----------------------------------------

TITLE: Updating Webhook Event Type Handling
DESCRIPTION: Shows how to update code to handle the new webhook event types, by checking the notification kind before accessing kind-specific properties.

LANGUAGE: ts
CODE:
// ❌ Before
const threadId = event.data.threadId;

// ✅ After
if (event.data.kind === "thread") {
  const threadId = event.data.threadId;
}

----------------------------------------

TITLE: Retrieving Yjs Document Data with Liveblocks REST API in TypeScript
DESCRIPTION: This code sets up a webhook handler to verify Liveblocks webhook requests and retrieve the current Yjs document data using the Liveblocks REST API when a document is updated. It requires a webhook signing secret and an API secret key from your Liveblocks project.

LANGUAGE: typescript
CODE:
import { WebhookHandler } from "@liveblocks/node";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When Yjs document data has been updated
  if (event.type === "ydocUpdated") {
    const { roomId } = event.data;

    // Get Yjs data from Liveblocks REST API
    const url = `https://api.liveblocks.io/v2/rooms/${roomId}/ydoc`;
    const response = await fetch(url, {
      headers: { Authorization: `Bearer ${API_SECRET}` },
    });

    if (!response.ok) {
      return new Response("Problem accessing Liveblocks REST APIs", {
        status: 500,
      });
    }

    // Your JSON Yjs document data as a string
    const yDocData = await response.text();

    // Update database
    // ...
  }

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Adding Threading and Commenting to BlockNote Editor
DESCRIPTION: Implements the Threads component that adds commenting functionality to the text editor. It uses FloatingComposer for creating new threads and AnchoredThreads/FloatingThreads for displaying them on desktop and mobile.

LANGUAGE: tsx
CODE:
import { useThreads } from "@liveblocks/react/suspense";
import {
  AnchoredThreads,
  FloatingComposer,
  FloatingThreads,
} from "@liveblocks/react-blocknote";
import { BlockNoteEditor } from "@blocknote/core";

export function Threads({ editor }: { editor: BlockNoteEditor | null }) {
  const { threads } = useThreads({ query: { resolved: false } });

  if (!editor) {
    return null;
  }

  return (
    <>
      <div className="anchored-threads">
        <AnchoredThreads editor={editor} threads={threads} />
      </div>
      <FloatingThreads
        editor={editor}
        threads={threads}
        className="floating-threads"
      />
      <FloatingComposer editor={editor} className="floating-composer" />
    </>
  );
}

----------------------------------------

TITLE: Using useUpdateNotificationSettings Hook for Simple Updates
DESCRIPTION: Demonstrates the useUpdateNotificationSettings hook, which is a simplified version for just updating notification settings without retrieving the current state. This is useful for simple actions like unsubscribe buttons.

LANGUAGE: tsx
CODE:
// A suspense version of this hook is available
import { useUpdateNotificationSettings } from "@liveblocks/react";

const updateSettings = useUpdateNotificationSettings();

const onUnsubscribe = () => {
  updateSettings({
    slack: {
      thread: false,
    },
  });
};

----------------------------------------

TITLE: Deploying the Collaborative Spreadsheet Example to Vercel
DESCRIPTION: Command to create and deploy the collaborative spreadsheet example to Vercel. This sets up both the local development environment and the Vercel deployment.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-spreadsheet-advanced --vercel

----------------------------------------

TITLE: Creating a Schema via REST API in TypeScript
DESCRIPTION: Example of creating a schema through the Liveblocks REST API. The code demonstrates how to send a POST request with a schema name and definition, which will be used to validate storage operations.

LANGUAGE: typescript
CODE:
fetch("https://api.liveblocks.io/v2/schemas", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    name: "todo-list",
    body: `
      type Storage {
        todos: LiveList<LiveObject<Todo>>
      }

      type Todo {
        text: string
        checked?: boolean
      }
    `,
  }),
});

----------------------------------------

TITLE: Comparing Deprecated and Current Room Entry Methods
DESCRIPTION: Shows the deprecated client.enter method compared to the recommended client.enterRoom approach. The newer approach returns both the room instance and a leave function, providing a cleaner API for room management.

LANGUAGE: typescript
CODE:
// ❌ This API was recommended before 1.5
const room = client.enter("my-room", {
  initialPresence: { cursor: null },
  initialStorage: { todos: new LiveList() },
});
client.leave(roomId);

// ✅ Prefer this instead
const { room, leave } = client.enterRoom("my-room", {
  initialPresence: { cursor: null },
  initialStorage: { todos: new LiveList() },
});
leave();

----------------------------------------

TITLE: Getting Storage Synchronization Status in Liveblocks Room
DESCRIPTION: Retrieves the current storage synchronization status, indicating whether storage data has been loaded and synchronized with the Liveblocks servers.

LANGUAGE: typescript
CODE:
const status = room.getStorageStatus();

// "synchronizing"
console.log(status);

----------------------------------------

TITLE: Basic Zustand Store Implementation without Liveblocks Middleware
DESCRIPTION: Demonstrates how a basic Zustand store would be implemented without Liveblocks middleware. This example shows the creation of a store with todo list functionality, including state management for drafts, typing status, and todo items.

LANGUAGE: typescript
CODE:
import create from "zustand";

type State = {
  draft: string;
  isTyping: boolean;
  todos: Todo[];
  setDraft: (draft: string) => void;
  addTodo: () => void;
  deleteTodo: (index: number) => void;
};

create<State>(/* ... */);

----------------------------------------

TITLE: Building the Live Cursors Project
DESCRIPTION: Command for building the project using npm after setting up the application and configuring the Liveblocks public key.

LANGUAGE: bash
CODE:
npm run build

----------------------------------------

TITLE: Customizing styles for all BlockSelector default items
DESCRIPTION: Demonstrates how to modify the appearance of all default items in the BlockSelector dropdown by mapping over them and applying custom styling based on their types.

LANGUAGE: tsx
CODE:
import { Toolbar } from "@liveblocks/react-tiptap";

<Toolbar.BlockSelector
  items={(defaultItems) =>
    defaultItems.map((item) => {
      let label;

      if (item.name === "Text") {
        label = <span>Regular text</span>;
      }

      if (item.name === "Heading 1") {
        label = (
          <span style={{ fontSize: 18, fontWeight: "bold" }}>Heading 1</span>
        );
      }

      if (item.name === "Heading 2") {
        label = (
          <span style={{ fontSize: 16, fontWeight: "bold" }}>Heading 2</span>
        );
      }

      if (item.name === "Heading 3") {
        label = (
          <span style={{ fontSize: 15, fontWeight: "bold" }}>Heading 3</span>
        );
      }

      if (item.name === "Blockquote") {
        label = (
          <span style={{ borderLeft: "3px solid gray", paddingLeft: 8 }}>
            Blockquote
          </span>
        );
      }

      return {
        ...item,
        label,
        icon: null, // Hide all icons
      };
    })
  }
/>;

----------------------------------------

TITLE: Configuring Redux Store with Liveblocks Enhancer
DESCRIPTION: Sets up a Redux store with the liveblocksEnhancer to connect Redux state to Liveblocks Presence and Storage features.

LANGUAGE: js
CODE:
import { liveblocksEnhancer } from "@liveblocks/redux";
import { configureStore } from "@reduxjs/toolkit";

const store = configureStore({
  reducer: /* reducer */,
  enhancers: [
    liveblocksEnhancer({
      client,
      storageMapping: {},
      presenceMapping: {},
    }),
  ],
});

----------------------------------------

TITLE: Using useNotificationSettings Hook in React
DESCRIPTION: This snippet demonstrates how to use the useNotificationSettings hook from @liveblocks/react to get and update user notification settings in a React component. It shows how to retrieve settings data with loading and error states, and update specific notification channels.

LANGUAGE: tsx
CODE:
// A suspense version of this hook is available
import { useNotificationSettings } from "@liveblocks/react";

const [{ isLoading, error, settings }, updateSettings] =
  useNotificationSettings();
// { email: { thread: true, ... }, slack: { thread: false, ... }, ... }
console.log(settings);

const onSave = () => {
  updateSettings({
    slack: {
      textMention: true,
    },
  });
};

----------------------------------------

TITLE: Initializing Liveblocks Configuration File
DESCRIPTION: Command to create the liveblocks.config.ts file which is used for configuration and type definitions. This uses the Liveblocks CLI tool to generate the necessary boilerplate.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --init --framework javascript

----------------------------------------

TITLE: Implementing User Identification in Backend Endpoint
DESCRIPTION: Creates a server endpoint that identifies the user with Liveblocks, providing the userId and optional groupIds for permission checking.

LANGUAGE: tsx
CODE:
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "sk_prod_xxxxxxxxxxxxxxxxxxxxxxxx",
});

export async function POST(request) {
  const user = { id: "olivier@example.com", info: { name: "Olivier" }};

  const { status, body } = await liveblocks.identifyUser({
    userId: user.id,
    groupIds, // Optional
  });

  return new Response(body, { status });
}

----------------------------------------

TITLE: Implementing User Presence with Svelte
DESCRIPTION: Complete Svelte component script implementing the 'others' subscription to track other users connected to the room. Includes initialization, subscription setup, and cleanup on component destruction.

LANGUAGE: js
CODE:
<script>
  import { onDestroy } from "svelte";
  import { room } from "./room.js";

  let others = room.getOthers();

  const unsubscribeOthers = room.subscribe("others", (updatedOthers) => {
    others = updatedOthers;
  });

  onDestroy(() => {
    unsubscribeOthers();
  });
</script>

<div>There are {others.length} other user(s) online</div>

----------------------------------------

TITLE: Implementing presence to show online users with Redux and Liveblocks
DESCRIPTION: Enhanced App component that displays the number of other users currently in the room. It uses the liveblocks.others state property to track presence information.

LANGUAGE: javascript
CODE:
import React, { useEffect } from "react";
import { useDispatch, useSelector } from "react-redux";
import { actions } from "@liveblocks/redux";

import "./App.css";

function WhoIsHere() {
  const othersUsersCount = useSelector(
    (state) => state.liveblocks.others.length
  );

  return (
    <div className="who_is_here">
      There are {othersUsersCount} other users online
    </div>
  );
}

export default function App() {
  const dispatch = useDispatch();

  useEffect(() => {
    dispatch(actions.enterRoom("redux-demo-room"));

    return () => {
      dispatch(actions.leaveRoom("redux-demo-room"));
    };
  }, [dispatch]);

  return (
    <div className="container">
      <WhoIsHere />
    </div>
  );
}

----------------------------------------

TITLE: Removing Default Type Parameters in Liveblocks Client
DESCRIPTION: Shows how default type parameters were dangerous in v0.16 and have been removed in v0.17. LiveList, LiveMap, and LiveObject now follow the same pattern as built-in TypeScript generics.

LANGUAGE: ts
CODE:
// ✅ Inferred
let list = new LiveList([1, 2, 3]);

// ✅ Explicit
let list: LiveList<number> = new LiveList([1, 2, 3]);

// ☢️ 0.16: Dangerous footgun: discards useful type information!
// 🚫 0.17: No longer possible
let list: LiveList = new LiveList([1, 2, 3]);

----------------------------------------

TITLE: Using User ID and Info in React
DESCRIPTION: Example showing how to access the user's ID and information in a React component using the useSelf hook. This is useful for displaying user data or making user-specific logic decisions.

LANGUAGE: typescript
CODE:
const self = useSelf();
console.log(self.id);
console.log(self.info);

----------------------------------------

TITLE: Migrating from createClient to LiveblocksProvider
DESCRIPTION: Example showing how to replace the old client creation pattern with the new LiveblocksProvider component approach.

LANGUAGE: tsx
CODE:
// ❌ Before, you no longer have to use createClient()
import { createClient } from "@liveblocks/client";

const client = createClient({
  authEndpoint: "/api/liveblocks-auth",
  throttle: 16,
  /* etc */
);

LANGUAGE: tsx
CODE:
// ✅ After
"use client";

import { LiveblocksProvider } from "@liveblocks/react";

export function Layout({ children }) {
  return (
    // Move options here, client will be created for you
    <LiveblocksProvider
      authEndpoint="/api/liveblocks-auth"
      throttle={16}
      /* etc */
    >
      {children}
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Implementing RoomProvider with Required ID Property in React
DESCRIPTION: This snippet demonstrates the correct way to implement RoomProvider by providing the required 'id' property. The component wraps other components to provide a Room context in the React component tree.

LANGUAGE: jsx
CODE:
import { RoomProvider } from "@liveblocks/react";

function Component() {
  return (
    <RoomProvider id="your-room-id">
      <YourComponent />
    </RoomProvider>
  );
}

----------------------------------------

TITLE: Installing the Live Avatar Stack Example with Liveblocks CLI
DESCRIPTION: Command to download and set up the Nuxt.js live avatars example with automatic API key configuration from a Liveblocks account.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nuxtjs-live-avatars --api-key

----------------------------------------

TITLE: Configuring Tutorial Metadata in JSON
DESCRIPTION: Example of how to define a tutorial in the tutorials.json file, including the URL slug, page title, and description.

LANGUAGE: json
CODE:
{
  "slug": "welcome", // url slug
  "title": "Welcome to Liveblocks", // page title, goes in <title>
  "description": "Interactively learn Liveblocks" // goes in <title>
}

----------------------------------------

TITLE: Handling Room ID Change for Active Users in React
DESCRIPTION: This code shows how to use the useErrorListener hook from Liveblocks React to detect when a room ID has changed (error code 4006) and redirect users to the new room location. This prevents disconnections when room IDs are updated.

LANGUAGE: tsx
CODE:
import { useErrorListener } from "../liveblocks.config";

function App() {
  useErrorListener((error) => {
    if (error.code === 4006) {
      // Room ID has been changed, get the new ID and redirect
      const newRoomId = error.message;
      __redirect__(`https://example.com/document/${newRoomId}}`);
    }
  });
}

----------------------------------------

TITLE: Return Value Example of prepareTextMentionNotificationEmailAsReact
DESCRIPTION: An example of the returned data structure from prepareTextMentionNotificationEmailAsReact function, showing the format of an unread text mention with room information and mention details.

LANGUAGE: js
CODE:
{
  roomInfo: {
    name: "my room name"
    url: "https://my-room-url.io"
  },
  mention: {
    id: "in_oiujhdg...",
    roomId: "my-room-id",
    createdAt: Date <Fri Dec 15 2023 14:15:22 GMT+0000 (Greenwich Mean Time)>,
    userId: "user_0"

    // The formatted content, pass it to React `children`
    reactContent: { /* ... */}

    author: {
      id: "vincent@example.com",
      info: { /* Custom user info you have resolved */ }
    }
  },
}

----------------------------------------

TITLE: Managing User Notification Settings with Liveblocks Node.js Client
DESCRIPTION: Example of using the Liveblocks Node.js client to manage user notification settings, including retrieving, updating, and deleting notification preferences. This demonstrates the three new methods exposed by the client.

LANGUAGE: tsx
CODE:
import { Liveblocks } from "@liveblocks/node";
const liveblocks = new Liveblocks({ secret: "sk_xxx" });

const settings = await liveblocks.getNotificationSettings({ userId });
// { email: { thread: true, ... }, slack: { thread: false, ... }, ... }
console.log(settings);

const updatedSettings = await liveblocks.updateNotificationSettings({
  userId,
  data: {
    teams: {
      $fileUploaded: true,
    },
  },
});
await liveblocks.deleteNotificationSettings({ userId });

----------------------------------------

TITLE: Installing the Advanced Collaborative Text Editor Example with Liveblocks CLI
DESCRIPTION: Command to automatically download and set up the Liveblocks collaborative text editor example with Tiptap and Next.js, including API key configuration.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-tiptap-advanced --api-key

----------------------------------------

TITLE: Removing Batched Updates Configuration
DESCRIPTION: Diff showing how to remove the unstable_batchedUpdates configuration from RoomProvider. This is no longer needed after upgrading to React 18 and Liveblocks 2.15.

LANGUAGE: diff
CODE:
-import { unstable_batchedUpdates } from "react-dom";
 //                                      ^^^^^^^^^^^ ...or "react-native"!

 <RoomProvider
   id="my-room"
   initialPresence={/* ... */}
   initialStorage={/* ... */}
-  unstable_batchedUpdates={unstable_batchedUpdates}
 >
   <App />
 </RoomProvider>

----------------------------------------

TITLE: Configuring Liveblocks Client with Firebase Authentication
DESCRIPTION: Sets up the Liveblocks client on the frontend using Firebase functions for authentication. Creates a client that uses a Firebase callable function to handle auth instead of a public API key.

LANGUAGE: javascript
CODE:
import { createClient } from "@liveblocks/client";
import firebase from "firebase";
import "firebase/functions";

firebase.initializeApp({
  /* Firebase config */
});

const auth = firebase.functions().httpsCallable("liveblocks-auth");

// Create a Liveblocks client
const client = createClient({
  authEndpoint: async (room) => (await auth({ room })).data,
});

----------------------------------------

TITLE: Using LiveList in Liveblocks Schema
DESCRIPTION: Shows how to use LiveList to create collaborative arrays. Wraps an array element type in LiveList to make it collaborative and observable.

LANGUAGE: typescript
CODE:
type Storage {
  animals: LiveList<string>
  //       ^^^^^^^^
}

----------------------------------------

TITLE: Liveblocks API Base URL
DESCRIPTION: The base URL endpoint for the Liveblocks REST API v2. All API requests should be made to this base URL followed by specific resource paths.

LANGUAGE: text
CODE:
https://api.liveblocks.io/v2

----------------------------------------

TITLE: Deploying the Collaborative Text Editor on Vercel
DESCRIPTION: Command to download the example and set up deployment on Vercel. This helps with both deployment configuration and local development setup.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-blocknote --vercel

----------------------------------------

TITLE: Setting Up LiveblocksProvider with Auth Endpoint
DESCRIPTION: Code for configuring the LiveblocksProvider component on the client side to use the custom authentication endpoint instead of a public API key.

LANGUAGE: tsx
CODE:
<LiveblocksProvider authEndpoint="/api/liveblocks-auth">

----------------------------------------

TITLE: Creating a Liveblocks Room Component in Next.js
DESCRIPTION: Setup for a Liveblocks room with LiveblocksProvider, RoomProvider, and ClientSideSuspense to create a collaborative space. This component will wrap the collaborative features of the application.

LANGUAGE: tsx
CODE:
"use client";

import { ReactNode } from "react";
import {
  LiveblocksProvider,
  RoomProvider,
  ClientSideSuspense,
} from "@liveblocks/react/suspense";

export function Room({ children }: { children: ReactNode }) {
  return (
    <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>
      <RoomProvider id="my-room">
        <ClientSideSuspense fallback={<div>Loading…</div>}>
          {children}
        </ClientSideSuspense>
      </RoomProvider>
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Using useSyncStatus with Smooth Option in React
DESCRIPTION: Example showing how to use the useSyncStatus hook with the smooth option to track synchronization status in a React application. This enables displaying a 'Saving...' spinner when changes are being synchronized.

LANGUAGE: TSX
CODE:
useSyncStatus({ smooth: true })

----------------------------------------

TITLE: Installing the Collaborative Spreadsheet Example with Liveblocks CLI
DESCRIPTION: Command to create a new Liveblocks application based on the advanced spreadsheet example. This automatically downloads the example and sets up your API key.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-spreadsheet-advanced --api-key

----------------------------------------

TITLE: Using getMentionedIdsFromCommentBody with Custom CommentBody in TypeScript
DESCRIPTION: Example showing how to use getMentionedIdsFromCommentBody with a custom CommentBody structure. It demonstrates creating a structured comment with a mention and extracting the mentioned user ID.

LANGUAGE: typescript
CODE:
import {
  CommentBody,
  getMentionedIdsFromCommentBody,
} from "@liveblocks/client";

// Create a custom `CommentBody`
const commentBody: CommentBody = {
  version: 1,
  content: [
    {
      type: "paragraph",
      children: [
        { text: "Hello " },
        { type: "mention", id: "chris@example.com" },
      ],
    },
  ],
};

// Get the mentions inside the comment's body
const mentionedIds = getMentionedIdsFromCommentBody(commentBody);

// ["chris@example.com"]
console.log(mentionedIds);

----------------------------------------

TITLE: Using Pagination with useInboxNotifications Hook
DESCRIPTION: Example of using the useInboxNotifications hook with pagination support to fetch inbox notifications incrementally, improving initial load time and user experience.

LANGUAGE: TSX
CODE:
const {
  inboxNotifications,
  isLoading,
  error,

  // ✨ New in Liveblocks 2.9
  fetchMore,
  isFetchingMore,
  hasFetchedAll,
  fetchMoreError,
} = useInboxNotifications();

----------------------------------------

TITLE: Filtering threads by absence of metadata using null in Liveblocks 2.16
DESCRIPTION: Example showing how to filter threads by the absence of a metadata field using null, which is now officially supported in version 2.16.

LANGUAGE: ts
CODE:
// ✅ Will now return "important" threads without a `color` field
const threads = useThreads({
  query: {
    metadata: {
      // +++
      color: null,
      // +++
      label: "important",
    },
  },
});

----------------------------------------

TITLE: Implementing Liveblocks User Presence in SolidJS Component
DESCRIPTION: A SolidJS component that subscribes to the 'others' event to track other users in the room. Uses SolidJS lifecycle methods (onMount, onCleanup) to manage subscriptions and updates a reactive signal with user presence data.

LANGUAGE: js
CODE:
import { createSignal, onCleanup, onMount } from "solid-js";
import { room } from "./room.js";

export function Room() {
  const [other, setOthers] = createSignal(room.getOthers());

  onMount(() => {
    const unsubscribeOthers = room.subscribe("others", (updatedOthers) => {
      setOthers(updatedOthers);
    });

    onCleanup(() => {
      unsubscribeOthers();
    });
  })

  return (
    <div>There are {others.length} other user(s) online</div>
  );
}

----------------------------------------

TITLE: Installing @liveblocks/client 1.0.0 with npm
DESCRIPTION: Command to update the @liveblocks/client package to version 1.0.0 using npm package manager.

LANGUAGE: bash
CODE:
npm install @liveblocks/client@1.0.0

----------------------------------------

TITLE: Granting Access to Multiple Rooms with Different Permissions
DESCRIPTION: This enhanced authentication endpoint shows how to grant a user access to multiple rooms with different permission levels, including using wildcards for room name patterns.

LANGUAGE: tsx
CODE:
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "sk_prod_xxxxxxxxxxxxxxxxxxxxxxxx",
});

export async function POST(request) {
  const user = { id: "olivier@example.com", info: { name: "Olivier" }};

  const session = liveblocks.prepareSession(
    user.id,
    { userInfo: user.info } // Optional
  );

  const { room } = await request.json();
  session.allow(room, session.FULL_ACCESS);
  session.allow("my-room-*", session.READ_ACCESS);
  session.allow("my-other-room", session.READ_ACCESS);

  const { status, body } = await session.authorize();
  return new Response(body, { status });
}

----------------------------------------

TITLE: Comparing Composer Component Structure Before and After 2.8
DESCRIPTION: HTML comparison showing the structural changes in the Composer component between Liveblocks 2.7 and 2.8, which affects custom styling.

LANGUAGE: html
CODE:
<!-- ❌ Before - Liveblocks 2.7 -->
<form class="lb-root lb-composer lb-composer-form">
  <!-- The editor and its controls -->
</form>

<!-- ✅ After - Liveblocks 2.8 -->
<form class="lb-root lb-composer lb-composer-form">
  <div class="lb-composer-editor-container">
    <!-- The editor and its controls -->
  </div>
</form>

----------------------------------------

TITLE: Using useSyncStatus Hook for Synchronization Status in React
DESCRIPTION: Example of using the useSyncStatus hook to track whether Liveblocks is synchronizing local changes to the server. This can be used to display a 'Saving...' indicator in your application.

LANGUAGE: tsx
CODE:
const {
  inboxNotifications,
  isLoading,
  error,

  // ✨ New in Liveblocks 2.9
  fetchMore,
  isFetchingMore,
  hasFetchedAll,
  fetchMoreError,
} = useInboxNotifications();

----------------------------------------

TITLE: Installing Custom Notifications Example with Liveblocks CLI
DESCRIPTION: Command to set up the custom notifications example project using the Liveblocks CLI. This automatically downloads the example and helps you connect it to your Liveblocks account.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-notifications-custom --api-key

----------------------------------------

TITLE: Deploying Collaborative Text Editor to Vercel using Liveblocks CLI
DESCRIPTION: Command to download the example project and deploy it to Vercel. This will open your browser and guide you through the Vercel deployment process with the Liveblocks integration.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-lexical --vercel

----------------------------------------

TITLE: Accessing Awareness Metadata
DESCRIPTION: Shows how to access the meta property which contains metadata about users' awareness states.

LANGUAGE: typescript
CODE:
const meta: Map<number, { click: number; lastUpdated: number }> =
  awareness.meta;

----------------------------------------

TITLE: Deploying Collaborative Whiteboard to Vercel
DESCRIPTION: Command to set up the whiteboard example and deploy it to Vercel, which downloads the example and opens the browser to complete the Vercel deployment process.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-whiteboard-advanced --vercel

----------------------------------------

TITLE: Installing Dependencies for Manual Setup
DESCRIPTION: Command to install all the required dependencies for the collaborative code editor project when setting up manually.

LANGUAGE: bash
CODE:
npm install

----------------------------------------

TITLE: Accessing User Information in Liveblocks
DESCRIPTION: Demonstrates how to access the user ID and user information in a JavaScript application after authentication. This can be done using room.getSelf() or useSelf() in React.

LANGUAGE: typescript
CODE:
const self = room.getSelf(); // or useSelf() in React
console.log(self.id);
console.log(self.info);

----------------------------------------

TITLE: Applying Query Language to Liveblocks REST API
DESCRIPTION: Example of how to encode and include a query string in the REST API call. This shows a specific example of formatting a complex query for the 'query' parameter in the API endpoint URL.

LANGUAGE: javascript
CODE:
metadata['status']:'open' AND metadata['priority']:3

----------------------------------------

TITLE: Calling a Mutation with an Argument
DESCRIPTION: Shows how to invoke a mutation function with a specific parameter value.

LANGUAGE: typescript
CODE:
updateName("Grace");

----------------------------------------

TITLE: Configuring User Metadata in ID Tokens for Liveblocks Notifications
DESCRIPTION: Alternative approach for setting up user metadata using ID token authentication. This shows how to identify a user with their ID, optional group IDs, and user information for displaying in notifications.

LANGUAGE: typescript
CODE:
const { status, body } = await liveblocks.identifyUser(
  {
    userId: "marc@example.com",
    groupIds: [], // Optional
  },
  {
    userInfo: {
      name: "Marc",
      avatar: "https://example.com/marc.png",

      // Your custom metadata
      // ...
    },
  }
);

----------------------------------------

TITLE: Getting and Updating Notification Settings Using Client API
DESCRIPTION: Demonstrates how to create a Liveblocks client and use it to retrieve and update user notification settings. The example shows getting current settings and updating email notification preferences.

LANGUAGE: tsx
CODE:
import { createClient } from '@liveblocks/client'
const client = createClient({ ... })

const settings = await client.getNotificationSettings();
// { email: { thread: true, ... }, slack: { thread: false, ... }, ... }
console.log(settings);

const updatedSettings = await client.updateNotificationSettings({
  email: {
    thread: false,
  }
});

----------------------------------------

TITLE: Creating LiveList with Type Definition in TypeScript
DESCRIPTION: Shows how to define a type for a LiveList to add type safety to the synchronized collection. This example defines a LiveList that will only contain string values.

LANGUAGE: typescript
CODE:
type Names = LiveList<string>;

----------------------------------------

TITLE: Deploying Live Form Selection Example to Vercel
DESCRIPTION: Command to create and deploy the live form selection example to Vercel. This downloads the example and guides you through the Vercel deployment process.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-live-form-selection --vercel

----------------------------------------

TITLE: Subscribing to Status Changes in @liveblocks/client
DESCRIPTION: Method to subscribe to changes of the connection status in a Liveblocks room.

LANGUAGE: typescript
CODE:
room.subscribe("status")

----------------------------------------

TITLE: Deploying Live Avatar Stack to Vercel with Liveblocks CLI
DESCRIPTION: Command to download the live avatar stack example and deploy it to Vercel. This opens your browser to complete the Vercel deployment process.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-live-avatars-advanced --vercel

----------------------------------------

TITLE: Deploying Audio Comments Example to Vercel
DESCRIPTION: Command to set up the audio comments example for both local development and Vercel deployment. This guides through downloading the example and deploying it to Vercel.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-comments-audio --vercel

----------------------------------------

TITLE: Initializing Liveblocks Configuration File
DESCRIPTION: Command to initialize the liveblocks.config.ts file which can be used later to define types for the application.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --init --framework javascript

----------------------------------------

TITLE: Using LiveList.set Method for Element Manipulation
DESCRIPTION: Demonstrates the usage of the LiveList.set method introduced in v0.16.0. This method allows setting a specific element at a given index in a LiveList, with a warning about version compatibility across connected clients.

LANGUAGE: typescript
CODE:
const list = new LiveList(["🦁", "🦊", "🐵"]);
list.set(0, "🐺");
list.toArray(); // equals ["🐺", "🦊", "🐵"]

----------------------------------------

TITLE: Building the Application
DESCRIPTION: Command to build the application using the predefined npm script, likely invoking esbuild to bundle the JavaScript files.

LANGUAGE: bash
CODE:
npm run build

----------------------------------------

TITLE: Installing Liveblocks React UI Package
DESCRIPTION: Command to install the Liveblocks React UI package along with its required dependencies using npm. This installs the client, react, and react-ui packages needed for using Liveblocks in a React application.

LANGUAGE: bash
CODE:
npm install @liveblocks/client @liveblocks/react @liveblocks/react-ui

----------------------------------------

TITLE: Using indexOf Method with LiveList in TypeScript
DESCRIPTION: Demonstrates how to use the indexOf method to find the first index of an element in a LiveList. Returns the index of the item if found, or -1 if not present.

LANGUAGE: typescript
CODE:
const list = new LiveList(["adrien", "jonathan"]);

// 1
list.indexOf("jonathan");

// undefined
list.indexOf("chris");

----------------------------------------

TITLE: Alternative Responsive Implementation Using Media Query Hook
DESCRIPTION: An alternative approach to responsive thread components using a media query hook. Demonstrates how to conditionally render either FloatingThreads or AnchoredThreads based on screen size.

LANGUAGE: tsx
CODE:
import { useSyncExternalStore } from "react";
import { useThreads } from "@liveblocks/react/suspense";
import { AnchoredThreads, FloatingThreads } from "@liveblocks/react-lexical";

function ThreadOverlay() {
  const { threads } = useThreads({ query: { resolved: false } });
  // +++
  const isMobile = useIsMobile();
  // +++

  // +++
  if (isMobile) {
    return <FloatingThreads threads={threads} style={{ width: "350px" }} />;
  }
  // +++

  // +++
  return <AnchoredThreads threads={threads} style={{ width: "350px" }} />;
  //+++
}

export function useIsMobile() {
  return useSyncExternalStore(subscribe, getSnapshot, getSnapshot);
}

function subscribe(callback: () => void) {
  const query = window.matchMedia("(max-width: 1024px)");

  query.addEventListener("change", callback);
  return () => query.removeEventListener("change", callback);
}

function getSnapshot() {
  const query = window.matchMedia("(max-width: 1024px)");
  return query.matches;
}

----------------------------------------

TITLE: Advanced Client Configuration with Custom Headers
DESCRIPTION: Extended client-side configuration that uses a callback for the authEndpoint to allow passing custom headers and request body to the authentication endpoint.

LANGUAGE: typescript
CODE:
import { createClient } from "@liveblocks/client";

// Passing custom headers and body to your endpoint
const client = createClient({
  authEndpoint: async (room) => {
    const headers = {
      // Custom headers
      // ...

      "Content-Type": "application/json",
    };

    const body = JSON.stringify({
      // Custom body
      // ...

      room,
    });

    const response = await fetch("/api/liveblocks-auth", {
      method: "POST",
      headers,
      body,
    });

    return await response.json();
  },
});

----------------------------------------

TITLE: Demonstrating Old Room API in Liveblocks Client
DESCRIPTION: Shows the deprecated API patterns for entering, getting, and leaving rooms in the Liveblocks client that will remain functional but are no longer recommended.

LANGUAGE: typescript
CODE:
// Old APIs we'll no longer be recommending (but that will remain working)
const room = client.enter("my-room", options);
client.getRoom("my-room");
client.leave("my-room");

----------------------------------------

TITLE: Implementing Extended Document Type in buildDocuments.ts
DESCRIPTION: How to modify the buildDocuments utility to include the new property when converting Liveblocks rooms into custom document format.

LANGUAGE: typescript
CODE:
// Return our custom Document format
const document: Document = {
  randomNumber: Math.random(),
  // ...
};

----------------------------------------

TITLE: Using useHistoryVersions Hook in React
DESCRIPTION: Shows how to use the useHistoryVersions hook to retrieve versions of a room. This hook is used with Version History Components for displaying version history.

LANGUAGE: tsx
CODE:
import { useHistoryVersions } from "@liveblocks/react";

const { versions, error, isLoading } = useHistoryVersions();

----------------------------------------

TITLE: Defining LiveList Types in Liveblocks Configuration
DESCRIPTION: Sets up the Person type as a LiveObject and defines the global Liveblocks Storage type with a LiveList of Person objects. This provides type safety for the collaborative list structure.

LANGUAGE: typescript
CODE:
// Person type
type Person = LiveObject<{
  name: string;
  age: number;
}>;

// Global types
declare global {
  interface Liveblocks {
    Storage: {
      people: LiveList<Person>;
    };
  }
}

----------------------------------------

TITLE: Subscribing to Liveblocks Room Events
DESCRIPTION: Example of using the 'others' subscription to get real-time updates about other users in the room. This displays the count of other connected users in a div element.

LANGUAGE: js
CODE:
import { room } from "./room.js"

const div = document.querySelector("div");

room.subscribe("others", (others) => {
  div.innerText = `There are ${others.length} other user(s) online`;
});

----------------------------------------

TITLE: Using shouldInitiallyConnect with client.enter
DESCRIPTION: Code demonstrating how to use the new shouldInitiallyConnect option with client.enter to control the WebSocket connection establishment, particularly useful for SSR.

LANGUAGE: tsx
CODE:
client.enter("room", {
  initialPresence: {},
  shouldInitiallyConnect: false, // 👈 for SSR using the @liveblocks/client package
});

----------------------------------------

TITLE: Updating React-Comments Package Imports
DESCRIPTION: Shows how to update imports after the package rename from @liveblocks/react-comments to @liveblocks/react-ui.

LANGUAGE: tsx
CODE:
// ❌ Before
import { Thread } from "@liveblocks/react-comments";

// ✅ After
import { Thread } from "@liveblocks/react-ui";

----------------------------------------

TITLE: Configuring User Metadata in ID Tokens for Liveblocks Text Editor
DESCRIPTION: Sets up user metadata using ID token authentication. This approach identifies a user with their ID and optional group IDs, while also attaching metadata for name, color, and avatar.

LANGUAGE: typescript
CODE:
const { status, body } = await liveblocks.identifyUser(
  {
    userId: "marc@example.com",
    groupIds: [], // Optional
  },
  {
    userInfo: {
      name: "Marc",
      color: "#00ff00",
      avatar: "https://example.com/marc.png",

      // Your custom metadata
      // ...
    },
  }
);

----------------------------------------

TITLE: Using getOrCreate Method in Node SDK
DESCRIPTION: Shows how to use the new getOrCreate method which combines getRoom and createRoom functionality.

LANGUAGE: javascript
CODE:
.getOrCreate()

----------------------------------------

TITLE: Installing the Live Avatar Stack Example with Liveblocks CLI
DESCRIPTION: Command to set up the Next.js live avatar stack example using Liveblocks CLI. This automatically downloads the example and helps set up your API key from your liveblocks.io account.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-live-avatars-advanced --api-key

----------------------------------------

TITLE: Deploying Notion-like AI Editor on Vercel
DESCRIPTION: Command to download the example and deploy it to Vercel. This sets up both local development and cloud deployment in one step.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-notion-like-ai-editor --vercel

----------------------------------------

TITLE: Complete Liveblocks Email Notification Webhook Handler with Resend Integration
DESCRIPTION: A full implementation of a webhook handler that processes thread notification events, prepares email content using @liveblocks/emails, and sends notifications using Resend. This handles both unread mentions and replies with custom styling for comment components.

LANGUAGE: tsx
CODE:
import {
  Liveblocks,
  WebhookHandler,
  isThreadNotificationEvent,
} from "@liveblocks/node";
import { prepareThreadNotificationEmailAsReact } from "@liveblocks/emails";
// +++
import { Resend } from "resend";
// +++

// +++
// Create Resend client (add your API key)
const resend = new Resend("re_123456789");
// +++

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";
const liveblocks = new Liveblocks({ secret: API_SECRET });

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When an inbox notification has been created on the email channel
  if (isThreadNotificationEvent(event) && event.data.channel === "email") {
    // Check if user has access to room
    if (!__hasRoomAccess__(event.userId, event.roomId)) {
      return new Response(null, { status: 200 });
    }

    // The user to send the email to
    const emailAddress = __getEmailAddressFromDB__(event.userId);

    let emailData;

    try {
      emailData = await prepareThreadNotificationEmailAsReact(
        liveblocks,
        event,
        {
          resolveUsers: async ({ userIds }) => {
            const usersData = await __getUsersFromDB__(userIds);

            return usersData.map((userData) => ({
              name: userData.name, // "Steven"
              avatar: userData.avatar.src, // "https://example.com/steven.jpg"
            }));
          },
          resolveRoomInfo: async ({ roomId }) => {
            const roomData = await __getRoomFromDB__(roomId);

            return {
              name: roomData.name, // "Untitled document"
              url: roomData.url, //`https://example.com/my-room-id`
            };
          },
          components: {
            Paragraph: ({ children }) => (
              <p style={{ margin: "12px 0" }}>{children}</p>
            ),

            // `user` is the optional data returned from `resolveUsers`
            Mention: ({ element, user }) => (
              <span style={{ color: "red" }}>@{user?.name ?? element.id}</span>
            ),

            // If the link is rich-text render it, otherwise use the URL
            Link: ({ element, href }) => (
              <a href={href} style={{ textDecoration: "underline" }}>
                {element?.text ?? href}
              </a>
            ),
          },
        }
      );
    } catch (err) {
      console.log(err);
      return new Response("Could not fetch thread notification data", {
        status: 500,
      });
    }

    // All comments have already been read
    if (!emailData) {
      return new Response(null, { status: 200 });
    }

    let email;
    switch (emailData.type) {
      case "unreadMention": {
        email = (
          <div>
            <div>
              @{emailData.comment.author.id} at {emailData.comment.createdAt}
            </div>
            <div>{emailData.comment.reactBody}</div>
          </div>
        );
        break;
      }

      case "unreadReplies": {
        email = (
          <div>
            {emailData.comments.map((comment) => (
              <div key={comment.id}>
                <div>
                  @{comment.author.id} at {comment.createdAt}
                </div>
                <div>{comment.reactBody}</div>
              </div>
            ))}
          </div>
        );
        break;
      }
    }

    // +++
    // Send email to the user's email address
    try {
      const data = await resend.emails.send({
        from: "My company <hello@my-company.com>",
        to: emailAddress,
        subject: "New comment",
        react: email,
      });
    } catch (err) {
      console.error(err);
    }
    // +++
  }

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Installing Dependencies and Running Development Server
DESCRIPTION: Commands for manual setup, installing dependencies and starting the development server after configuring the environment variables.

LANGUAGE: bash
CODE:
npm install
npm run dev

----------------------------------------

TITLE: Configuring client for liveblocks middleware
DESCRIPTION: Setting up the Liveblocks client for authentication and passing it to the liveblocks middleware. The client handles the connection to the Liveblocks service.

LANGUAGE: javascript
CODE:
import { createClient } from "@liveblocks/client";
import { liveblocks } from "@liveblocks/zustand";

const client = createClient({
  authEndpoint: "/api/liveblocks-auth",
});

liveblocks(/* Zustand config */, { client })

----------------------------------------

TITLE: Extending Document Type in types/documents.ts
DESCRIPTION: How to add a new property to the Document type by modifying the TypeScript type definition.

LANGUAGE: typescript
CODE:
export type Document = {
  // Your new property
  randomNumber: number;
  //...
};

----------------------------------------

TITLE: Adding ClientSideSuspense for Loading States in Liveblocks React App
DESCRIPTION: Enhanced implementation that adds ClientSideSuspense to handle loading states. This approach uses React Suspense to display a loading fallback while Liveblocks hooks are connecting to the room.

LANGUAGE: tsx
CODE:
return (
  <LiveblocksProvider publicApiKey={publicApiKey}>
    <RoomProvider id={roomId}>
      <ClientSideSuspense fallback={<div>Loading…</div>}>
        <Room />
      </ClientSideSuspense>
    </RoomProvider>
  </LiveblocksProvider>
);

----------------------------------------

TITLE: Configuring Lost Connection Timeout in Liveblocks
DESCRIPTION: Shows how to set the lostConnectionTimeout when creating a Liveblocks client. This determines how quickly the lost-connection event triggers after a connection loss occurs.

LANGUAGE: typescript
CODE:
import { createClient } from "@liveblocks/client";

const client = createClient({
  // Throw lost-connection event after 5 seconds offline
  lostConnectionTimeout: 5000,

  // ...
});

----------------------------------------

TITLE: Managing User Notification Settings with Liveblocks Node.js Client
DESCRIPTION: Demonstrates how to use the Liveblocks Node.js client to manage user notification settings, including getting current settings, updating specific notification preferences, and deleting settings entirely.

LANGUAGE: tsx
CODE:
import { Liveblocks } from "@liveblocks/node";
const liveblocks = new Liveblocks({ secret: "sk_xxx" });

const settings = await liveblocks.getNotificationSettings({ userId });
// { email: { thread: true, ... }, slack: { thread: false, ... }, ... }
console.log(settings);

const updatedSettings = await liveblocks.updateNotificationSettings({
  userId,
  data: {
    teams: {
      $fileUploaded: true,
    },
  },
});
await liveblocks.deleteNotificationSettings({ userId });

----------------------------------------

TITLE: Installing the Collaborative Text Editor Example with Liveblocks CLI
DESCRIPTION: Command to set up the collaborative text editor example project using the Liveblocks CLI. This automatically downloads the example and helps you configure your API key from your Liveblocks account.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-tiptap-novel --api-key

----------------------------------------

TITLE: Configuring Storage Types in Liveblocks
DESCRIPTION: Defines the Storage interface in TypeScript for Liveblocks, declaring a LiveList to store todo items with text properties. This ensures storage hooks are properly typed throughout the application.

LANGUAGE: tsx
CODE:
import { LiveList } from "@liveblocks/client";

declare global {
  interface Liveblocks {
    Presence: { isTyping: boolean };

    // +++
    Storage: {
      todos: LiveList<{ text: string }>;
    };
    // +++
  }
}

----------------------------------------

TITLE: Example of Invalid LSON in Liveblocks Storage Type with Date
DESCRIPTION: This code snippet shows a Storage type declaration with an invalid LSON value - a Date object, which triggers the error.

LANGUAGE: typescript
CODE:
declare global {
  interface Liveblocks {
    Storage: {
      layers: LiveMap<string, LiveObject<Layer>>;
      layerIds: LiveList<string>;
      createdAt: Date; // ❌ The issue is here
    };
  }
}

----------------------------------------

TITLE: Subscribing to Storage Status Changes in TypeScript
DESCRIPTION: Demonstrates how to subscribe to storage status changes using the room.subscribe method with the "storage-status" event. The code shows how to handle different storage status states in a switch statement.

LANGUAGE: typescript
CODE:
room.subscribe("storage-status", (status) => {
  switch (status) {
    case "not-loaded":
      break;
    case "loading":
      break;
    case "synchronizing":
      break;
    case "synchronized":
      break;
    default:
      break;
  }
});

----------------------------------------

TITLE: Installing the Live Avatar Stack Example
DESCRIPTION: Command to create a new Liveblocks application with the SvelteKit live avatars example and automatically set up the API key.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example sveltekit-live-avatars --api-key

----------------------------------------

TITLE: Finding Index of First Matching Element in LiveList in TypeScript
DESCRIPTION: Shows how to find the index of the first element that satisfies a condition using the findIndex() method. Returns -1 if no elements match the condition.

LANGUAGE: typescript
CODE:
const list = new LiveList(["apple", "lemon", "tomato"]);

// 1
list.findIndex((value, index) => value.startsWith("l"));

----------------------------------------

TITLE: Demonstrating New Room API in Liveblocks Client
DESCRIPTION: Shows the new recommended API pattern for entering and leaving rooms in the Liveblocks client that supports multiple connections to the same room.

LANGUAGE: typescript
CODE:
// New API we'll be recommending instead
const { room, leave } = client.enterRoom("my-room", options);
leave();

----------------------------------------

TITLE: Implementing Complete To-Do List UI with Liveblocks Integration
DESCRIPTION: The complete React component for the to-do list application. Handles loading state, renders the to-do items, and provides UI for adding and deleting to-dos. Includes event handlers for typing and submission.

LANGUAGE: tsx
CODE:
import React, { useEffect } from "react";
import useStore from "./store";

import "./App.css";

/* WhoIsHere */
/* SomeoneIsTyping */

export default function App() {
  const {
    draft,
    setDraft,
    todos,
    addTodo,
    deleteTodo,
    liveblocks: { enterRoom, leaveRoom, isStorageLoading },
  } = useStore();

  useEffect(() => {
    enterRoom("zustand-todo-app");
    return () => {
      leaveRoom("zustand-todo-app");
    };
  }, [enterRoom, leaveRoom]);

  if (isStorageLoading) {
    return <div>Loading...</div>;
  }

  return (
    <div className="container">
      <WhoIsHere />
      <input
        className="input"
        type="text"
        placeholder="What needs to be done?"
        value={draft}
        onChange={(e) => setDraft(e.target.value)}
        onKeyDown={(e) => {
          if (e.key === "Enter") {
            addTodo();
          }
        }}
      ></input>
      <SomeoneIsTyping />
      {todos.map((todo, index) => {
        return (
          <div className="todo_container" key={index}>
            <div className="todo">{todo.text}</div>
            <button
              className="delete_button"
              onClick={() => {
                deleteTodo(index);
              }}
            >
              ✕
            </button>
          </div>
        );
      })}
    </div>
  );
}

----------------------------------------

TITLE: Using useRoom with allowOutsideRoom Option
DESCRIPTION: Shows how to use the optional allowOutsideRoom parameter with useRoom hook to return null when used outside a room instead of throwing.

LANGUAGE: javascript
CODE:
useRoom({ allowOutsideRoom: true })

----------------------------------------

TITLE: Importing Liveblocks Default Styles in Next.js
DESCRIPTION: Imports the default CSS styles for Liveblocks React UI components into the root layout of a Next.js application to ensure proper styling of the comment components.

LANGUAGE: tsx file
CODE:
import "@liveblocks/react-ui/styles.css";

----------------------------------------

TITLE: Updating Zustand store creation pattern
DESCRIPTION: Code demonstrating the migration from the old Zustand pattern to the new Zustand v4 pattern with the WithLiveblocks type wrapper.

LANGUAGE: ts
CODE:
create(liveblocks<MyState, ...>(...))

LANGUAGE: ts
CODE:
create<WithLiveblocks<MyState, ...>>()(liveblocks(...))

----------------------------------------

TITLE: Preparing Thread Notification Email with React in Liveblocks
DESCRIPTION: This code demonstrates how to prepare and render email notifications for thread comments using React JSX. It handles both unread mentions and multiple unread replies scenarios.

LANGUAGE: tsx
CODE:
// Get email data as React JSX
const emailData = await prepareThreadNotificationEmailAsReact(
  liveblocks,
  event
);

let email;
switch (emailData.type) {
  // The user has an unread mention
  case "unreadMention": {
    email = (
      // +++
      <div>
        <div>
          @{emailData.comment.author.id} at {emailData.comment.createdAt}
        </div>
        <div>{emailData.comment.reactBody}</div>
      </div>
      // +++
    );
    break;
  }

  // The user has multiple unread replies
  case "unreadReplies": {
    email = (
      // +++
      <div>
        {emailData.comments.map((comment) => (
          <div key={comment.id}>
            <div>
              @{comment.author.id} at {comment.createdAt}
            </div>
            <div>{comment.reactBody}</div>
          </div>
        ))}
      </div>
      // +++
    );
  }
}

----------------------------------------

TITLE: Installing Liveblocks Multiplayer Form Example with CLI
DESCRIPTION: Command to download and set up the Liveblocks collaborative form example locally. This will install necessary dependencies and prompt for an API key.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-form --api-key

----------------------------------------

TITLE: Deploying to Vercel with Liveblocks
DESCRIPTION: Command to create a new Liveblocks application with the SendGrid comments email notifications example and deploy it to Vercel. This downloads the example and opens the browser to complete the Vercel deployment process.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-comments-emails-sendgrid --vercel

----------------------------------------

TITLE: Accessing Other Users in Liveblocks Room with Redux
DESCRIPTION: Uses useSelector to access information about other users present in the current Liveblocks room.

LANGUAGE: js
CODE:
const others = useSelector((state) => state.liveblocks.others);

----------------------------------------

TITLE: Configuring User Metadata in Access Tokens for Liveblocks Text Editor
DESCRIPTION: Sets up user metadata in a Liveblocks session using access token authentication. The metadata includes user name, color, and avatar which will be used by the Text Editor to display user information.

LANGUAGE: typescript
CODE:
const session = liveblocks.prepareSession("marc@example.com", {
  userInfo: {
    name: "Marc",
    color: "#00ff00",
    avatar: "https://example.com/marc.png",

    // Your custom metadata
    // ...
  },
});

----------------------------------------

TITLE: Comment Object Structure within a Thread in Liveblocks
DESCRIPTION: This snippet illustrates the structure of a thread object containing a comment. It shows the complete comment object structure with properties including type, IDs, user ID, timestamps, and body content in CommentBody format.

LANGUAGE: typescript
CODE:
{
  type: "thread",
  id: "th_sf8s6sh...",
  roomId: "my-room-id",
  createdAt: Date <Fri Dec 15 2023 14:15:22 GMT+0000 (Greenwich Mean Time)>,
  resolved: false,
  comments: [
    {
      type: "comment",
      threadId: "th_sf8s6sh...",
      id: "cm_agH76a...",
      roomId: "my-room-id",
      userId: "alicia@example.com",
      createdAt: Date <Fri Dec 15 2023 14:15:22 GMT+0000 (Greenwich Mean Time)>,
      editedAt: Date <Fri Dec 15 2023 15:07:19 GMT+0000 (Greenwich Mean Time)>,
      body: {
        // The comment's text in `CommentBody` format
        // ...
      },
    },

    // Other comments in the thread
    // ...
  ],
  metadata: {
    // Your custom thread metadata
    // ...
  },
}

----------------------------------------

TITLE: Configuring Multiple Tiptap Editors with Liveblocks
DESCRIPTION: Shows how to configure multiple Tiptap editors on a single page by assigning each a unique field identifier for collaborative functionality.

LANGUAGE: tsx
CODE:
import { useLiveblocksExtension } from "@liveblocks/react-tiptap";

function TextEditor() {
  const liveblocks = useLiveblocksExtension({
    field: "editor-one",
  });

  // ...
}

----------------------------------------

TITLE: Broadcasting Toast Event on Button Click
DESCRIPTION: Implements a button click handler that broadcasts a toast notification event to all users in the room. The event contains a type identifier and a message that will be displayed in the notification.

LANGUAGE: tsx
CODE:
return (
  <button
    onClick={() =>
      // Broadcast toast event
      broadcast({ type: "TOAST", message: "Event received!" })
    }
  >
    Broadcast event
  </button>
);

----------------------------------------

TITLE: Creating Thread in Liveblocks Comments
DESCRIPTION: This code shows how to create a thread with an initial comment in a Liveblocks room. It includes setting the user ID and creating a structured comment body with the Liveblocks format.

LANGUAGE: typescript
CODE:
// The unique ID for the room
const roomId = "my-room-id";

// Create a room
const room = await liveblocks.createRoom(roomId, {
  defaultAccesses: [],
});

//+++
// Create a thread
const thread = await liveblocks.createThread({
  roomId,

  data: {
    comment: {
      // ID of the user that created the thread
      userId: "florent@example.com",

      body: {
        version: 1,
        content: [
          // The initial comment's body text goes here
          // {
          //   type: "paragraph",
          //   children: [{ text: "Hello " }, { text: "world", bold: true }],
          // },
        ],
      },
    },
  },
});
// +++

----------------------------------------

TITLE: Demonstrating Old vs New Room API in Liveblocks Client
DESCRIPTION: Example showing the transition from deprecated room APIs to the new recommended pattern for entering and leaving rooms in Liveblocks client.

LANGUAGE: typescript
CODE:
// Old APIs we'll no longer be recommending (but that will remain working)
const room = client.enter("my-room", options);
client.getRoom("my-room");
client.leave("my-room");

LANGUAGE: typescript
CODE:
// New API we'll be recommending instead
const { room, leave } = client.enterRoom("my-room", options);
leave();

----------------------------------------

TITLE: Deploying Liveblocks Comments Email Notifications to Vercel
DESCRIPTION: Command to create and deploy the Liveblocks comments notification email example to Vercel. This sets up the project and prepares it for deployment through Vercel's platform.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-comments-emails-resend --vercel

----------------------------------------

TITLE: Installing Lexical Notification Emails Example with Liveblocks
DESCRIPTION: Command to set up the example project with a Liveblocks API key. This downloads the example and opens a browser to automatically obtain an API key from your Liveblocks account.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-lexical-emails-resend --api-key

----------------------------------------

TITLE: Basic error handling with useErrorListener hook
DESCRIPTION: Example showing how to use the useErrorListener hook to handle Liveblocks errors in your application.

LANGUAGE: ts
CODE:
import { useErrorListener } from "@liveblocks/react/suspense";

useErrorListener((error) => {
  // { message: "You don't have access to this room", context: { ... }}
  console.error(error);
});

----------------------------------------

TITLE: Deleting Single Notification with Client.deleteInboxNotification in TypeScript
DESCRIPTION: Shows how to delete a specific inbox notification for the current user. Requires the ID of the notification to be deleted.

LANGUAGE: typescript
CODE:
await client.deleteInboxNotification("in_xxx");

----------------------------------------

TITLE: Managing User Notification Settings with @liveblocks/node
DESCRIPTION: Demonstrates how to use the new methods in the Node.js client to manage user notification settings, including getting, updating, and deleting notification preferences.

LANGUAGE: tsx
CODE:
import { Liveblocks } from "@liveblocks/node";
const liveblocks = new Liveblocks({ secret: "sk_xxx" });

const settings = await liveblocks.getNotificationSettings({ userId });
// { email: { thread: true, ... }, slack: { thread: false, ... }, ... }
console.log(settings);

const updatedSettings = await liveblocks.updateNotificationSettings({
  userId,
  data: {
    teams: {
      $fileUploaded: true,
    },
  },
});
await liveblocks.deleteNotificationSettings({ userId });

----------------------------------------

TITLE: Deploying To-do List Example to Vercel
DESCRIPTION: Command to set up the example and deploy it to Vercel. This downloads the example and initiates the Vercel deployment process.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example javascript-todo-list --vercel

----------------------------------------

TITLE: Accessing User Data in Liveblocks Rooms
DESCRIPTION: Shows how to access the current user's ID and information in a Liveblocks room using the JavaScript client or React hooks.

LANGUAGE: typescript
CODE:
const self = room.getSelf(); // or useSelf() in React
console.log(self.id);
console.log(self.info);

----------------------------------------

TITLE: Implementing Zustand Store without Liveblocks Middleware
DESCRIPTION: Example of how a Zustand store would be implemented without the Liveblocks middleware. This shows the basic structure of a Zustand store with a TypeScript interface.

LANGUAGE: typescript
CODE:
import create from "zustand";

type State = {
  draft: string;
  isTyping: boolean;
  todos: Todo[];
  setDraft: (draft: string) => void;
  addTodo: () => void;
  deleteTodo: (index: number) => void;
};

create<State>(/* ... */);

----------------------------------------

TITLE: Configuring NPM Workspace for Local Development
DESCRIPTION: JSON configuration for adding an example to NPM workspaces in package.json. This allows linking examples to local Liveblocks packages during development, instead of using published versions.

LANGUAGE: javascript
CODE:
{
  "workspaces": [
    "shared/*",
    "packages/*",
    "e2e/next-sandbox",
    "examples/whatever-example",  // 👈
  ]
}

----------------------------------------

TITLE: Customizing Components with CSS Variables
DESCRIPTION: Demonstrates how to customize the appearance of all default Liveblocks components using CSS variables for accent color, spacing, and border radius.

LANGUAGE: css
CODE:
/* Styles all default components */
.lb-root {
  --lb-accent: purple;
  --lb-spacing: 1em;
  --lb-radius: 0;
}

----------------------------------------

TITLE: Removing a Reaction from a Comment in TypeScript
DESCRIPTION: Example of removing a user's emoji reaction from a comment using room.removeReaction. This requires specifying the thread ID, comment ID, and emoji to remove.

LANGUAGE: ts
CODE:
await room.removeReaction({
  threadId: "th_xxx",
  commentId: "cm_xxx",
  emoji: "👍",
});

----------------------------------------

TITLE: Complete Liveblocks Lexical Editor Implementation
DESCRIPTION: A comprehensive example showing how to set up a collaborative Lexical editor with Liveblocks. It demonstrates importing required components, configuring the editor, and structuring the component hierarchy with LiveblocksPlugin and standard Lexical components.

LANGUAGE: tsx
CODE:
import { LexicalComposer } from "@lexical/react/LexicalComposer";
import { RichTextPlugin } from "@lexical/react/LexicalRichTextPlugin";
import { ContentEditable } from "@lexical/react/LexicalContentEditable";
import { LexicalErrorBoundary } from "@lexical/react/LexicalErrorBoundary";
// +++
import { liveblocksConfig, LiveblocksPlugin } from "@liveblocks/react-lexical";
// +++

const initialConfig = liveblocksConfig({
  namespace: "MyEditor",
  theme: {},
  nodes: [],
  onError: (err) => console.error(err),
});

function Editor() {
  return (
    <LexicalComposer initialConfig={initialConfig}>
      // +++
      <LiveblocksPlugin>
        <FloatingThreads />
        <FloatingComposer />
        <AnchoredThreads />
      </LiveblocksPlugin>
      // +++
      <RichTextPlugin
        contentEditable={<ContentEditable />}
        placeholder={<div>Enter some text...</div>}
        ErrorBoundary={LexicalErrorBoundary}
      />
    </LexicalComposer>
  );
}

----------------------------------------

TITLE: Complete Liveblocks Lexical Editor Implementation
DESCRIPTION: A comprehensive example showing how to set up a collaborative Lexical editor with Liveblocks. It demonstrates importing required components, configuring the editor, and structuring the component hierarchy with LiveblocksPlugin and standard Lexical components.

LANGUAGE: tsx
CODE:
import { LexicalComposer } from "@lexical/react/LexicalComposer";
import { RichTextPlugin } from "@lexical/react/LexicalRichTextPlugin";
import { ContentEditable } from "@lexical/react/LexicalContentEditable";
import { LexicalErrorBoundary } from "@lexical/react/LexicalErrorBoundary";
// +++
import { liveblocksConfig, LiveblocksPlugin } from "@liveblocks/react-lexical";
// +++

const initialConfig = liveblocksConfig({
  namespace: "MyEditor",
  theme: {},
  nodes: [],
  onError: (err) => console.error(err),
});

function Editor() {
  return (
    <LexicalComposer initialConfig={initialConfig}>
      // +++
      <LiveblocksPlugin>
        <FloatingThreads />
        <FloatingComposer />
        <AnchoredThreads />
      </LiveblocksPlugin>
      // +++
      <RichTextPlugin
        contentEditable={<ContentEditable />}
        placeholder={<div>Enter some text...</div>}
        ErrorBoundary={LexicalErrorBoundary}
      />
    </LexicalComposer>
  );
}

----------------------------------------

TITLE: Using Generic Presence Types with Zustand Middleware
DESCRIPTION: Example showing how to type the presence data in Liveblocks Zustand middleware using the TPresence generic argument, enabling type-safe access to other users' presence data.

LANGUAGE: typescript
CODE:
type Presence = {
  isTyping: true;
}

const useStore = create(
  middleware<State, Presence>(/* ... */, {
    client,
    presenceMapping: { isTyping: true },
    storageMapping: { todos: true }
  })
);

// In your component
useStore(state => state.liveblocks.others[0].presence?.isTyping)

----------------------------------------

TITLE: Configuring User Mentions with LiveblocksProvider in React
DESCRIPTION: Sets up the LiveblocksProvider component with resolveUsers and resolveMentionSuggestions functions to enable user mentions and suggestions in the text editor.

LANGUAGE: tsx
CODE:
import { LiveblocksProvider } from "@liveblocks/react/suspense";

function App() {
  return (
    <LiveblocksProvider
      resolveUsers={async ({ userIds }) => {
        // Return user info from their `userIds`
        // ...
      }}
      resolveMentionSuggestions={async ({ text, roomId }) => {
        // Return suggestions from the search `text`
        // ...
      }}
    >
      {/* children */}
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Configuring LiveblocksProvider with preventUnsavedChanges Option
DESCRIPTION: Shows how to configure the LiveblocksProvider component to prevent browser tabs from being closed while local changes are not yet synchronized to the server.

LANGUAGE: tsx
CODE:
<LiveblocksProvider preventUnsavedChanges />

----------------------------------------

TITLE: Setting Up ErrorBoundary and ClientSideSuspense for Liveblocks Hooks
DESCRIPTION: This snippet demonstrates how to use ErrorBoundary and ClientSideSuspense to handle errors and loading states when using Suspense-enabled Liveblocks hooks.

LANGUAGE: tsx
CODE:
import { ClientSideSuspense } from "@liveblocks/react";
import { ErrorBoundary } from "react-error-boundary";

// Handle errors and loading state in the component above
function Component() {
  return (
    <ErrorBoundary fallback={<div>Error</div>}>
      <ClientSideSuspense fallback={<div>Loading...</div>}>
        <MyNotifications />
      </ClientSideSuspense>
    </ErrorBoundary>
  );
}

----------------------------------------

TITLE: Creating HTML Element for Quill Editor
DESCRIPTION: Creates a div element with the ID 'editor' that will be used as the container for the Quill editor.

LANGUAGE: html
CODE:
<div id="editor"></div>

----------------------------------------

TITLE: Updating enterRoom usage in Redux
DESCRIPTION: Code demonstrating the change in enterRoom usage where explicit initial state should be removed, as it will now use the state from the Redux store.

LANGUAGE: ts
CODE:
useEffect(() => {
  enterRoom("room-id", {
    todos: [], // 👈 remove explicit initial state
  });
});

LANGUAGE: ts
CODE:
useEffect(() => {
  enterRoom("room-id");
});

----------------------------------------

TITLE: Rendering Inbox Notifications with useInboxNotifications in React
DESCRIPTION: Basic implementation of displaying inbox notifications using the useInboxNotifications hook to map through notifications and render them with the InboxNotification component.

LANGUAGE: tsx
CODE:
import { InboxNotification } from "@liveblocks/react-ui";
import { useInboxNotifications } from "../liveblocks.config";

function Component() {
  const { inboxNotifications } = useInboxNotifications();

  return (
    <>
      {inboxNotifications.map((inboxNotification) => (
        <InboxNotification
          key={inboxNotification.id}
          inboxNotification={inboxNotification}
        />
      ))}
    </>
  );
}

----------------------------------------

TITLE: Verifying Webhook Requests with Liveblocks Node.js
DESCRIPTION: This snippet demonstrates how to set up webhook verification using the WebhookHandler from @liveblocks/node. It verifies incoming webhook requests by checking headers and the request body against a webhook secret key.

LANGUAGE: typescript
CODE:
import { WebhookHandler } from "@liveblocks/node";

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // Send notifications
  // ...

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Creating and Deploying the Example on Vercel
DESCRIPTION: Command to download the example and set up deployment on Vercel, which will open a browser to complete the process.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example redux-whiteboard --vercel

----------------------------------------

TITLE: Installing the Collaborative Text Editor Example with Liveblocks CLI
DESCRIPTION: Command to set up the collaborative text editor example using the Liveblocks CLI, which downloads the example and helps configure your API key automatically.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-blocknote --api-key

----------------------------------------

TITLE: Installing the Multiplayer 3D Builder with Create Liveblocks App
DESCRIPTION: Command to download and set up the Multiplayer 3D Builder example using the create-liveblocks-app CLI tool. This automatically downloads the example code and helps set up the required API key from a Liveblocks account.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-3d-builder --api-key

----------------------------------------

TITLE: Basic AnchoredThreads Implementation
DESCRIPTION: Shows the basic usage of the AnchoredThreads component to display thread components vertically alongside the editor. This component positions threads at the same vertical coordinates as their corresponding text highlights.

LANGUAGE: tsx
CODE:
<AnchoredThreads editor={editor} threads={threads} />

----------------------------------------

TITLE: Example User IDs and Information Format for Comments
DESCRIPTION: This shell example shows the expected format for user IDs that Liveblocks will request, and the corresponding user information that should be returned. The returned user array should have the same length and order as the userIds array.

LANGUAGE: shell
CODE:
# If this is `userIds`
["marc@example.com", "pierre@example.com"]

# Return `users`
[{ name: "Marc", avatar: "https://example.com/marc.png" }, { name: "Pierre", avatar: "https://example.com/pierre.png" }]

----------------------------------------

TITLE: Creating and Sending Yjs Document Updates in Liveblocks
DESCRIPTION: Demonstrates how to create a Yjs document with text content, encode it as a binary update, and send it to Liveblocks to update a room's document.

LANGUAGE: typescript
CODE:
import * as Y from "yjs";

// Create a Yjs document
const yDoc = new Y.Doc();

// Create your data structures and make your update
// If you're using a text editor, you need to match its format
const yText = yDoc.getText("text");
yText.insert(0, "Hello world");

// Encode the document state as an update
const update = Y.encodeStateAsUpdate(yDoc);

// Send update to Liveblocks
await liveblocks.sendYjsBinaryUpdate("my-room-id", update);

----------------------------------------

TITLE: Creating Multiple BlockNote Editors with Unique Fields
DESCRIPTION: This example demonstrates how to create multiple BlockNote editors on a single page by assigning each editor a unique field identifier. This allows each editor to have its own collaborative space and features.

LANGUAGE: tsx
CODE:
import { useCreateBlockNoteWithLiveblocks } from "@liveblocks/react-blocknote";

function TextEditor() {
  const editor = useCreateBlockNoteWithLiveblocks(
    {},
    {
      field: "editor-one",
    }
  );

  // ...
}

----------------------------------------

TITLE: UserLeftEvent Schema in TypeScript
DESCRIPTION: TypeScript schema and example for the UserLeftEvent webhook. This event is triggered when a user disconnects from a room and includes details about the user and the updated count of active users.

LANGUAGE: typescript
CODE:
// Schema
type UserLeftEvent = {
  type: "userLeft";
  data: {
    projectId: string;
    roomId: string;
    connectionId: number;
    userId: string | null;
    userInfo: Record<string, any> | null;
    leftAt: string;
    numActiveUsers: number;
  };
};

// Example
const userLeftEvent = {
  type: "userLeft",
  data: {
    projectId: "my-project-id",
    roomId: "my-room-id",
    connectionId: 4,
    userId: "a-user-id",
    userInfo: {
      name: "John Doe",
    },
    leftAt: "2021-10-06T01:45:56.558Z",
    numActiveUsers: 7,
  },
};

----------------------------------------

TITLE: Creating a Next.js Route Handler for Liveblocks Notifications
DESCRIPTION: A basic Next.js route handler that serves as an endpoint for receiving webhook events from Liveblocks. This handler extracts the request body and headers, which will be used to process notification events for unread comments.

LANGUAGE: typescript
CODE:
export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Handle webhooks and notifications
  // ...

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Installing Collaborative To-do List Example with Liveblocks CLI
DESCRIPTION: Command to download and install the collaborative to-do list example using the Liveblocks CLI tool. This creates a new project with all necessary dependencies without requiring an API key or Vercel deployment.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example zustand-todo-list --no-api-key --no-vercel

----------------------------------------

TITLE: Creating a Mixed Custom Toolbar with Default and Custom Buttons
DESCRIPTION: This example shows how to create a custom toolbar that mixes default sections with custom buttons, including a history section, custom help button, and a highlight toggle that requires a Tiptap extension.

LANGUAGE: tsx
CODE:
import { Toolbar } from "@liveblocks/react-tiptap";
import { Icon } from "@liveblocks/react-ui";
import { Editor } from "@tiptap/react";

function CustomToolbar({ editor }: { editor: Editor | null }) {
  return (
    <Toolbar editor={editor}>
      // +++
      <Toolbar.SectionHistory />
      <Toolbar.Separator />
      <Toolbar.Button
        name="Help"
        icon={<Icon.QuestionMark />}
        shortcut="CMD-H"
        onClick={() => console.log("help")}
      />
      <Toolbar.Toggle
        name="Highlight"
        icon={<div>🖊️</div>}
        active={editor?.isActive("highlight") ?? false}
        onClick={() => editor?.chain().focus().toggleHighlight().run()}
        disabled={!editor?.can().chain().focus().toggleHighlight().run()}
      />
      // +++
    </Toolbar>
  );
}

----------------------------------------

TITLE: Setting Up User Notification Settings with CURL Request
DESCRIPTION: CURL command to initialize project notification settings needed for user notification e2e tests. Posts to the dashboard API endpoint with authorization token to configure the required settings.

LANGUAGE: sh
CODE:
curl -X POST \
  'https://<dev_worker_url>/dashboard/projects/<project_id>/notification-settings/setup' \
  -H 'Content-Type: application/json' \
  -H 'Authorization: <authorization_token>' \
  -d '{}'

----------------------------------------

TITLE: Accessing User Notification Settings with Liveblocks Client in TypeScript
DESCRIPTION: Demonstrates how to use the Liveblocks client to retrieve and update user notification settings. This snippet shows creating a client instance, getting current notification settings, and updating them to disable thread notifications for email.

LANGUAGE: typescript
CODE:
import { createClient } from '@liveblocks/client'
const client = createClient({ ... })

const settings = await client.getNotificationSettings();
// { email: { thread: true, ... }, slack: { thread: false, ... }, ... }
console.log(settings);

const updatedSettings = await client.updateNotificationSettings({
  email: {
    thread: false,
  }
});

----------------------------------------

TITLE: Installing the Liveblocks Comments with OpenAI Example
DESCRIPTION: Command to download and set up the Liveblocks example project with AI-powered comments. This automatically downloads the example and guides you through setting up your Liveblocks API key.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-comments-ai --api-key

----------------------------------------

TITLE: Manual Installation for Liveblocks Project
DESCRIPTION: Command to install all dependencies for the project using npm. This is part of the manual setup process for the live form selection example.

LANGUAGE: bash
CODE:
npm install

----------------------------------------

TITLE: Setting Room Permissions in Liveblocks
DESCRIPTION: Demonstrates how to create a room with specific permission settings using the Liveblocks Node SDK. This example sets default read-only access while giving write permissions to specific groups and users.

LANGUAGE: typescript
CODE:
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

const room = await liveblocks.createRoom("my-room-id", {
  defaultAccesses: ["room:read", "room:presence:write"],
  groupsAccesses: {
    "my-group-id": ["room:write"],
  },
  usersAccesses: {
    "my-user-id": ["room:write"],
  },
});

----------------------------------------

TITLE: Importing Liveblocks React Hooks - Before and After v2.0
DESCRIPTION: Comparison showing how hooks can now be imported directly from @liveblocks/react instead of from a configuration file.

LANGUAGE: typescript
CODE:
// ❌ Before: get hooks exported from your Liveblocks config
import { RoomProvider, useRoom, ... } from "./liveblocks.config";

// ✅ After: import hooks directly
import { RoomProvider, useRoom, ... } from "@liveblocks/react";
import { RoomProvider, useRoom, ... } from "@liveblocks/react/suspense";

----------------------------------------

TITLE: Broadcasting Revalidation Events with Liveblocks
DESCRIPTION: Using Liveblocks' useBroadcastEvent hook to send a custom REVALIDATE event to other clients. This function creates a broadcast that will notify other connected clients that they should refresh their data.

LANGUAGE: tsx
CODE:
const broadcast = useBroadcastEvent();

// Sending a custom REVALIDATE event
broadcast({ type: "REVALIDATE" });

----------------------------------------

TITLE: Creating a Comment in a Thread in TypeScript
DESCRIPTION: Example of creating a new comment within an existing thread using room.createComment. This requires specifying the thread ID and providing a formatted comment body.

LANGUAGE: ts
CODE:
const comment = await room.createComment({
  threadId: "th_xxx",
  body: {
    version: 1,
    content: [{ type: "paragraph", children: [{ text: "Hello" }] }],
  },
});

----------------------------------------

TITLE: Complete FloatingToolbar setup with collaboration features
DESCRIPTION: Demonstrates a complete setup for a text editor with FloatingToolbar, FloatingComposer for comments, and FloatingThreads for displaying comment threads.

LANGUAGE: tsx
CODE:
import {
  useLiveblocksExtension,
  // +++
  FloatingToolbar,
  // +++
  FloatingComposer,
  FloatingThreads,
} from "@liveblocks/react-tiptap";
import { useEditor, EditorContent } from "@tiptap/react";

function TextEditor() {
  const liveblocks = useLiveblocksExtension();

  const editor = useEditor({
    extensions: [
      liveblocks,
      // ...
    ],
  });

  return (
    <div>
      <EditorContent editor={editor} />
      // +++
      <FloatingToolbar editor={editor} />
      // +++
      <FloatingComposer editor={editor} style={{ width: "350px" }} />
      <FloatingThreads editor={editor} style={{ width: "350px" }} />
    </div>
  );
}

----------------------------------------

TITLE: Using WebhookHandler to Verify Webhook Requests in TypeScript
DESCRIPTION: The WebhookHandler class is used to verify webhook event requests from Liveblocks. It validates the rawBody and headers of incoming webhook requests against a secret.

LANGUAGE: typescript
CODE:
new WebhookHandler(secret).verifyRequest({ rawBody, headers })

----------------------------------------

TITLE: Adding Liveblocks Components to Tiptap Editor
DESCRIPTION: This snippet shows how to add Liveblocks Tiptap components like FloatingComposer to your editor. These components need to be passed the editor instance to enable their functionality.

LANGUAGE: tsx
CODE:
import {
  useLiveblocksExtension,
  // +++
  FloatingComposer,
  // +++
} from "@liveblocks/react-tiptap";
import { useEditor, EditorContent } from "@tiptap/react";

function TextEditor() {
  const liveblocks = useLiveblocksExtension();

  const editor = useEditor({
    extensions: [
      liveblocks,
      // ...
    ],
  });

  return (
    <div>
      <EditorContent editor={editor} />
      // +++
      <FloatingComposer editor={editor} style={{ width: "350px" }} />
      // +++
    </div>
  );
}

----------------------------------------

TITLE: Adding ClientSideSuspense for Loading State
DESCRIPTION: Enhanced React component that adds a ClientSideSuspense wrapper to handle loading states while connecting to the Liveblocks room.

LANGUAGE: tsx
CODE:
"use client";

import {
  LiveblocksProvider,
  RoomProvider,
  ClientSideSuspense,
} from "@liveblocks/react/suspense";
import { Editor } from "./Editor";

export default function App() {
  return (
    <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>
      <RoomProvider id="my-room">
        <ClientSideSuspense fallback={<div>Loading…</div>}>
          <Editor />
        </ClientSideSuspense>
      </RoomProvider>
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Updating Redux enhancer import in @liveblocks/redux
DESCRIPTION: Code showing the migration from the old enhancer import to the new liveblocksEnhancer import in @liveblocks/redux.

LANGUAGE: ts
CODE:
import { enhancer } from "@liveblocks/redux";

LANGUAGE: ts
CODE:
import { liveblocksEnhancer } from "@liveblocks/redux";

----------------------------------------

TITLE: Deploying the Liveblocks tldraw Example to Vercel
DESCRIPTION: Command for downloading the example project and deploying it to Vercel. This opens the browser to facilitate the deployment process.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-tldraw-whiteboard-yjs --vercel

----------------------------------------

TITLE: Installing MySQL2 Package for Database Connection
DESCRIPTION: Bash command to install the mysql2 npm package, which is required to connect to the PlanetScale MySQL database from the Node.js application.

LANGUAGE: bash
CODE:
npm i mysql2

----------------------------------------

TITLE: Styling Liveblocks Primitives with CSS Modules
DESCRIPTION: Demonstrates styling Liveblocks primitives using CSS modules. This allows for scoped styling of components with imported CSS class names.

LANGUAGE: tsx
CODE:
import { Composer } from "@liveblocks/react-ui";
import styles from "./Component.module.css";

function Component() {
  return <Composer.Submit className={styles.submit}>Reply</Composer.Submit>;
}

----------------------------------------

TITLE: Fetching Updated Threads Since a Timestamp in Liveblocks (TypeScript)
DESCRIPTION: Demonstrates how to fetch threads that have been updated or deleted since a specific timestamp. This is useful for polling updates after an initial fetch of all threads.

LANGUAGE: typescript
CODE:
const initial = await room.getThreads();

const { threads, inboxNotifications, requestedAt } = await room.getThreadsSince(
  { since: initial.requestedAt }
);

// { updated: [{ id: "th_s4368s...", type: "thread" }, ...], deleted: [...] }
console.log(threads);

// { updated: [{ id: "in_ds83hs...", kind: "thread", }, ...], deleted: [...] }
console.log(inboxNotifications);

----------------------------------------

TITLE: Displaying Unread Notification Count with useUnreadInboxNotificationsCount Hook
DESCRIPTION: This snippet shows how to use the useUnreadInboxNotificationsCount hook to display the number of unread notifications for the current user.

LANGUAGE: tsx
CODE:
import { useUnreadInboxNotificationsCount } from "../liveblocks.config";

function Component() {
  const { count } = useUnreadInboxNotificationsCount();

  // 3
  console.log(count);

  return <div>You have {count} unread notifications</div>;
}

----------------------------------------

TITLE: Updating metadata filtering from undefined to null (After)
DESCRIPTION: Example showing the correct way to filter threads by absence of metadata in Liveblocks 2.16 using null instead of undefined.

LANGUAGE: ts
CODE:
const threads = useThreads({
  query: {
    metadata: {
      // ✅ After - Will now find threads without a `color`
      // +++
      color: null,
      // +++
      label: "important",
    },
  },
});

----------------------------------------

TITLE: Configuring Hidden Pages in Navigation JSON
DESCRIPTION: Demonstrates how to create pages that are generated but don't appear in the navigation menu by using the 'hidden' property in the routes configuration.

LANGUAGE: json
CODE:
{
  "title": "API v1 Endpoints",
  "hidden": true,
  "path": "/api-reference/rest-api-endpoints-v1"
}

----------------------------------------

TITLE: Configuring External Links in Navigation JSON
DESCRIPTION: Shows how to add external links to the documentation navigation by using the 'href' property instead of 'path' in the routes configuration.

LANGUAGE: json
CODE:
{
  "title": "System status",
  "href": "https://liveblocks.statuspage.io/"
}

----------------------------------------

TITLE: Deploying Liveblocks Overlay Comments Example on Vercel
DESCRIPTION: Command to download the example project and open a browser window for deploying it to Vercel.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-comments-overlay --vercel

----------------------------------------

TITLE: Setting up BlockNote with Liveblocks basic implementation
DESCRIPTION: Basic implementation of BlockNote with Liveblocks collaborative features using the useCreateBlockNoteWithLiveblocks hook and BlockNoteView component.

LANGUAGE: tsx
CODE:
import { useCreateBlockNoteWithLiveblocks } from "@liveblocks/react-blocknote";
import { BlockNoteView } from "@blocknote/mantine";

function TextEditor() {
  // +++
  const editor = useCreateBlockNoteWithLiveblocks({});
  // +++

  return (
    <div>
      // +++
      <BlockNoteView editor={editor} />
      // +++
    </div>
  );
}

----------------------------------------

TITLE: Using Toolbar.SectionCollaboration for comments
DESCRIPTION: Demonstrates how to add a section containing an add comment button to enable collaboration features in the toolbar.

LANGUAGE: tsx
CODE:
import { Toolbar } from "@liveblocks/react-tiptap";

<Toolbar editor={editor}>
  // +++
  <Toolbar.SectionCollaboration />
  // +++
</Toolbar>;

----------------------------------------

TITLE: Generating NextAuth Secret for Authentication
DESCRIPTION: Command to create a NextAuth secret that's needed for authentication within the application. This secret is required before the project can be run successfully.

LANGUAGE: bash
CODE:
npx auth secret

----------------------------------------

TITLE: Creating a Basic Next.js Webhook Endpoint for Liveblocks
DESCRIPTION: A simple Next.js route handler that serves as the webhook endpoint. This code handles POST requests and extracts headers and body for further processing.

LANGUAGE: typescript
CODE:
export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Handle webhooks and database
  // ...

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Advanced Client Configuration with Custom Headers
DESCRIPTION: An alternative way to configure the Liveblocks client using a callback function that allows passing custom headers and body data to the authentication endpoint.

LANGUAGE: typescript
CODE:
import { createClient } from "@liveblocks/client";

// Passing custom headers and body to your endpoint
const client = createClient({
  authEndpoint: async (room) => {
    const headers = {
      // Custom headers
      // ...

      "Content-Type": "application/json",
    };

    const body = JSON.stringify({
      // Custom body
      // ...

      room,
    });

    const response = await fetch("/api/liveblocks-auth", {
      method: "POST",
      headers,
      body,
    });

    return await response.json();
  },
});

----------------------------------------

TITLE: Using useNotificationSettings Hook in React
DESCRIPTION: Shows how to implement the useNotificationSettings hook to retrieve and update user notification settings in a React component, handling loading states and errors.

LANGUAGE: tsx
CODE:
// A suspense version of this hook is available
import { useNotificationSettings } from "@liveblocks/react";

const [{ isLoading, error, settings }, updateSettings] =
  useNotificationSettings();
// { email: { thread: true, ... }, slack: { thread: false, ... }, ... }
console.log(settings);

const onSave = () => {
  updateSettings({
    slack: {
      textMention: true,
    },
  });
};

----------------------------------------

TITLE: Listening for Yjs Subdocument Changes
DESCRIPTION: Shows how to listen for changes to subdocuments using the Y.Doc 'subdocs' event. This allows tracking when subdocuments are added, removed, or loaded.

LANGUAGE: ts
CODE:
import { LiveblocksYjsProvider } from "@liveblocks/yjs";
import * as Y from "yjs";

// Create main document and connect, disabling auto-loading of subdocuments
const yDoc = new Y.Doc();
const yProvider = new LiveblocksYjsProvider(room, yDoc, {
  autoloadSubdocs: false,
});

yDoc.on("subdocs", ({ added, removed, loaded }) => {
  // Subdocument change
  // ...
});

----------------------------------------

TITLE: Retrieving Threads with useThreads in React
DESCRIPTION: Example of using the useThreads hook to retrieve and display a list of threads in a component. The hook returns an array of thread objects that can be mapped to render Thread components.

LANGUAGE: tsx
CODE:
import { useThreads } from "../liveblocks.config";

function Component() {
  const { threads } = useThreads();

  // [{ type: "thread", id: "th_sf8s6sh...", ... }, ...]
  console.log(threads);

  return (
    <>
      {threads.map((thread) => (
        <Thread key={thread.id} thread={thread} />
      ))}
    </>
  );
}

----------------------------------------

TITLE: Serial Execution of Async Functions in Subscription Callbacks
DESCRIPTION: Uses async-mutex to ensure that async functions in subscription callbacks run serially, forming a queue for all upcoming updates to guarantee execution order.

LANGUAGE: typescript
CODE:
import { Mutex } from "async-mutex";

const { root } = await room.getStorage();
const myMutex = new Mutex();

const unsubscribeUpdates = room.subscribe(root, (root) => {
  void myMutex.runExclusive(async () => {
    await fetch(/* ... */);
  });
});

----------------------------------------

TITLE: Using WebhookHandler to verify webhook requests
DESCRIPTION: Example of using the new WebhookHandler class to verify event requests from Liveblocks Webhooks. This ensures events are coming from legitimate sources and provides typed WebhookEvents.

LANGUAGE: typescript
CODE:
import { WebhookHandler } from "@liveblocks/node";

const webhookHandler = new WebhookHandler(process.env.SECRET);

const event = webhookHandler.verifyRequest({
  headers: req.headers,
  rawBody: req.body,
});

----------------------------------------

TITLE: Configuring preventUnsavedChanges Option in LiveblocksProvider
DESCRIPTION: Example showing how to enable the preventUnsavedChanges option on the LiveblocksProvider component to prevent browser tabs from being closed while local changes are not yet synchronized.

LANGUAGE: tsx
CODE:
<LiveblocksProvider preventUnsavedChanges />

----------------------------------------

TITLE: Retrieving Liveblocks Inbox Notification
DESCRIPTION: Code for retrieving an inbox notification using the Liveblocks API. This uses data from the notification event to fetch detailed notification information.

LANGUAGE: typescript
CODE:
// Data from the `notification` event
const { inboxNotificationId, userId } = event.data;

// Get the inbox notification, which details when the user last read the thread
const inboxNotification = await liveblocks.getInboxNotification({
  inboxNotificationId,
  userId,
});

// { kind: "$myCustomNotification", readAt: Date<2024-07-13T14:32:50.697Z>, ... }
console.log(inboxNotification);

----------------------------------------

TITLE: Accessing Other Users' Cursor Positions with Liveblocks
DESCRIPTION: Example showing how to retrieve cursor positions from other users in the room. This snippet demonstrates how to map through the 'others' array to access each user's presence data.

LANGUAGE: tsx
CODE:
function App() {
  /* ... */

  const others = useStore((state) => state.liveblocks.others);
  const othersCursors = others.map((user) => user.presence.cursor);

  // Render cursors with custom SVGs based on x and y
}

----------------------------------------

TITLE: Upgrading Liveblocks Packages with CLI
DESCRIPTION: Command to upgrade all Liveblocks packages to version 2.15 using the create-liveblocks-app CLI tool.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --upgrade

----------------------------------------

TITLE: Initializing Liveblocks configuration file
DESCRIPTION: Command to create a liveblocks.config.ts file that can be used later to define types for the application.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --init --framework javascript

----------------------------------------

TITLE: Old Pattern: Null Checks for Liveblocks Data
DESCRIPTION: Example of code with null checks for Liveblocks data that can be removed when using Suspense-enabled hooks, as they guarantee data is available before rendering.

LANGUAGE: tsx
CODE:
function Component() {
  const a = useMap("a");
  const b = useList("b");
  const c = useObject("c");

  if (a == null || b == null || c == null) {
    return <Loading />;
  }

  /* ... */
}

----------------------------------------

TITLE: Declaring UserMeta Types for Liveblocks
DESCRIPTION: TypeScript type declaration for user metadata in Liveblocks configuration file. This provides type hints in the editor and ensures consistency with the metadata format used throughout the application.

LANGUAGE: typescript
CODE:
declare global {
  interface Liveblocks {
    UserMeta: {
      id: string;

      info: {
        name: string;
        avatar: string;

        // Your custom metadata
        // ...
      };
    };
  }
}

----------------------------------------

TITLE: Installing Liveblocks Next.js Starter Kit
DESCRIPTION: Command to create a new Liveblocks project using the Next.js template. This will run an installer that allows you to download, configure, and deploy your collaborative SaaS application.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --next

----------------------------------------

TITLE: Converting Lexical Document to Markdown
DESCRIPTION: Demonstrates how to convert a Lexical document to markdown format using the toMarkdown method. This allows for exporting Lexical content in a widely supported text format.

LANGUAGE: typescript
CODE:
const markdown = await withLexicalDocument(
  { roomId: "my-room-id", client: liveblocks },
  async (doc) => {
    return doc.toMarkdown();
  }
);

----------------------------------------

TITLE: Basic SWR Hook for Fetching User Data in React
DESCRIPTION: A simple implementation of SWR to fetch a list of users. This component uses the useSWR hook to fetch data from the '/api/users' endpoint and displays the returned user list.

LANGUAGE: tsx
CODE:
function Component() {
  const { data: users, mutate } = useSWR("/api/users", fetcher);

  return (
     <div>
       {users.map((user) => /* ... */)}:
     </div>
  );
}

----------------------------------------

TITLE: Thread Object Structure in Liveblocks Comments
DESCRIPTION: This snippet shows the structure of a thread object in Liveblocks Comments. The thread contains an ID, room ID, creation timestamp, resolution status, list of comments, and custom metadata.

LANGUAGE: typescript
CODE:
{
  type: "thread",
  id: "th_sf8s6sh...",
  roomId: "my-room-id",
  createdAt: Date <Fri Dec 15 2023 14:15:22 GMT+0000 (Greenwich Mean Time)>,
  resolved: false,
  comments: [
    // A list of comments in the thread
    // ...
  ],
  metadata: {
    // Your custom thread metadata
    // ...
  },
}

----------------------------------------

TITLE: Creating HTML Element for Editor
DESCRIPTION: HTML markup to create a container element for the Tiptap editor with the ID 'editor', which will be targeted by JavaScript.

LANGUAGE: html
CODE:
<div id="editor"></div>

----------------------------------------

TITLE: Creating HTML Element for Editor
DESCRIPTION: HTML markup to create a container element for the Tiptap editor with the ID 'editor', which will be targeted by JavaScript.

LANGUAGE: html
CODE:
<div id="editor"></div>

----------------------------------------

TITLE: Implementing InboxNotificationList for Organized Display
DESCRIPTION: Implementation of notifications list using InboxNotificationList component to render notifications as an ordered HTML list structure.

LANGUAGE: tsx
CODE:
import { InboxNotification, InboxNotificationList } from "@liveblocks/react-ui";
import { useInboxNotifications } from "../liveblocks.config";

function Component() {
  const { inboxNotifications } = useInboxNotifications();

  return (
    <InboxNotificationList>
      {inboxNotifications.map((inboxNotification) => (
        <InboxNotification
          key={inboxNotification.id}
          inboxNotification={inboxNotification}
        />
      ))}
    </InboxNotificationList>
  );
}

----------------------------------------

TITLE: CSS Variables for Comments - Before
DESCRIPTION: Previous approach to styling tooltips and elevations in Liveblocks 1.9 using global CSS variables that have been removed in 1.10.

LANGUAGE: css
CODE:
/* ❌ Before - Liveblocks 1.9 */
:root {
  --lb-tooltip-foreground: white;
  --lb-elevation-background: red;
}

----------------------------------------

TITLE: Handling Liveblocks Notification Event Object
DESCRIPTION: Example of a notification event object sent by Liveblocks webhook when a user receives a new inbox notification on the email channel.

LANGUAGE: typescript
CODE:
const event = {
  type: "notification",
  data: {
    channel: "email",
    kind: "$myCustomNotification",
    projectId: "my-project-id",
    roomId: "my-room-id",
    userId: "my-user-id",
    inboxNotificationId: "in_xt3p7ak...",
    createdAt: "2021-10-06T01:45:56.558Z",
  },
};

----------------------------------------

TITLE: Modifying Lexical Documents with Paragraphs and Text Nodes
DESCRIPTION: Provides an example of modifying a Lexical document by adding paragraph and text nodes. This demonstrates how to use Lexical's node creation and manipulation APIs with the Liveblocks document interface.

LANGUAGE: typescript
CODE:
import { $getRoot } from "lexical";
import { $createParagraphNode, $createTextNode } from "lexical/nodes";

await withLexicalDocument(
  { roomId: "my-room-id", client: liveblocks },
  async (doc) => {
    await doc.update(() => {
      // Adding a paragraph node with contained text node
      const root = $getRoot();
      const paragraphNode = $createParagraphNode();
      const textNode = $createTextNode("Hello world");
      paragraphNode.append(textNode);
      root.append(paragraphNode);
    });
  }
);

----------------------------------------

TITLE: Installing Liveblocks Node Package
DESCRIPTION: Command to install the @liveblocks/node package which is required for setting up server-side authentication.

LANGUAGE: bash
CODE:
npm install @liveblocks/node

----------------------------------------

TITLE: Installing Liveblocks Collaborative Dashboard Example with CLI
DESCRIPTION: Command to create a new Liveblocks application using the nextjs-dashboard example template, with automatic API key configuration. This is the recommended way to get started with the project.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-dashboard --api-key

----------------------------------------

TITLE: Framework Selection Component in JSX
DESCRIPTION: A JSX component that displays a grid of framework options for ID token authentication. It uses the ListGrid and DocsCard components to present various frameworks with icons and links to their specific documentation pages.

LANGUAGE: jsx
CODE:
<ListGrid columns={3}>
  <DocsCard
    title="Next.js"
    href="/docs/authentication/id-token/nextjs"
    visual={<DocsNextjsIcon />}
  />
  <DocsCard
    title="Remix"
    href="/docs/authentication/id-token/remix"
    visual={<DocsRemixIcon />}
  />
  <DocsCard
    title="SvelteKit"
    href="/docs/authentication/id-token/sveltekit"
    visual={<DocsSvelteIcon />}
  />
  <DocsCard
    title="Nuxt.js"
    href="/docs/authentication/id-token/nuxtjs"
    visual={<DocsNuxtjsIcon />}
  />
  <DocsCard
    title="Express"
    href="/docs/authentication/id-token/express"
    visual={<DocsExpressIcon />}
  />
  <DocsCard
    title="Firebase"
    href="/docs/authentication/id-token/firebase"
    visual={<DocsFirebaseIcon />}
  />
</ListGrid>

----------------------------------------

TITLE: Using useUpdateNotificationSettings Hook in React
DESCRIPTION: Demonstrates how to implement a simpler hook for just updating notification settings, useful for scenarios like unsubscribe buttons without needing to fetch current settings.

LANGUAGE: tsx
CODE:
// A suspense version of this hook is available
import { useUpdateNotificationSettings } from "@liveblocks/react";

const updateSettings = useUpdateNotificationSettings();

const onUnsubscribe = () => {
  updateSettings({
    slack: {
      thread: false,
    },
  });
};

----------------------------------------

TITLE: Initializing Liveblocks Yjs Provider with Subdocuments Support
DESCRIPTION: Sets up the main Yjs document with Liveblocks provider, disabling automatic loading of subdocuments to allow for lazy loading. Creates a map to store subdocuments references.

LANGUAGE: ts
CODE:
import { LiveblocksYjsProvider } from "@liveblocks/yjs";
import * as Y from "yjs";

// Create main document and connect, disabling auto-loading of subdocuments
const yDoc = new Y.Doc();
const yProvider = new LiveblocksYjsProvider(room, doc, {
  autoloadSubdocs: false,
});

// Create a Y.Map to hold subdocuments
const subdocMap = yDoc.getMap("subdocs");

----------------------------------------

TITLE: Configuring Mention Suggestions in Liveblocks Client
DESCRIPTION: Demonstrates how to provide a resolver function to the resolveMentionSuggestions option in createClient to enable mentions in Comments. The resolver function searches for matching users based on the text being typed.

LANGUAGE: tsx
CODE:
import { createClient } from "@liveblocks/client";

const client = createClient({
  resolveMentionSuggestions: async ({ text, roomId }) => {
    const workspaceUsers = await __getWorkspaceUsersFromDB__(roomId);

    if (!text) {
      // Show all workspace users by default
      return __getUserIds__(workspaceUsers);
    } else {
      const matchingUsers = __findUsers__(workspaceUsers, text);
      return __getUserIds__(matchingUsers);
    }
  },

  // Other options
  // ...
});

----------------------------------------

TITLE: Subscribing to Storage Status in Liveblocks Client
DESCRIPTION: Example showing how to subscribe to storage status changes using the Room.subscribe method with the 'storage-status' event. This allows tracking different states of storage synchronization with the Liveblocks servers.

LANGUAGE: typescript
CODE:
room.subscribe("storage-status", (status) => {
  switch (status) {
    case "not-loaded":
      break;
    case "loading":
      break;
    case "synchronizing":
      break;
    case "synchronized":
      break;
    default:
      break;
  }
});

----------------------------------------

TITLE: Importing Hooks Directly in Liveblocks React Components
DESCRIPTION: Example showing the improved import structure in v2.0, where hooks can be imported directly from @liveblocks/react packages instead of from a configuration file.

LANGUAGE: typescript
CODE:
// ❌ Before: get hooks exported from your Liveblocks config
import { RoomProvider, useRoom, ... } from "./liveblocks.config";

// ✅ After: import hooks directly
import { RoomProvider, useRoom, ... } from "@liveblocks/react";
import { RoomProvider, useRoom, ... } from "@liveblocks/react/suspense";

----------------------------------------

TITLE: Using Mutation Hooks to Edit Thread Metadata
DESCRIPTION: Example showing how to use the useEditThreadMetadata hook to create a button that sets the 'pinned' metadata property to true for a specific thread.

LANGUAGE: tsx
CODE:
import { useEditThreadMetadata } from "../liveblocks.config";

// Button that sets `pinned` metadata to `true`
function Component() {
  const editThreadMetadata = useEditThreadMetadata();

  return (
    <button
      onClick={() =>
        editThreadMetadata({
          threadId: "th_d75sF3...",
          metadata: { pinned: true },
        })
      }
    >
      Pin thread
    </button>
  );
}

----------------------------------------

TITLE: Implementing Cursor Tracking Container with Event Handlers in React
DESCRIPTION: This JSX component creates a full-viewport container that tracks pointer movements and departures, updating presence accordingly. It also displays the current cursor coordinates from myPresence.

LANGUAGE: tsx
CODE:
return (
  <div
    style={{ width: "100vw", height: "100vh" }}
    onPointerMove={handlePointerMove}
    onPointerLeave={handlePointerLeave}
  >
    Cursor: {JSON.stringify(myPresence.cursor)}
  </div>
);

----------------------------------------

TITLE: Running Local Webhook Testing with Localtunnel
DESCRIPTION: Command to use localtunnel for exposing a local development server to the internet, allowing Liveblocks to send webhook events to your local environment for testing purposes.

LANGUAGE: bash
CODE:
npx localtunnel --port 3000

----------------------------------------

TITLE: Enabling Dark Mode with Class or Data Attributes in Liveblocks
DESCRIPTION: Imports the CSS for enabling dark mode based on class names or data attributes. This allows manual control over when to apply dark mode styling.

LANGUAGE: typescript
CODE:
// Dark mode using `className="dark"`, `data-theme="dark"`, or `data-dark="true"`
import "@liveblocks/react-ui/styles/dark/attributes.css";

----------------------------------------

TITLE: Using useInboxNotifications before pagination implementation in React
DESCRIPTION: Previous implementation of useInboxNotifications hook that fetches all notifications without pagination support.

LANGUAGE: tsx
CODE:
import { useInboxNotifications } from "@liveblocks/react/suspense";

function Notifications() {
  const { inboxNotifications } = useInboxNotifications();

  return (
    <div>
      {inboxNotifications.map((notification) => (
        <InboxNotification key={notification.id} inboxNotification={no†ification} />
      ))}
    </div>
  );
}

----------------------------------------

TITLE: Exporting Regular Hooks from Liveblocks Config
DESCRIPTION: This snippet shows how to export the regular (non-Suspense) version of Liveblocks hooks from the liveblocks.config.ts file.

LANGUAGE: tsx
CODE:
// ...

export const {
  // Export from here to use regular hooks
  useInboxNotifications,
  useUser,
} = createLiveblocksContext(client, {});

----------------------------------------

TITLE: Implementing useOthers Hook to Track Connected Users
DESCRIPTION: Shows how to implement the useOthers hook to access information about other users currently connected to the room. The code retrieves the list of online users and counts them using the length property.

LANGUAGE: tsx
CODE:
// Add useOthers
const others = useOthers();
const userCount = others.length;

----------------------------------------

TITLE: Implementing resolveMentionSuggestions Function in Liveblocks Config
DESCRIPTION: This code snippet shows how to implement the resolveMentionSuggestions function in your Liveblocks configuration file. This function handles user mention suggestions when someone types '@' in the comment input.

LANGUAGE: typescript
CODE:
// ...

const client = createClient({
  // ...
  async resolveUsers({ userIds }) {
    // ...
  },
  async resolveMentionSuggestions({ text, roomId }) {
    // "mar"
    console.log(text);

    // Return an array of user IDs for the query "mar"
    let userIds;

    if (text) {
      // If there's a query, get user IDs from your back end that match
      userIds = await __queryUserIds__(text);
    } else {
      // If there's no query, get all of the room's user IDs
      userIds = await __getAllUserIds__();
    }

    // ["marc@example.com", "marissa@example.com"]
    console.log(userIds);
    return userIds;
  },
});

----------------------------------------

TITLE: Recommended RoomProvider-Level Storage Initialization
DESCRIPTION: The new recommended pattern for initializing storage at the RoomProvider level using explicit LiveObject structures.

LANGUAGE: tsx
CODE:
import { LiveObject } from "@liveblocks/client";

function Root() {
  // Instead, initialize it at the RoomProvider level to remove all ambiguity
  const initialStorage = {
    author: new LiveObject({
      firstName: "Ada",
      lastName: "Lovelace",
    }),
  };

  return (
    <RoomProvider id="my-room-id" initialStorage={initialStorage}>
      <ComponentA />
    </RoomProvider>
  );
}

function ComponentA() {
  const author = useObject("author");

  /* ... */
}

----------------------------------------

TITLE: Installing Node.js Polyfills for Liveblocks
DESCRIPTION: Command to install the required WebSocket and fetch polyfills for using Liveblocks client in Node.js environments.

LANGUAGE: bash
CODE:
npm install ws node-fetch

----------------------------------------

TITLE: Using Liveblocks Client with Custom Headers and Body
DESCRIPTION: Advanced configuration for the Liveblocks client that uses a callback function for the authEndpoint to pass custom headers and body data to the authentication endpoint.

LANGUAGE: typescript
CODE:
import { createClient } from "@liveblocks/client";

// Passing custom headers and body to your endpoint
const client = createClient({
  authEndpoint: async (room) => {
    const headers = {
      // Custom headers
      // ...

      "Content-Type": "application/json",
    };

    const body = JSON.stringify({
      // Custom body
      // ...

      room,
    });

    const response = await fetch("/api/liveblocks-auth", {
      method: "POST",
      headers,
      body,
    });

    return await response.json();
  },
});

----------------------------------------

TITLE: Maintaining legacy behavior of useErrorListener to only show room connection errors
DESCRIPTION: Code example showing how to filter out the new error types in useErrorListener to maintain the pre-2.16 behavior of only displaying room connection errors.

LANGUAGE: ts
CODE:
import { useErrorListener, useRoom } from "@liveblocks/react";

function App() {
  // +++
  const room = useRoom();
  // +++

  useErrorListener((error) => {
    // +++
    if (
      error.context.roomId !== room.id &&
      error.context.type !== "ROOM_CONNECTION_ERROR"
    ) {
      return;
    }
    // +++

    // Your previous logic
  });
}

----------------------------------------

TITLE: Managing User Notification Settings in Node.js with Liveblocks
DESCRIPTION: Demonstrates how to use the Liveblocks Node.js client to get, update, and delete user notification settings. The code shows initializing the client with a secret key and the three methods for notification settings management.

LANGUAGE: tsx
CODE:
import { Liveblocks } from "@liveblocks/node";
const liveblocks = new Liveblocks({ secret: "sk_xxx" });

const settings = await liveblocks.getNotificationSettings({ userId });
// { email: { thread: true, ... }, slack: { thread: false, ... }, ... }
console.log(settings);

const updatedSettings = await liveblocks.updateNotificationSettings({
  userId,
  data: {
    teams: {
      $fileUploaded: true,
    },
  },
});
await liveblocks.deleteNotificationSettings({ userId });

----------------------------------------

TITLE: Using User ID and Info in React Components
DESCRIPTION: Example showing how to access both the user ID and user information in a React component using the useSelf hook and logging the values to the console.

LANGUAGE: typescript
CODE:
const self = useSelf();
console.log(self.id);
console.log(self.info);

----------------------------------------

TITLE: Using Pagination with useThreads Hook
DESCRIPTION: Example showing how to use the pagination features introduced in Liveblocks 2.9 with the useThreads hook to incrementally load more threads with a query filter.

LANGUAGE: tsx
CODE:
const {
  threads,
  isLoading,
  error,

  // ✨ New in Liveblocks 2.9
  fetchMore,
  isFetchingMore,
  hasFetchedAll,
  fetchMoreError,
} = useThreads({ query });

----------------------------------------

TITLE: Creating SQL Schema for PlanetScale MySQL Database
DESCRIPTION: SQL command for creating a 'documents' table in PlanetScale MySQL database with roomId as the primary key and storageData field to store the JSON data from Liveblocks Storage.

LANGUAGE: sql
CODE:
CREATE TABLE documents (
   roomId VARCHAR(255) PRIMARY KEY,
   storageData TEXT NOT NULL
);

----------------------------------------

TITLE: Running Codemod for LiveList Constructor Change
DESCRIPTION: Command to automatically update LiveList constructors to include an empty array parameter.

LANGUAGE: bash
CODE:
npx @liveblocks/codemod@latest live-list-constructor

----------------------------------------

TITLE: Creating a Liveblocks Client with Public Key Authentication in TypeScript
DESCRIPTION: Example showing how to create a Liveblocks client using a public API key for authentication. This approach is recommended for prototyping and public landing pages only, not for production use.

LANGUAGE: ts
CODE:
import { createClient } from "@liveblocks/client";

const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

----------------------------------------

TITLE: Updating a Yjs Subdocument in Liveblocks
DESCRIPTION: Shows how to update a specific subdocument within a Yjs document by passing its GUID to the sendYjsBinaryUpdate method.

LANGUAGE: typescript
CODE:
await liveblocks.sendYjsBinaryUpdate("my-room-id", update, {
  // Optional, update a subdocument instead. guid is its unique identifier
  guid: "c4a755...",
});

----------------------------------------

TITLE: Creating a Basic Mutation with useMutation Hook
DESCRIPTION: Shows how to create a mutation function using the useMutation hook to modify storage without parameters.

LANGUAGE: typescript
CODE:
const updateName = useMutation(({ storage }) => {
  const person = storage.get("person");
  person.set("name", "Albert");
}, []);

----------------------------------------

TITLE: Getting User Notification Settings with @liveblocks/client
DESCRIPTION: Example of using the client to retrieve and update user notification settings. This shows how to get current settings and modify them.

LANGUAGE: tsx
CODE:
import { createClient } from '@liveblocks/client'
const client = createClient({ ... })

const settings = await client.getNotificationSettings();
// { email: { thread: true, ... }, slack: { thread: false, ... }, ... }
console.log(settings);

const updatedSettings = await client.updateNotificationSettings({
  email: {
    thread: false,
  }
});

----------------------------------------

TITLE: Initializing Liveblocks Configuration File
DESCRIPTION: Command to create a liveblocks.config.ts file that can be used to define types for the application.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --init --framework javascript

----------------------------------------

TITLE: Using useStorageStatus Hook to Track Storage Synchronization
DESCRIPTION: Shows how to use the deprecated useStorageStatus hook to track the storage synchronization status of a room. This hook re-renders the component whenever the storage status changes.

LANGUAGE: ts
CODE:
import { useStorageStatus } from "@liveblocks/react";

const storageStatus = useStorageStatus();

// "not-loaded" | "loading" | "synchronizing" | "synchronized"
console.log(storageStatus);

----------------------------------------

TITLE: Deprecated Component-Level Storage Initialization
DESCRIPTION: Example of the deprecated pattern where storage is initialized at the component level using useObject hooks.

LANGUAGE: tsx
CODE:
function ComponentA() {
  const author = useObject(
    "author",

    // ⚠️ Don't initialize your data here anymore!
    { firstName: "Ada", lastName: "Lovelace" }
  );

  /* ... */
}

----------------------------------------

TITLE: Debugging ActivitiesData Type Issues in TypeScript
DESCRIPTION: A debugging approach to identify type errors in complex ActivitiesData definitions by explicitly trying to assign your custom type to the BaseActivitiesData type, which reveals detailed type errors.

LANGUAGE: typescript
CODE:
import type { BaseActivitiesData } from "@liveblocks/client";

declare global {
  interface Liveblocks {
    ActivitiesData: MyActivitiesData;
  }
}

// Quick debugging snippet to find root cause
const xxx: BaseActivitiesData = {} as MyActivitiesData;
//    ^?
//    The error will appear here

----------------------------------------

TITLE: Updating Cursor Coordinates on Pointer Move in React with Liveblocks
DESCRIPTION: This function handles pointer movement events by extracting the cursor's x and y coordinates from the event and updating the user's presence with these values using updateMyPresence.

LANGUAGE: tsx
CODE:
// Update cursor coordinates on pointer move
function handlePointerMove(e) {
  const cursor = { x: Math.floor(e.clientX), y: Math.floor(e.clientY) };
  updateMyPresence({ cursor });
}

----------------------------------------

TITLE: Using LiveblocksProvider Instead of createClient in Liveblocks 2.0
DESCRIPTION: Demonstrates the transition from using createClient to the new component-based approach with LiveblocksProvider in Liveblocks 2.0, which simplifies configuration.

LANGUAGE: typescript
CODE:
// ❌ Before
const client = createClient(/* options */);

// ✅ After
<LiveblocksProvider /* options */>
  <App />
</LiveblocksProvider>

----------------------------------------

TITLE: Getting Other Connected Users in Liveblocks Room
DESCRIPTION: Retrieves an array of currently connected users in the room, each represented as a User object containing connection details, user information, and presence data.

LANGUAGE: typescript
CODE:
const others = room.getOthers();

for (const other of others) {
  const { connectionId, id, info, presence, canWrite, canComment } = other;
  // Do things
}

----------------------------------------

TITLE: Updating Node Client Methods to Remove Type Parameters
DESCRIPTION: Shows how to update @liveblocks/node client methods that no longer accept type parameters, using global type augmentation instead.

LANGUAGE: tsx
CODE:
// ❌ Before
await liveblocks.createThread<MyThreadMetadata>();
await liveblocks.editThreadMetadata<MyThreadMetadata>();
await liveblocks.getThreads<MyThreadMetadata>();
await liveblocks.getThread<MyThreadMetadata>();
//                         ^^^^^^^^^^^^^^^^ No longer possible

// ✅ After
await liveblocks.createThread();
await liveblocks.editThreadMetadata();
await liveblocks.getThreads();
await liveblocks.getThread();

// In liveblocks.config.ts
declare global {
  interface Liveblocks {
    ThreadMetadata: MyThreadMetadata;
  }
}

----------------------------------------

TITLE: Comments Overrides Configuration - Before
DESCRIPTION: Previous implementation of Comments overrides in Liveblocks 1.9, using constants that have been renamed or modified in version 1.10.

LANGUAGE: tsx
CODE:
// ❌ Before - Liveblocks 1.9
<CommentsConfig
  overrides={{
    SELF: "you",
    UNKNOWN_USER: "Anon",
    COMMENT_REACTION_REMAINING: (others) => `${others} people`,
    COMMENT_REACTION_TOOLTIP: (emoji, list) => (
      <>
        {list} reacted with {emoji}
      </>
    ),
  }}
/>

----------------------------------------

TITLE: Using getYjsProviderForRoom with Options
DESCRIPTION: Demonstrates how to get or create a LiveblocksYjsProvider for a room using the recommended getYjsProviderForRoom function with configuration options. This is the preferred way to use Yjs with Liveblocks.

LANGUAGE: typescript
CODE:
import { getYjsProviderForRoom } from "@liveblocks/yjs";

const yProvider = getYjsProviderForRoom(room, {
  // Options
  // ...
});

const yDoc = yProvider.getYDoc();

----------------------------------------

TITLE: Accessing Other User's Cursor Position
DESCRIPTION: Example showing how to access the cursor position from the first other user's presence data. The cursor position will be null if the user's cursor is off-screen.

LANGUAGE: tsx
CODE:
// { cursor: null }
others[0].presence;

----------------------------------------

TITLE: Installing Liveblocks, Yjs, and Slate Packages
DESCRIPTION: Command to install all necessary dependencies for creating a collaborative text editor with Liveblocks, Yjs, and Slate in a React application.

LANGUAGE: bash
CODE:
npm install @liveblocks/client @liveblocks/react @liveblocks/yjs yjs slate slate-react @slate-yjs/core

----------------------------------------

TITLE: Configuring RoomProvider with unstable_batchedUpdates for React 17 compatibility
DESCRIPTION: Implementation example showing how to pass the unstable_batchedUpdates function to RoomProvider to avoid the 'stale-props/zombie-child' problem in React 17 or lower. This ensures that state updates are properly batched together.

LANGUAGE: tsx
CODE:
import { unstable_batchedUpdates } from "react-dom";
//                                      ^^^^^^^^^^^ ...or "react-native"!
<RoomProvider
  id="my-room"
  initialPresence={/* ... */}
  initialStorage={/* ... */}
  unstable_batchedUpdates={unstable_batchedUpdates}
>
  <App />
</RoomProvider>;

----------------------------------------

TITLE: Accessing User Information in Vue.js Component
DESCRIPTION: Demonstrates how to access the user ID and user information in a Vue.js component after authentication has been set up.

LANGUAGE: typescript
CODE:
const self = ref(room.getSelf());
console.log(self.id);
console.log(self.info);

----------------------------------------

TITLE: Using useNotificationSettings Hook for Managing Notification Settings in React
DESCRIPTION: Example demonstrating how to use the useNotificationSettings hook to get the current user notification settings and update them. This hook provides loading and error states along with the settings data.

LANGUAGE: tsx
CODE:
// A suspense version of this hook is available
import { useNotificationSettings } from "@liveblocks/react";

const [{ isLoading, error, settings }, updateSettings] =
  useNotificationSettings();
// { email: { thread: true, ... }, slack: { thread: false, ... }, ... }
console.log(settings);

const onSave = () => {
  updateSettings({
    slack: {
      textMention: true,
    },
  });
};

----------------------------------------

TITLE: Running simplify-client-side-suspense-children Codemod in Shell
DESCRIPTION: Executes the codemod that removes any function-style body from <ClientSideSuspense>'s children prop.

LANGUAGE: shell
CODE:
npx @liveblocks/codemod@latest simplify-client-side-suspense-children

----------------------------------------

TITLE: Update Room ID with Liveblocks in TypeScript
DESCRIPTION: Permanently updates a room's ID, replacing the old ID with a new one. This disconnects connected users from the room. Throws an error if the room isn't found.

LANGUAGE: typescript
CODE:
const room = await liveblocks.updateRoomId({
  roomId: "my-room-id",
  newRoomId: "new-room-id",
});

// { type: "room", id: "my-room-id", metadata: {...}, ... }
console.log(room);

----------------------------------------

TITLE: Defining User Metadata Types in Liveblocks Config
DESCRIPTION: TypeScript configuration to define the structure of user metadata in the Liveblocks global interface. This enables type safety when working with user information in the application.

LANGUAGE: typescript
CODE:
declare global
  interface Liveblocks {
    UserMeta: {
      id: string;

      // Example, use any JSON-compatible data in your metadata
      info: {
        name: string;
        avatar: string;
        colors: string[];
      }
    }

    // Other type definitions
    // ...
  }
}

----------------------------------------

TITLE: Using LiveList.set Method in TypeScript
DESCRIPTION: Example of using the LiveList.set method introduced in v0.16.0 to update a specific index in a LiveList. This method lets you replace a single element without modifying the entire list.

LANGUAGE: typescript
CODE:
const list = new LiveList(["🦁", "🦊", "🐵"]);
list.set(0, "🐺");
list.toArray(); // equals ["🐺", "🦊", "🐵"]

----------------------------------------

TITLE: Converting LocalTunnel URL for Webhook Configuration
DESCRIPTION: Example of how to convert a local webhook endpoint URL to use the LocalTunnel domain for testing. This allows the Liveblocks webhook system to reach your local development environment.

LANGUAGE: shell
CODE:
# Take your local URL
http://localhost:3000/api/liveblocks-notifications

# Replace localhost with the generated domain, then copy it
https://my-localtunnel-url.loca.lt/api/liveblocks-notifications

----------------------------------------

TITLE: Deploying the Collaborative To-do List Example on Vercel
DESCRIPTION: Command to download the React Native to-do list example and set it up with Vercel deployment. This will open a browser to complete the Vercel setup process.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example react-native-todo-list --vercel

----------------------------------------

TITLE: Importing Hooks Directly in Liveblocks 2.0
DESCRIPTION: Comparison of how hooks were imported before and after Liveblocks 2.0, showing the simplified direct import approach that replaces importing from a config file.

LANGUAGE: typescript
CODE:
// ❌ Before: get hooks exported from your Liveblocks config
import { RoomProvider, useRoom, ... } from "./liveblocks.config";

// ✅ After: import hooks directly
import { RoomProvider, useRoom, ... } from "@liveblocks/react";
import { RoomProvider, useRoom, ... } from "@liveblocks/react/suspense";

----------------------------------------

TITLE: Setting Initial Storage Value in RoomProvider
DESCRIPTION: Demonstrates how to initialize the Storage with a LiveList in the RoomProvider component to set default values for collaborative data structures.

LANGUAGE: tsx
CODE:
import { LiveList } from "@liveblocks/client";
import { RoomProvider } from "@liveblocks/react/suspense";

function App() {
  return (
    <RoomProvider
      id="my-room-name"
      // +++
      initialStorage={{ animals: new LiveList(["Fido"]) }}
      // +++
    >
      {/* children */}
    </RoomProvider>
  );
}

----------------------------------------

TITLE: Invalid vs Valid Wildcard Usage in Liveblocks
DESCRIPTION: This snippet demonstrates the correct way to use wildcards in room IDs for access permissions. Wildcards can only be used at the end of a room ID, not in the middle, as shown in the example.

LANGUAGE: jsx
CODE:
// ❌ Wildcard must be at the end of the room ID
session.allow("Vu78Rt:*:product", session.FULL_ACCESS);

// ✅ Valid wildcard
session.allow("Vu78Rt:product:*", session.FULL_ACCESS);

----------------------------------------

TITLE: Implementing Room Component with useStorage
DESCRIPTION: Complete implementation of the Room component that imports useStorage from Liveblocks, selects the person object from storage, and renders it as a JSON string.

LANGUAGE: tsx
CODE:
import { useStorage } from "@liveblocks/react/suspense";

export function Room() {
  const person = useStorage((root) => root.person);

  return <div>Person: {JSON.stringify(person)}</div>;
}

----------------------------------------

TITLE: Subscribing to Storage Status Changes in TypeScript
DESCRIPTION: Example of how to subscribe to storage status changes using the room.subscribe method. The code demonstrates handling different storage states including not-loaded, loading, synchronizing, and synchronized.

LANGUAGE: typescript
CODE:
room.subscribe("storage-status", (status) => {
  switch (status) {
    case "not-loaded":
      break;
    case "loading":
      break;
    case "synchronizing":
      break;
    case "synchronized":
      break;
    default:
      break;
  }
});

----------------------------------------

TITLE: Defining Custom ActivitiesData Type for Custom Notifications
DESCRIPTION: Example showing how to define a custom ActivitiesData type to improve typing for custom notification activities.

LANGUAGE: tsx
CODE:
declare global {
  interface Liveblocks {
    // Custom activities data for custom notification kinds
    ActivitiesData: {
      // Example, a custom $alert kind
      $alert: {
        title: string;
        message: string;
      };
    };

    // Other kinds
    // ...
  }
}

----------------------------------------

TITLE: Setting up RoomProvider for Liveblocks Connection in React
DESCRIPTION: Implementation of the RoomProvider component to connect to a Liveblocks room. The code establishes a connection to a specific room using a unique roomId and renders a Room component within it.

LANGUAGE: tsx
CODE:
return (
  <LiveblocksProvider publicApiKey={publicApiKey}>
    <RoomProvider id={roomId}>
      <Room />
    </RoomProvider>
  </LiveblocksProvider>
);

----------------------------------------

TITLE: Complete Next.js Authentication Endpoint Implementation
DESCRIPTION: A full working example of an authentication endpoint in a Next.js application using ID tokens with Liveblocks.

LANGUAGE: ts
CODE:
import { Liveblocks } from "@liveblocks/node";

// Create a client
const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export async function POST(request: Request) {
  const user = __getUserFromDB__(request);

  // Identify the user and return the result
  const { status, body } = await liveblocks.identifyUser({
    userId: user.id,
    groupIds, // Optional
  });

  return new Response(body, { status });
}

----------------------------------------

TITLE: Implementing Threads with useThreads Hook and Thread Component
DESCRIPTION: React component implementing the useThreads hook to fetch threads and rendering them using the Thread component. Also includes a Composer component for creating new threads.

LANGUAGE: tsx
CODE:
"use client";

import { useThreads } from "@liveblocks/react/suspense";
import { Composer, Thread } from "@liveblocks/react-ui";

export function Room() {
  const { threads } = useThreads();

  return (
    <div>
      {threads.map((thread) => (
        <Thread key={thread.id} thread={thread} />
      ))}
      <Composer />
    </div>
  );
}

----------------------------------------

TITLE: Implementing Threads with useThreads Hook and Thread Component
DESCRIPTION: React component implementing the useThreads hook to fetch threads and rendering them using the Thread component. Also includes a Composer component for creating new threads.

LANGUAGE: tsx
CODE:
"use client";

import { useThreads } from "@liveblocks/react/suspense";
import { Composer, Thread } from "@liveblocks/react-ui";

export function Room() {
  const { threads } = useThreads();

  return (
    <div>
      {threads.map((thread) => (
        <Thread key={thread.id} thread={thread} />
      ))}
      <Composer />
    </div>
  );
}

----------------------------------------

TITLE: Initializing Liveblocks Configuration File
DESCRIPTION: Command to initialize the liveblocks.config.ts file using the Liveblocks CLI. This file can later be used to define types for the application.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --init --framework react

----------------------------------------

TITLE: Basic Zustand Store Configuration Without Liveblocks Middleware
DESCRIPTION: Demonstrates a basic zustand store implementation for a to-do list without liveblocks integration. This shows the baseline store structure before adding real-time collaboration features.

LANGUAGE: typescript
CODE:
import create from "zustand";

type State = {
  draft: string;
  isTyping: boolean;
  todos: Todo[];
  setDraft: (draft: string) => void;
  addTodo: () => void;
  deleteTodo: (index: number) => void;
};

create<State>(/* ... */);

----------------------------------------

TITLE: Creating a Room and Initializing Yjs Document in Liveblocks
DESCRIPTION: Demonstrates how to create a new room and initialize its Yjs document in sequence, useful for setting up new collaborative spaces with initial data.

LANGUAGE: typescript
CODE:
// Create new room
const room = await liveblocks.createRoom("my-room-id");

// Set initial Yjs document value
await liveblocks.sendYjsBinaryUpdate("my-room-id", state);

----------------------------------------

TITLE: Using useClient Hook Instead of Importing Client
DESCRIPTION: Example showing how to access the Liveblocks client instance using the useClient hook instead of importing it directly.

LANGUAGE: tsx
CODE:
// ❌ Before
import { client } from "./liveblocks.config";

function MyComponent() {
  doSomethingWith(client);
}

LANGUAGE: tsx
CODE:
// ✅ After
import { useClient } from "@liveblocks/react"; // or
import { useClient } from "@liveblocks/react/suspense";

function MyComponent() {
  const client = useClient();
  doSomethingWith(client);
}

----------------------------------------

TITLE: Defining Alternative Tutorial Folder Structure in Markdown
DESCRIPTION: Shows an alternative folder structure for tutorials where only the differences between initial and solved states are stored instead of the complete solution.

LANGUAGE: markdown
CODE:
intial - The project shown when the page loads
solved-diff - The project files that differ to initial when you press "Show solution" button 
guide.mdx - The markdown guide

----------------------------------------

TITLE: Installing Liveblocks Node Package
DESCRIPTION: Command to install the @liveblocks/node package, which is required for setting up authentication endpoints in Next.js.

LANGUAGE: bash
CODE:
npm install @liveblocks/node

----------------------------------------

TITLE: Using upsertRoom Method in Liveblocks Node Package
DESCRIPTION: Example of the upsertRoom method that combines updateRoom and createRoom functionality, optimized to make a single round-trip to the server, introduced in v2.22.2.

LANGUAGE: javascript
CODE:
.upsertRoom()

----------------------------------------

TITLE: Configuring Liveblocks Client with Auth Endpoint
DESCRIPTION: Client-side configuration that uses the authentication endpoint instead of a public API key. This connects the frontend to the secure authentication backend.

LANGUAGE: typescript
CODE:
import { createClient } from "@liveblocks/client";

const client = createClient({
  authEndpoint: "/api/liveblocks-auth",
});

----------------------------------------

TITLE: Running live-list-constructor Codemod in Shell
DESCRIPTION: Executes the codemod that adds an array to empty LiveList constructors.

LANGUAGE: shell
CODE:
npx @liveblocks/codemod@latest live-list-constructor

----------------------------------------

TITLE: Installing Liveblocks Comments Primitives Example
DESCRIPTION: Command to set up the Liveblocks Comments Primitives example project with Next.js, which automatically downloads the example and helps obtain an API key from a Liveblocks account.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-comments-primitives --api-key

----------------------------------------

TITLE: Integrating Zustand with Liveblocks Middleware
DESCRIPTION: Example demonstrating how to integrate Liveblocks middleware with a Zustand store, including presence and storage mapping configuration.

LANGUAGE: typescript
CODE:
import create from "zustand";
import { createClient } from "@liveblocks/client";
import { middleware } from "@liveblocks/zustand";

const client = createClient({ /*...*/ });

type State = {
  draft: string;
  isTyping: boolean;
  todos: Todo[];
  setDraft: (draft: string) => void;
  addTodo: () => void;
  deleteTodo: (index: number) => void;
};

create(
  middleware<State>(/* ... */, {
    client,
    presenceMapping: { isTyping: true },
    storageMapping: { todos: true }
  })
);

----------------------------------------

TITLE: Granting Access to Multiple Rooms Using Wildcard Pattern in TypeScript
DESCRIPTION: A TypeScript example showing how to grant full access to all rooms in an organization using a naming pattern with wildcard. This is the recommended approach when users need access to multiple rooms.

LANGUAGE: typescript
CODE:
// ✅ Grants access to every `acme` organization room
session.allow(`acme:*`, session.FULL_ACCESS);

----------------------------------------

TITLE: Updating useOther hook implementation in React
DESCRIPTION: Code demonstrating the old approach of using useOther without a selector (which is now invalid) and the new required implementation with a selector function.

LANGUAGE: tsx
CODE:
const other = useOther(id); // 👈 does not include a selector

LANGUAGE: tsx
CODE:
const other = useOther(id, (other) => other); // 👈 requires a selector

----------------------------------------

TITLE: Deploying the Collaborative Text Editor to Vercel
DESCRIPTION: Command to both download the example and deploy it to Vercel using the Liveblocks CLI tool.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-yjs-blocknote --vercel

----------------------------------------

TITLE: Filtering Threads by Absence of Metadata in useThreads
DESCRIPTION: Example showing how to filter threads by the absence of metadata in the useThreads hook. This snippet demonstrates filtering pinned threads that don't have a color attribute set in their metadata.

LANGUAGE: ts
CODE:
useThreads({
  query: {
    // Filter any "pinned" threads that don't have a color set
    metadata: {
      pinned: true,
      color: null, // ✨
    },
  },
});

----------------------------------------

TITLE: Subscribing to Storage Status in Liveblocks
DESCRIPTION: Code example showing how to subscribe to storage status changes in a Liveblocks room. The status can be 'not-loaded', 'loading', 'synchronizing', or 'synchronized', which helps track the synchronization state with Liveblocks servers.

LANGUAGE: typescript
CODE:
room.subscribe("storage-status", (status) => {
  switch (status) {
    case "not-loaded":
      break;
    case "loading":
      break;
    case "synchronizing":
      break;
    case "synchronized":
      break;
    default:
      break;
  }
});

----------------------------------------

TITLE: Implementing Threads Component for Comments in BlockNote
DESCRIPTION: Component for rendering comment threads in the collaborative editor. Uses AnchoredThreads for desktop, FloatingThreads for mobile, and FloatingComposer for creating new threads.

LANGUAGE: tsx
CODE:
import { useThreads } from "@liveblocks/react/suspense";
import {
  AnchoredThreads,
  FloatingComposer,
  FloatingThreads,
} from "@liveblocks/react-blocknote";
import { BlockNoteEditor } from "@blocknote/core";

export function Threads({ editor }: { editor: BlockNoteEditor | null }) {
  const { threads } = useThreads({ query: { resolved: false } });

  if (!editor) {
    return null;
  }

  return (
    <>
      <div className="anchored-threads">
        <AnchoredThreads editor={editor} threads={threads} />
      </div>
      <FloatingThreads
        editor={editor}
        threads={threads}
        className="floating-threads"
      />
      <FloatingComposer editor={editor} className="floating-composer" />
    </>
  );
}

----------------------------------------

TITLE: Media Query Hook Implementation for Responsive Threads
DESCRIPTION: Alternative approach to responsive thread display using a custom media query hook to conditionally render either AnchoredThreads or FloatingThreads based on screen size.

LANGUAGE: tsx
CODE:
import { useSyncExternalStore } from "react";
import { useThreads } from "@liveblocks/react/suspense";
import { AnchoredThreads, FloatingThreads } from "@liveblocks/react-blocknote";
import { BlockNoteEditor } from "@blocknote/core";

function ThreadOverlay({ editor }: { editor: BlockNoteEditor | null }) {
  const { threads } = useThreads({ query: { resolved: false } });
  // +++
  const isMobile = useIsMobile();
  // +++

  // +++
  if (isMobile) {
    return (
      <FloatingThreads
        editor={editor}
        threads={threads}
        style={{ width: "350px" }}
      />
    );
  }
  // +++

  // +++
  return (
    <AnchoredThreads
      editor={editor}
      threads={threads}
      style={{ width: "350px" }}
    />
  );
  //+++
}

export function useIsMobile() {
  return useSyncExternalStore(subscribe, getSnapshot, getSnapshot);
}

function subscribe(callback: () => void) {
  const query = window.matchMedia("(max-width: 1024px)");

  query.addEventListener("change", callback);
  return () => query.removeEventListener("change", callback);
}

function getSnapshot() {
  const query = window.matchMedia("(max-width: 1024px)");
  return query.matches;
}

----------------------------------------

TITLE: Integrating Zustand Store with Liveblocks Middleware
DESCRIPTION: Example showing how to integrate Liveblocks middleware with a Zustand store. It demonstrates moving the State type parameter to the middleware level and configuring presence and storage mappings.

LANGUAGE: typescript
CODE:
import create from "zustand";
import { createClient } from "@liveblocks/client";
import { middleware } from "@liveblocks/zustand";

const client = createClient({ /*...*/ });

type State = {
  draft: string;
  isTyping: boolean;
  todos: Todo[];
  setDraft: (draft: string) => void;
  addTodo: () => void;
  deleteTodo: (index: number) => void;
};

create(
  middleware<State>(/* ... */, {
    client,
    presenceMapping: { isTyping: true },
    storageMapping: { todos: true }
  })
);

----------------------------------------

TITLE: Configuring Liveblocks Client with Auth Endpoint
DESCRIPTION: Client-side configuration that uses the authentication endpoint instead of a public API key. This connects the frontend to the secure authentication backend.

LANGUAGE: typescript
CODE:
import { createClient } from "@liveblocks/client";

const client = createClient({
  authEndpoint: "/api/liveblocks-auth",
});

----------------------------------------

TITLE: Defining Storage Types in Liveblocks Configuration
DESCRIPTION: Defines the storage type structure using a LiveObject generic in the liveblocks.config.ts file. This establishes the schema for the person object with name and age properties.

LANGUAGE: typescript
CODE:
// Storage type
Storage: {
  person: LiveObject<{
    name: string;
    age: number;
  }>;
}

----------------------------------------

TITLE: Filtering Threads by Absence of Metadata in React
DESCRIPTION: Shows how to use the useThreads hook to filter threads that don't have specific metadata attributes set, using the new null value to indicate absence of a property.

LANGUAGE: ts
CODE:
useThreads({
  query: {
    // Filter any "pinned" threads that don't have a color set
    metadata: {
      pinned: true,
      color: null, // ✨
    },
  },
});

----------------------------------------

TITLE: Using a custom Markdown serializer with ProseMirror
DESCRIPTION: Create and use a custom Markdown serializer with the toMarkdown method to control how specific ProseMirror marks are converted to Markdown syntax.

LANGUAGE: typescript
CODE:
import { defaultMarkdownSerializer } from "prosemirror-markdown";

const mySerializer = new MarkdownSerializer({
  marks: {
    ...defaultMarkdownSerializer.marks,
    em: {
      open: "*",
      close: "*",
      mixable: true,
      expelEnclosingWhitespace: true,
    },
  },
});

const markdown = await withProsemirrorDocument(
  { roomId: "my-room-id", client: liveblocks },
  async (api) => {
    // +++
    return api.toMarkdown(mySerializer);
    // +++
  }
);

----------------------------------------

TITLE: Updating Liveblocks Import Statements
DESCRIPTION: Example of how import statements change when migrating from custom context to direct imports from the Liveblocks packages.

LANGUAGE: tsx
CODE:
// ❌ Before
import { RoomProvider, useRoom, ... } from "./liveblocks.config.ts";

LANGUAGE: tsx
CODE:
// ✅ After
import { RoomProvider, useRoom, ... } from "@liveblocks/react/suspense";  // Option 1
import { RoomProvider, useRoom, ... } from "@liveblocks/react";           // Option 2

----------------------------------------

TITLE: Configuring Custom File Location for Pages in JSON
DESCRIPTION: Shows how to specify a different file location from the URL path for a documentation page, using the 'file' property to explicitly set the MDX file location.

LANGUAGE: json
CODE:
{
  "title": "Overview",
  "path": "/",
  "file": "/index.mdx"
}

----------------------------------------

TITLE: Project Structure Overview in Liveblocks Next.js Starter Kit
DESCRIPTION: A directory structure overview of the Liveblocks Next.js starter kit, showing the organization of components, app folders, and library functions.

LANGUAGE: text
CODE:
app
components
data
icons
layouts
lib
 └─ actions
 └─ database
 └─ hooks
 └─ utils
primitives
styles
types
auth.ts
auth.config.ts
liveblocks.config.ts
liveblocks.server.config.ts
package.json

----------------------------------------

TITLE: Setting Up Liveblocks Client and Room Provider in React
DESCRIPTION: Configures the Liveblocks client with LiveblocksProvider and sets up a room for collaboration using RoomProvider. This is the foundation for creating a collaborative environment.

LANGUAGE: tsx
CODE:
"use client";

import {
  LiveblocksProvider,
  RoomProvider,
} from "@liveblocks/react/suspense";
import { Editor } from "./Editor";

export default function App() {
  return (
    <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>      <RoomProvider id="my-room">
        {/* ... */}
      </RoomProvider>
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Setting Up Liveblocks Client and Room Provider in React
DESCRIPTION: Configures the Liveblocks client with LiveblocksProvider and sets up a room for collaboration using RoomProvider. This is the foundation for creating a collaborative environment.

LANGUAGE: tsx
CODE:
"use client";

import {
  LiveblocksProvider,
  RoomProvider,
} from "@liveblocks/react/suspense";
import { Editor } from "./Editor";

export default function App() {
  return (
    <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>      <RoomProvider id="my-room">
        {/* ... */}
      </RoomProvider>
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Accessing User Information in Svelte Application
DESCRIPTION: Example of how to access the authenticated user's ID and custom information in a Svelte component using the Liveblocks room API.

LANGUAGE: typescript
CODE:
const self = room.getSelf();
console.log(self.id);
console.log(self.info.color);

----------------------------------------

TITLE: Importing Liveblocks React Hooks Directly
DESCRIPTION: Demonstrates the improved way to import Liveblocks React hooks directly from the package rather than from a configuration file, which is a DX improvement in Liveblocks 2.0.

LANGUAGE: typescript
CODE:
// ❌ Before: get hooks exported from your Liveblocks config
import { RoomProvider, useRoom, ... } from "./liveblocks.config";

// ✅ After: import hooks directly
import { RoomProvider, useRoom, ... } from "@liveblocks/react";
import { RoomProvider, useRoom, ... } from "@liveblocks/react/suspense";

----------------------------------------

TITLE: Multiple editors component implementation
DESCRIPTION: Full example of implementing multiple BlockNote editors on the same page, using a TextEditor component that accepts a field prop to differentiate between editor instances.

LANGUAGE: tsx
CODE:
import { useCreateBlockNoteWithLiveblocks } from "@liveblocks/react-blocknote";
import { BlockNoteView } from "@blocknote/mantine";

function TextEditors() {
  return (
    <div>
      // +++
      <TextEditor field="one" />
      <TextEditor field="two" />
      // +++
    </div>
  );
}

function TextEditor({ field }: { field: string }) {
  const editor = useCreateBlockNoteWithLiveblocks(
    {},
    {
      // +++
      field,
      // +++
    }
  );

  return (
    <div>
      <BlockNoteView editor={editor} />
    </div>
  );
}

----------------------------------------

TITLE: Real-world Example of resolveMentionSuggestions with Filtering
DESCRIPTION: Demonstrates a practical implementation of resolveMentionSuggestions that fetches all users and filters them based on the search text. This approach handles both empty searches and specific user filtering.

LANGUAGE: tsx
CODE:
<LiveblocksProvider
  resolveUsers={async ({ userIds }) => {
    // ...
  }}
  resolveMentionSuggestions={async ({ text, roomId }) => {
    // Fetch all users from your back end
    let users = await __fetchAllUsers__();

    // If there's a query, filter for the relevant users
    if (text) {
      // Filter any way you'd like, e.g. checking if the name matches
      users = users.filter((user) => user.name.includes(text));
    }

    // Return the filtered `userIds`
    return users.map((user) => user.id);
  }}

  // ...
/>;

----------------------------------------

TITLE: Updated CommentBodyResolveUsersArgs Import
DESCRIPTION: Change in the import for CommentBodyResolveUsersArgs, which has been replaced with ResolveUsersArgs in Liveblocks 1.10.

LANGUAGE: tsx
CODE:
// ❌ Before - Liveblocks 1.9
import { CommentBodyResolveUsersArgs } from "@liveblocks/node";

// ✅ After - Liveblocks 1.10
import { ResolveUsersArgs } from "@liveblocks/node";

----------------------------------------

TITLE: Getting User Notification Settings with @liveblocks/client
DESCRIPTION: Code snippet demonstrating how to create a Liveblocks client and retrieve a user's notification settings. The settings show notification preferences for different channels like email and Slack.

LANGUAGE: typescript
CODE:
import { createClient } from '@liveblocks/client'
const client = createClient({ ... })

const settings = await client.getNotificationSettings();
// { email: { thread: true, ... }, slack: { thread: false, ... }, ... }
console.log(settings);

const updatedSettings = await client.updateNotificationSettings({
  email: {
    thread: false,
  }
});

----------------------------------------

TITLE: Creating a Yjs Provider with getYjsProviderForRoom Factory
DESCRIPTION: Example of using the getYjsProviderForRoom factory function to create a Yjs provider instance that is automatically cleaned up when the room is disconnected or changed.

LANGUAGE: javascript
CODE:
getYjsProviderForRoom

----------------------------------------

TITLE: Deploying Liveblocks Comments Notifications to Vercel
DESCRIPTION: Command to download the example and initiate the Vercel deployment process for the comments notifications system.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-comments-notifications --vercel

----------------------------------------

TITLE: Using useInboxNotifications Hook with Pagination
DESCRIPTION: Example of using the useInboxNotifications hook with pagination support added in Liveblocks 2.9, showing how to access pagination-related properties and methods.

LANGUAGE: tsx
CODE:
const {
  inboxNotifications,
  isLoading,
  error,

  // ✨ New in Liveblocks 2.9
  fetchMore,
  isFetchingMore,
  hasFetchedAll,
  fetchMoreError,
} = useInboxNotifications();

----------------------------------------

TITLE: Implementing a Notification Toggle Checkbox with useNotificationSettings in React
DESCRIPTION: This code demonstrates how to create a checkbox that toggles the current user's email/thread notification setting. When toggled off, corresponding webhook events for the current user are disabled, preventing them from receiving notifications of that type on that channel.

LANGUAGE: tsx
CODE:
import { useNotificationSettings } from "@liveblocks/react";

function NotificationSettings() {
  const [{ isLoading, error, settings }, updateSettings] =
    useNotificationSettings();

  if (isLoading || error) {
    return null;
  }

  return (
    <>
      {settings.email ? (
        <>
          // +++
          <label>
            Receive thread notifications by email
            <input
              type="checkbox"
              checked={settings.email.thread}
              onChange={(e) =>
                updateSettings({ email: { thread: e.target.checked } })
              }
            />
          </label>
          // +++
        </>
      ) : null}
    </>
  );
}

----------------------------------------

TITLE: Deploying the Connection Status Example to Vercel
DESCRIPTION: Command to download the connection status example and deploy it to Vercel. This will open your browser to complete the Vercel deployment process.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-connection-status --vercel

----------------------------------------

TITLE: Integrating Zustand with Liveblocks Middleware in TypeScript
DESCRIPTION: Implementation of a Zustand store using the Liveblocks middleware. This demonstrates how to move the State type to the middleware level and configure presence and storage mappings.

LANGUAGE: typescript
CODE:
import create from "zustand";
import { createClient } from "@liveblocks/client";
import { middleware } from "@liveblocks/zustand";

const client = createClient({ /*...*/ });

type State = {
  draft: string;
  isTyping: boolean;
  todos: Todo[];
  setDraft: (draft: string) => void;
  addTodo: () => void;
  deleteTodo: (index: number) => void;
};

create(
  middleware<State>(/* ... */, {
    client,
    presenceMapping: { isTyping: true },
    storageMapping: { todos: true }
  })
);

----------------------------------------

TITLE: Managing User Notification Settings with @liveblocks/node
DESCRIPTION: This example demonstrates how to use the Liveblocks Node.js client to manage user notification settings. It shows methods for retrieving, updating, and deleting notification settings for a specific user.

LANGUAGE: tsx
CODE:
import { Liveblocks } from "@liveblocks/node";
const liveblocks = new Liveblocks({ secret: "sk_xxx" });

const settings = await liveblocks.getNotificationSettings({ userId });
// { email: { thread: true, ... }, slack: { thread: false, ... }, ... }
console.log(settings);

const updatedSettings = await liveblocks.updateNotificationSettings({
  userId,
  data: {
    teams: {
      $fileUploaded: true,
    },
  },
});
await liveblocks.deleteNotificationSettings({ userId });

----------------------------------------

TITLE: Setting up Authentication Endpoint in Next.js App Directory
DESCRIPTION: Creates an authentication endpoint in Next.js app directory that identifies users and determines their access to specific rooms. This endpoint is crucial for implementing security logic.

LANGUAGE: typescript
CODE:
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export async function POST(request: Request) {
  // Get the current user from your database
  const user = __getUserFromDB__(request);

  // Identify the user and return the result
  const { status, body } = await liveblocks.identifyUser(
    {
      userId: user.id,
      groupIds, // Optional
    },
    { userInfo: user.metadata },
  );

  return new Response(body, { status });
}

----------------------------------------

TITLE: Installing Liveblocks Packages for React
DESCRIPTION: Command to install the required Liveblocks packages for a React project. This installs both the client library and the React-specific integration.

LANGUAGE: bash
CODE:
npm install @liveblocks/client @liveblocks/react

----------------------------------------

TITLE: Enabling Synchronization Status Protection in React
DESCRIPTION: Code snippet showing how to enable the preventUnsavedChanges option with LiveblocksProvider in React to prevent browser tabs from being closed while local changes are not yet synchronized.

LANGUAGE: tsx
CODE:
<LiveblocksProvider preventUnsavedChanges />

----------------------------------------

TITLE: Using useEditorStatus Hook in React with Liveblocks Lexical
DESCRIPTION: This snippet demonstrates how to use the deprecated useEditorStatus hook to track the editor's synchronization status with Liveblocks servers. The hook returns one of three possible states: not-loaded, loading, or synchronized.

LANGUAGE: typescript
CODE:
import { useEditorStatus } from "@liveblocks/react-lexical";

const status = useEditorStatus();

----------------------------------------

TITLE: Configuring Auth0 Authentication Environment Variables
DESCRIPTION: Environment variables required for Auth0 authentication in the Next.js Starter Kit. These include the Auth0 client ID, client secret, and issuer base URL that need to be added to the .env.local file.

LANGUAGE: dotenv
CODE:
AUTH0_CLIENT_ID=XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
AUTH0_CLIENT_SECRET=XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
AUTH0_ISSUER_BASE_URL=https://XXXXXXXXXXXXXXXXXX.com

----------------------------------------

TITLE: Using Liveblocks Data from Redux Store
DESCRIPTION: Shows how to access Liveblocks data from the Redux store. In this example, it retrieves the 'others' array to display how many other users are online in the room.

LANGUAGE: tsx
CODE:
"use client";

import { useSelector } from "react-redux";

export function Room() {
  const others = useSelector((state) => state.liveblocks.others);
  const userCount = others.length;
  return <div>There are {userCount} other user(s) online</div>;
}

----------------------------------------

TITLE: Configuring Liveblocks Client with Auth Endpoint
DESCRIPTION: Sets up the Liveblocks client to use the authentication endpoint instead of a public API key. This connects the client-side application to the server-side authentication.

LANGUAGE: typescript
CODE:
import { createClient } from "@liveblocks/client";

const client = createClient({
  authEndpoint: "/api/liveblocks-auth",
});

----------------------------------------

TITLE: Using Custom Presence Type with Liveblocks Zustand Middleware
DESCRIPTION: Demonstrates how to type the 'others' presence using the TPresence generic argument on the middleware. This allows for proper typing when accessing other users' presence information in components.

LANGUAGE: typescript
CODE:
type Presence = {
  isTyping: true;
}

const useStore = create(
  middleware<State, Presence>(/* ... */, {
    client,
    presenceMapping: { isTyping: true },
    storageMapping: { todos: true }
  })
);

// In your component
useStore(state => state.liveblocks.others[0].presence?.isTyping)

----------------------------------------

TITLE: Using LiveObject in Liveblocks Schema
DESCRIPTION: Demonstrates how to use LiveObject to create collaborative object types. Wraps a type definition in LiveObject to make it collaborative and observable.

LANGUAGE: typescript
CODE:
type Scientist {
  name: string
  age: number
}

type Storage {
  scientist: LiveObject<Scientist>
  //         ^^^^^^^^^^
}

----------------------------------------

TITLE: Implementing resolveMentionSuggestions for User Mentions
DESCRIPTION: Basic implementation of resolveMentionSuggestions that returns a list of user IDs matching a search text, enabling user mention functionality in the Comments composer.

LANGUAGE: tsx
CODE:
<LiveblocksProvider
  resolveUsers={async ({ userIds }) => {
    // ...
  }}
  resolveMentionSuggestions={async ({ text, roomId }) => {
    // The text the user is searching for, e.g. "mar"
    console.log(text);

    // Return a list of user IDs that match the query
    return ["marc@example.com", "marissa@example.com"];
  }}

  // ...
/>;

----------------------------------------

TITLE: Using useUpdateNotificationSettings Hook in React
DESCRIPTION: Shows how to use the useUpdateNotificationSettings hook from @liveblocks/react to update notification settings without fetching them first. Useful for simple update scenarios like unsubscribe buttons.

LANGUAGE: tsx
CODE:
// A suspense version of this hook is available
import { useUpdateNotificationSettings } from "@liveblocks/react";

const updateSettings = useUpdateNotificationSettings();

const onUnsubscribe = () => {
  updateSettings({
    slack: {
      thread: false,
    },
  });
};

----------------------------------------

TITLE: Using React useSyncStatus Hook Example in TypeScript
DESCRIPTION: Example of using the useSyncStatus hook in React to display a loading spinner when Liveblocks is synchronizing changes to the server. The smooth parameter provides a debounced status suitable for UI display.

LANGUAGE: tsx
CODE:
const {
  inboxNotifications,
  isLoading,
  error,

  // ✨ New in Liveblocks 2.9
  fetchMore,
  isFetchingMore,
  hasFetchedAll,
  fetchMoreError,
} = useInboxNotifications();

----------------------------------------

TITLE: Basic JavaScript Object Example
DESCRIPTION: An example of a simple JavaScript object representing a person with name and age properties. This is shown as a reference before converting to Liveblocks data structures.

LANGUAGE: js
CODE:
person: { name: "Marie", age: 30 }

----------------------------------------

TITLE: Installing Liveblocks Comments with SendGrid Example
DESCRIPTION: Command to create a new Liveblocks application with the SendGrid comments email notifications example. This automatically downloads the example code and prompts for an API key from your Liveblocks account.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-comments-emails-sendgrid --api-key

----------------------------------------

TITLE: Using room.getStatus() Method in @liveblocks/client
DESCRIPTION: Method that returns the current status of the WebSocket connection, which can be 'initial', 'connecting', 'connected', 'reconnecting', or 'disconnected'.

LANGUAGE: typescript
CODE:
room.getStatus()

----------------------------------------

TITLE: Implementing Typing Indicator Component with Liveblocks
DESCRIPTION: Creates a React component that displays a message when another user is typing. It uses the Liveblocks others property to detect when any other user has their isTyping status set to true.

LANGUAGE: tsx
CODE:
import React, { useEffect } from "react";
import useStore from "./store";

import "./App.css";

/* WhoIsHere */

function SomeoneIsTyping() {
  const others = useStore((state) => state.liveblocks.others);

  const someoneIsTyping = others.some((user) => user.presence.isTyping);

  return someoneIsTyping ? (
    <div className="someone_is_typing">Someone is typing</div>
  ) : null;
}

export default function App() {
  const {
    draft,
    setDraft,
    liveblocks: { enterRoom, leaveRoom },
  } = useStore();

  useEffect(() => {
    enterRoom("zustand-todo-app");
    return () => {
      leaveRoom("zustand-todo-app");
    };
  }, [enterRoom, leaveRoom]);

  return (
    <div className="container">
      <WhoIsHere />
      <input
        className="input"
        type="text"
        placeholder="What needs to be done?"
        value={draft}
        onChange={(e) => setDraft(e.target.value)}
      ></input>
      <SomeoneIsTyping />
    </div>
  );
}

----------------------------------------

TITLE: Configuring GitHub Authentication Environment Variables
DESCRIPTION: Environment variables required for GitHub authentication in the Next.js Starter Kit. These include the GitHub client secret and client ID that need to be added to the .env.local file.

LANGUAGE: dotenv
CODE:
GITHUB_CLIENT_SECRET=XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
GITHUB_CLIENT_ID=XXXXXXXXXXXXXXXXXXXX

----------------------------------------

TITLE: Manual Setup with npm install
DESCRIPTION: Command to install all dependencies for the project when setting up manually.

LANGUAGE: bash
CODE:
npm install

----------------------------------------

TITLE: Constructing a Toolbar with Default Section Components
DESCRIPTION: Demonstrates how to construct a toolbar using the default section components provided by Liveblocks. This approach allows for a structured toolbar with predefined functionality groups.

LANGUAGE: tsx
CODE:
import { Toolbar } from "@liveblocks/react-lexical";

function CustomToolbar() {
  return (
    <Toolbar>
      // +++
      <Toolbar.BlockSelector />
      <Toolbar.SectionInline />
      <Toolbar.Separator />
      <Toolbar.SectionCollaboration />
      // +++
    </Toolbar>
  );
}

----------------------------------------

TITLE: Liveblocks React component implementation
DESCRIPTION: Shows a React component file that uses Liveblocks hooks for real-time collaboration. This represents a typical component file that would import and use Liveblocks functionality.

LANGUAGE: typescript
CODE:
file="MyComponent.tsx"

----------------------------------------

TITLE: Using Images in Liveblocks Documentation Markdown
DESCRIPTION: Demonstrates how to use the Image component to display assets from the assets directory in documentation pages, including specifying dimensions and alt text.

LANGUAGE: markdown
CODE:
<Image
  src="/assets/devtools/spreadsheet-example.png"
  alt="Liveblocks DevTools panel"
  width={920}
  height={542}
/>

----------------------------------------

TITLE: Alternative ThreadOverlay with Media Query Hook
DESCRIPTION: An alternative implementation of ThreadOverlay using a custom media query hook to conditionally render either FloatingThreads or AnchoredThreads based on screen size. This approach provides more control over responsive behavior.

LANGUAGE: tsx
CODE:
import { useSyncExternalStore } from "react";
import { useThreads } from "@liveblocks/react/suspense";
import { AnchoredThreads, FloatingThreads } from "@liveblocks/react-lexical";

function ThreadOverlay() {
  const { threads } = useThreads({ query: { resolved: false } });
  // +++
  const isMobile = useIsMobile();
  // +++

  // +++
  if (isMobile) {
    return <FloatingThreads threads={threads} style={{ width: "350px" }} />;
  }
  // +++

  // +++
  return <AnchoredThreads threads={threads} style={{ width: "350px" }} />;
  //+++
}

export function useIsMobile() {
  return useSyncExternalStore(subscribe, getSnapshot, getSnapshot);
}

function subscribe(callback: () => void) {
  const query = window.matchMedia("(max-width: 1024px)");

  query.addEventListener("change", callback);
  return () => query.removeEventListener("change", callback);
}

function getSnapshot() {
  const query = window.matchMedia("(max-width: 1024px)");
  return query.matches;
}

----------------------------------------

TITLE: Using New Liveblocks Room API in TypeScript
DESCRIPTION: Shows the new recommended pattern for entering and leaving rooms in Liveblocks. The enterRoom method returns both the room object and a leave function, allowing for better management of room connections.

LANGUAGE: typescript
CODE:
// New API we'll be recommending instead
const { room, leave } = client.enterRoom("my-room", options);
leave();

----------------------------------------

TITLE: Configuring Liveblocks Client with Authentication Endpoint
DESCRIPTION: Frontend configuration for the Liveblocks client, replacing the public API key with the authentication endpoint.

LANGUAGE: typescript
CODE:
import { createClient } from "@liveblocks/client";

const client = createClient({
  authEndpoint: "/api/liveblocks-auth",
});

----------------------------------------

TITLE: Setting the Ready State in TypeScript
DESCRIPTION: A simple TypeScript code snippet that sets the 'ready' variable to true to indicate that the user is ready to begin the Liveblocks tutorial.

LANGUAGE: typescript
CODE:
export const ready = true;

----------------------------------------

TITLE: Storing JavaScript Object as Example
DESCRIPTION: Simple JavaScript object representation that will be converted to a LiveObject.

LANGUAGE: javascript
CODE:
person: { name: "Marie", age: 30 }

----------------------------------------

TITLE: Invalid RoomEvent Type Definition Example with HTMLElement
DESCRIPTION: Example of an incorrect RoomEvent type definition that uses HTMLElement, which is not a valid JSON value. This causes type errors because Liveblocks requires all event types to be JSON-serializable.

LANGUAGE: typescript
CODE:
declare global {
  interface Liveblocks {
    RoomEvent:
      | { type: "beep" }
      | { type: "boop"; target: HtmlElement }
      //                        ^^^^^^^^^^^ ❌ The issue is here
      | { type: "buzz"; volume: number };
  }
}

----------------------------------------

TITLE: Installing Liveblocks Advanced Collaborative Spreadsheet Example
DESCRIPTION: Command to download and set up the Advanced Collaborative Spreadsheet example from Liveblocks. After running this command, you'll follow guided prompts to create your project with this pre-built example.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-spreadsheet-advanced

----------------------------------------

TITLE: Using shallow comparison with array filtering in React
DESCRIPTION: Shows how to fix unnecessary rerenders by adding the shallow comparison function when filtering arrays in a selector.

LANGUAGE: tsx
CODE:
import { shallow } from "@liveblocks/react";

// ❌ Bad - many unnecessary rerenders
const uncheckedItems = useStorage((root) =>
  root.todos.filter((item) => !item.done)
);

// ✅ Great
const uncheckedItems = useStorage(
  (root) => root.todos.filter((item) => !item.done),
  shallow // 👈 The fix!
);

----------------------------------------

TITLE: Using getSyncStatus Method in Liveblocks Client
DESCRIPTION: Example showing how to use the newly added getSyncStatus method from the client to check synchronization status of pending local changes.

LANGUAGE: typescript
CODE:
client.getSyncStatus()

----------------------------------------

TITLE: Invalid Presence Type Example with Date Object in TypeScript
DESCRIPTION: This code snippet shows an example of an invalid Liveblocks Presence type definition that includes a Date object, which is not a valid JSON value.

LANGUAGE: typescript
CODE:
declare global {
  interface Liveblocks {
    Presence: {
      // Your own fields go here...
      cursor: { x: number; y: number } | null;
      selection: string[];
      lastActivity: Date; // ❌ The issue is here
    };
  }
}

----------------------------------------

TITLE: Retrieving Text Content from Lexical Document
DESCRIPTION: Shows how to extract the text content from a Lexical document using the doc.getTextContent method. This returns a string containing all the text content in the document.

LANGUAGE: typescript
CODE:
const textContent = await withLexicalDocument(
  { roomId: "my-room-id", client: liveblocks },
  async (doc) => {
    return doc.getTextContent();
  }
);

// "My content"
console.log(TextContent);

----------------------------------------

TITLE: Running remove-unneeded-type-params Codemod in Shell
DESCRIPTION: Executes the codemod that removes no longer needed type parameters from Liveblocks types when using global types.

LANGUAGE: shell
CODE:
npx @liveblocks/codemod@latest remove-unneeded-type-params

----------------------------------------

TITLE: Comments Date Format After Liveblocks 1.9
DESCRIPTION: Example showing how date values like 'createdAt' are now returned as Date objects in Liveblocks 1.9. This demonstrates the new format after the breaking change.

LANGUAGE: tsx
CODE:
// ✅ After - Liveblocks 1.9
const { threads } = useThreads();

// Date <Fri Dec 15 2023 14:15:22 GMT+0000 (Greenwich Mean Time)>
console.log(threads[0].createdAt);

----------------------------------------

TITLE: Installing the Notion-like AI Editor Example with Liveblocks CLI
DESCRIPTION: Command to download and set up the Notion-like AI editor example with automatic API key configuration. This creates a new project based on the example and helps set up the Liveblocks API key.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-notion-like-ai-editor --api-key

----------------------------------------

TITLE: Installing Liveblocks Overlay Comments Example with API Key
DESCRIPTION: Command to download and set up the overlay comments example project with automatic API key configuration from a Liveblocks account.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-comments-overlay --api-key

----------------------------------------

TITLE: Connecting to a Liveblocks Room with Initial Presence
DESCRIPTION: JavaScript code to connect to a Liveblocks room with initial presence state. This establishes the collaborative environment for the to-do list application.

LANGUAGE: jsx
CODE:
import { createClient } from "@liveblocks/client";

const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

function run() {
  const { room, leave } = client.enterRoom("javascript-todo-app", {
    initialPresence: { isTyping: false },
  });
}

run();

----------------------------------------

TITLE: Accessing LiveObject Data with useStorage Hook
DESCRIPTION: Example of using the useStorage hook to access and display storage data. This converts the LiveObject to a regular JavaScript object for use in the component.

LANGUAGE: tsx
CODE:
// { person: "Marie", age: 30 }
const person = useStorage((root) => root.person);

----------------------------------------

TITLE: Using Pagination with useThreads Hook (TSX)
DESCRIPTION: Example of using the pagination features added to useThreads in version 2.9.0, providing better user experience with faster initial load and incremental data fetching.

LANGUAGE: tsx
CODE:
const {
  threads,
  isLoading,
  error,

  // ✨ New in Liveblocks 2.9
  fetchMore,
  isFetchingMore,
  hasFetchedAll,
  fetchMoreError,
} = useThreads({ query });

----------------------------------------

TITLE: Using useNotificationSettings Hook for Managing Notification Settings
DESCRIPTION: Example of how to use the useNotificationSettings hook from @liveblocks/react to get and update user notification settings in a React component. This hook returns both the current settings and a function to update them.

LANGUAGE: tsx
CODE:
// A suspense version of this hook is available
import { useNotificationSettings } from "@liveblocks/react";

const [{ isLoading, error, settings }, updateSettings] =
  useNotificationSettings();
// { email: { thread: true, ... }, slack: { thread: false, ... }, ... }
console.log(settings);

const onSave = () => {
  updateSettings({
    slack: {
      textMention: true,
    },
  });
};

----------------------------------------

TITLE: Extending User Type in types/data.ts
DESCRIPTION: How to add a new property to the User type by modifying the TypeScript type definition.

LANGUAGE: typescript
CODE:
export type User = {
  // Your new property
  randomNumber: number;
  // ...
};

----------------------------------------

TITLE: Filtering Rooms by Metadata in Liveblocks
DESCRIPTION: This snippet shows how to retrieve a list of rooms filtered by metadata using the Liveblocks REST API. It constructs a query parameter to filter rooms that have a 'roomType' of 'whiteboard', demonstrating how metadata can be used for organization and discovery.

LANGUAGE: typescript
CODE:
const metadata = "metadata.roomType=whiteboard";
const url = `https://api.liveblocks.io/v2/rooms?${metadata}`;
const response = await fetch(url);
const rooms = await response.json();

----------------------------------------

TITLE: Handling Cursor Leave Events in React with Liveblocks
DESCRIPTION: This function sets the cursor value to null when the pointer leaves the tracked area, effectively removing the cursor from other users' views using updateMyPresence.

LANGUAGE: tsx
CODE:
// Set cursor to null on pointer leave
function handlePointerLeave(e) {
  updateMyPresence({ cursor: null });
}

----------------------------------------

TITLE: Using Room Error Subscription in Client
DESCRIPTION: Example showing how to subscribe to error events on a room using the Liveblocks client. This will now receive errors related to Comments & Notifications in addition to room connection errors.

LANGUAGE: typescript
CODE:
// 👌 Same as before, but might now also receive errors related to Comments & Notifications
room.subscribe("error", (err) => { ... });

----------------------------------------

TITLE: Installing Liveblocks, Yjs, and CodeMirror Dependencies
DESCRIPTION: Command to install all required dependencies for creating a collaborative code editor with Liveblocks, Yjs, and CodeMirror. All Liveblocks packages should use the same version.

LANGUAGE: bash
CODE:
npm install @liveblocks/client @liveblocks/yjs yjs codemirror @codemirror/lang-javascript y-codemirror.next

----------------------------------------

TITLE: Deleting Comments with useDeleteComment in Liveblocks
DESCRIPTION: Shows how to use useDeleteComment hook to delete a comment. If it's the last non-deleted comment, the thread also gets deleted.

LANGUAGE: tsx
CODE:
import { useDeleteComment } from "@liveblocks/react/suspense";

const deleteComment = useDeleteComment();
deleteComment({ threadId: "th_xxx", commentId: "cm_xxx" });

----------------------------------------

TITLE: Configuring LiveblocksProvider with Unsaved Changes Prevention
DESCRIPTION: Example showing how to enable the preventUnsavedChanges option on the LiveblocksProvider component to prevent browser tabs from being closed while local changes are not yet synchronized.

LANGUAGE: tsx
CODE:
<LiveblocksProvider preventUnsavedChanges />

----------------------------------------

TITLE: Retrieving Text Content Using getTextContent Method
DESCRIPTION: Demonstrates how to use the getTextContent method to extract the text content from a Lexical document as a string. This is useful for getting a plain text representation of the document.

LANGUAGE: typescript
CODE:
const textContent = await withLexicalDocument(
  { roomId: "my-room-id", client: liveblocks },
  async (doc) => {
    return doc.getTextContent();
  }
);

----------------------------------------

TITLE: Subscribing to Storage Status Changes in TypeScript
DESCRIPTION: Demonstrates how to subscribe to storage status changes using the room.subscribe method. The code handles different storage states including not-loaded, loading, synchronizing, and synchronized.

LANGUAGE: typescript
CODE:
room.subscribe("storage-status", (status) => {
  switch (status) {
    case "not-loaded":
      break;
    case "loading":
      break;
    case "synchronizing":
      break;
    case "synchronized":
      break;
    default:
      break;
  }
});

----------------------------------------

TITLE: Deploying Liveblocks Comments Example to Vercel
DESCRIPTION: Command to set up and deploy the Liveblocks Comments Primitives example to Vercel, which downloads the example code and guides through the Vercel deployment process.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-comments-primitives --vercel

----------------------------------------

TITLE: Simplifying ClientSideSuspense Component Usage
DESCRIPTION: Example showing how to simplify the ClientSideSuspense component by removing the function wrapper for children.

LANGUAGE: tsx
CODE:
// ❌ Before
<ClientSideSuspense fallback={<Loading />}>
  {() => <MyApp />}
</ClientSideSuspense>

LANGUAGE: tsx
CODE:
// ✅ After
<ClientSideSuspense fallback={<Loading />}>
  <MyApp />
</ClientSideSuspense>

----------------------------------------

TITLE: Deploying Live Cursors Example to Vercel in Bash
DESCRIPTION: Command to create a new Liveblocks application using the nextjs-live-cursors-scroll example and deploy it to Vercel. This automates the deployment process to the Vercel platform.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-live-cursors-scroll --vercel

----------------------------------------

TITLE: Deploying the Liveblocks Text Editor Example on Vercel
DESCRIPTION: Command to download the Liveblocks text editor example and deploy it on Vercel. The command opens a browser to guide through the deployment process on Vercel's platform.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-comments-tiptap --vercel

----------------------------------------

TITLE: Adding Delete Button to App Component
DESCRIPTION: Updates the App component to include a Delete button that calls the deleteShape function from the store. The button is disabled when no shape is selected, providing a better user experience.

LANGUAGE: tsx
CODE:
import { useEffect } from "react";
import useStore from "./store";

import "./App.css";

export default function App() {
  const shapes = useStore((state) => state.shapes);
  const insertRectangle = useStore((state) => state.insertRectangle);
  const others = useStore((state) => state.liveblocks.others);
  const selectedShape = useStore((state) => state.selectedShape);
  const deleteShape = useStore((state) => state.deleteShape);

  /* ... */

  return (
    <>
      <div className="canvas">{/* ... */}</div>
      <div className="toolbar">
        <button onClick={insertRectangle}>Rectangle</button>
        <button onClick={deleteShape} disabled={selectedShape === null}>
          Delete
        </button>
      </div>
    </>
  );
}

/* Rectangle */

----------------------------------------

TITLE: Adding the Notifications Provider to Next.js Layout
DESCRIPTION: Integrating the NotificationsProvider into the application's layout.tsx file to enable notifications functionality throughout the application by wrapping the main app component.

LANGUAGE: tsx
CODE:
import { NotificationsProvider } from "./NotificationsProvider";
import { MyApp } from "./MyApp";

export default function Layout({ children }) {
  return (
    <NotificationsProvider>
      <MyApp />
    </NotificationsProvider>
  );
}

----------------------------------------

TITLE: Initializing a Liveblocks Project
DESCRIPTION: Command to initialize a Liveblocks project using the CLI tool. This creates a configuration file named liveblocks.config.ts used for TypeScript type definitions.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --init

----------------------------------------

TITLE: Deploying the Collaborative Whiteboard on Vercel with Liveblocks CLI
DESCRIPTION: Command to download the example and initiate the Vercel deployment process using the Liveblocks CLI with Vercel integration.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example zustand-whiteboard --vercel

----------------------------------------

TITLE: Configuring Extension Settings in VS Code
DESCRIPTION: Example VS Code extension settings that can be configured. Shows how to document configuration options in a README file for an extension.

LANGUAGE: markdown
CODE:
* `myExtension.enable`: Enable/disable this extension.
* `myExtension.thing`: Set to `blah` to do something.

----------------------------------------

TITLE: Checking for null notification settings in React
DESCRIPTION: Demonstrates how to handle the case when notification settings are not enabled for a particular channel, resulting in a null value.

LANGUAGE: ts
CODE:
const [{ isLoading, error, settings }, updateSettings] =
  useNotificationSettings();

// { email: null, ... }
console.log(settings);

----------------------------------------

TITLE: Using Error Listener with LiveblocksProvider in React
DESCRIPTION: Example showing how to use useErrorListener with LiveblocksProvider instead of RoomProvider to be notified about errors for any room, not just errors specific to one room.

LANGUAGE: typescript
CODE:
// ❌ Before: required a RoomProvider and would only notify about errors for that room
// ✅ Now: requires a LiveblocksProvider and will notify about errors for any room
useErrorListener((err: LiveblocksError) => {
  /* show toast, or notify Sentry, Datadog, etc */
});

----------------------------------------

TITLE: Accessing Extended User Properties in Session
DESCRIPTION: Example of how to access the newly added properties in the session object.

LANGUAGE: typescript
CODE:
// randomNumber: Math.random(),
console.log(session.user.info.randomNumber);

----------------------------------------

TITLE: Using Suspense with Liveblocks Notification Hooks
DESCRIPTION: This snippet shows how to use the Suspense version of Liveblocks notification hooks, which provides simpler code by guaranteeing that data is always defined when the component renders.

LANGUAGE: tsx
CODE:
import { useInboxNotifications } from "../liveblocks.config.ts";

// Suspense: `inboxNotifications` is always defined
function MyNotifications() {
  const { inboxNotifications } = useInboxNotifications();

  // [{ type: "$myCustomNotification", id: "in_sf8s6sh...", ... }, ...]
  console.log(inboxNotifications);
}

----------------------------------------

TITLE: Setting Up LocalTunnel for Webhook Testing
DESCRIPTION: Command to start LocalTunnel for exposing a local development server on port 3000 to the internet, allowing Liveblocks webhooks to reach the local endpoint during development.

LANGUAGE: bash
CODE:
npx localtunnel --port 3000

----------------------------------------

TITLE: Checking Liveblocks dependency versions with npm
DESCRIPTION: Command to list all installed Liveblocks packages and their versions in your project. This helps identify version mismatches that may be causing multiple copies to be loaded.

LANGUAGE: bash
CODE:
npm ls | grep @liveblocks

----------------------------------------

TITLE: Invalid Additional Fields Example in UserMeta
DESCRIPTION: An example showing that only id and info fields are valid top-level fields in UserMeta, and any additional fields will be ignored.

LANGUAGE: tsx
CODE:
declare global {
  interface Liveblocks {
    UserMeta: {
      id: string;
      info: { name: string };

      // Only `id` or `info` make sense inside `UserMeta`
      iWillBeIgnored: string;
    };
  }
}

----------------------------------------

TITLE: Using getOrCreateRoom Method in Node SDK
DESCRIPTION: Shows how to use the new getOrCreateRoom method which optimizes to only make a single round-trip to the server.

LANGUAGE: javascript
CODE:
.getOrCreateRoom()

----------------------------------------

TITLE: Converting Lexical Document to JSON
DESCRIPTION: Shows how to convert a Lexical document to a serialized JSON representation using the toJSON method. This is useful for storing or transferring the document in a serialized format.

LANGUAGE: typescript
CODE:
const docAsJSON = await withLexicalDocument(
  { roomId: "my-room-id", client: liveblocks },
  async (doc) => {
    return doc.toJson();
  }
);

----------------------------------------

TITLE: Deploying Liveblocks Comments Example on Vercel
DESCRIPTION: Command to deploy the Liveblocks comments example on Vercel and run it locally. It downloads the example and requests permission to open the browser for Vercel deployment.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-comments --vercel

----------------------------------------

TITLE: Using useThreads with pagination in React
DESCRIPTION: Updated implementation of useThreads hook that implements pagination support for fetching threads in batches of 50.

LANGUAGE: tsx
CODE:
import { useThreads } from "@liveblocks/react/suspense";

function Threads() {
  const {
    threads,
    // +++
    fetchMore,
    isFetchingMore,
    hasFetchedAll,
    fetchMoreError,
    // +++
  } = useThreads();

  // +++
  const loadMore = fetchMoreError ? (
    <>
      <p>Error loading more threads: {fetchMoreError.message}</p>
      <button onClick={fetchMore} disabled={isFetchingMore}>
        Retry
      </button>
    </>
  ) : (
    <button onClick={fetchMore} disabled={isFetchingMore}>
      Load more
    </button>
  );
  // +++

  return (
    <div>
      {threads.map((thread) => (
        <Thread key={thread.id} thread={thread} />
      ))}
      // +++
      {hasFetchedAll ? <div>🎉 You're all caught up!</div> : loadMore}
      // +++
    </div>
  );
}

----------------------------------------

TITLE: Installing the Liveblocks Text Editor Comments Example with CLI
DESCRIPTION: Command to set up the Liveblocks collaborative text editor example with Tiptap using the Liveblocks CLI tool. This automatically downloads the example and helps obtain an API key from your Liveblocks account.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-comments-tiptap --api-key

----------------------------------------

TITLE: Deploying the Collaborative Text Editor to Vercel
DESCRIPTION: Command to download the Liveblocks collaborative text editor example and launch the Vercel deployment process.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-tiptap-advanced --vercel

----------------------------------------

TITLE: Updated Component Imports in Liveblocks React 2.0
DESCRIPTION: Example showing the improved direct hook imports in Liveblocks React 2.0, eliminating the need to import from a local configuration file and allowing direct import from the package.

LANGUAGE: typescript
CODE:
// ❌ Before: get hooks exported from your Liveblocks config
import { RoomProvider, useRoom, ... } from "./liveblocks.config";

// ✅ After: import hooks directly
import { RoomProvider, useRoom, ... } from "@liveblocks/react";
import { RoomProvider, useRoom, ... } from "@liveblocks/react/suspense";

----------------------------------------

TITLE: Defining RoomEvent Type for Toast Notifications in Liveblocks Config
DESCRIPTION: Defines a RoomEvent type for toast notifications in the Liveblocks configuration file. This type specifies the structure of events that will be broadcast between users, containing a type identifier and a message string.

LANGUAGE: tsx
CODE:
// Event types
RoomEvent: {
  type: "TOAST";
  message: string;
}

----------------------------------------

TITLE: Initializing Storage with LiveList
DESCRIPTION: Sets up the initial storage state with a LiveList named 'people' containing one LiveObject person. This creates the initial collaborative data structure for the application.

LANGUAGE: tsx
CODE:
initialStorage={{
  people: new LiveList([
    new LiveObject({ name: "Marie", age: 30 })
  ]),
}}

----------------------------------------

TITLE: Creating a Room with Custom Metadata in Liveblocks
DESCRIPTION: This snippet demonstrates how to create a new Liveblocks room with custom metadata using the REST API. The example sets a 'roomType' property to 'whiteboard' in the metadata object, which can be used for categorization and filtering.

LANGUAGE: typescript
CODE:
fetch("https://api.liveblocks.io/v2/rooms", {
  method: "POST",
  body: JSON.stringify({
    id: "my-room-name",
    defaultAccesses: [],
    metadata: {
      roomType: "whiteboard",
    },
  }),
});

----------------------------------------

TITLE: Configuring Multiple Authentication Providers in NextAuth
DESCRIPTION: Example of adding multiple authentication providers (GitHub and Auth0) to a NextJS application using NextAuth.js. The code shows how to configure providers in the auth.config.ts file with proper environment variables.

LANGUAGE: typescript
CODE:
import GithubProvider from "next-auth/providers/github";
import Auth0Provider from "next-auth/providers/auth0";

export const authOptions = {
  // ...
  providers: {
    GithubProvider({
      clientId: process.env.GITHUB_CLIENT_ID as string,
      clientSecret: process.env.GITHUB_CLIENT_SECRET as string,
    }),
    Auth0Provider({
      clientId: process.env.AUTH0_CLIENT_ID as string,
      clientSecret: process.env.AUTH0_CLIENT_SECRET as string,
      issuer: process.env.AUTH0_ISSUER_BASE_URL as string,
    }),
  }
};

----------------------------------------

TITLE: Marking All Notifications as Read with useMarkAllInboxNotificationsAsRead Hook
DESCRIPTION: This snippet demonstrates how to use the useMarkAllInboxNotificationsAsRead hook to mark all notifications as read for the current user with a button click.

LANGUAGE: tsx
CODE:
function NotificationReadButton() {
  const markAllInboxNotificationsAsRead = useMarkAllInboxNotificationsAsRead();

  return (
    <button onClick={markAllInboxNotificationsAsRead}>Mark all as read</button>
  );
}

----------------------------------------

TITLE: Setting Up Suspense Boundary in App.tsx
DESCRIPTION: Setting up a React Suspense boundary to handle loading states for Liveblocks components, providing a fallback UI while data is loading.

LANGUAGE: tsx
CODE:
import { Suspense } from "react";

function Setup() {
  return (
    // Once
    <Suspense fallback={<Loading />}>
      <App />
    </Suspense>
  );
}

----------------------------------------

TITLE: Adding User Metadata in Authentication Endpoint
DESCRIPTION: Enhanced authentication endpoint code that demonstrates how to attach user metadata when preparing the session. This metadata will be available to all clients connected to the room.

LANGUAGE: typescript
CODE:
// Get the current user from your database
const user = __getUserFromDB__(request);

// Start an auth session inside your endpoint
const session = liveblocks.prepareSession(
  user.id,
  {
    userInfo: {
      name: user.name,
      avatar: user.avatarUrl,
      colors: user.colorArray,
    }
  }
);

----------------------------------------

TITLE: Debugging UserMeta Type Issues with TypeScript
DESCRIPTION: A troubleshooting technique for finding the root cause of UserMeta type errors by explicitly testing the type compatibility with BaseUserMeta.

LANGUAGE: typescript
CODE:
import type { BaseUserMeta } from "@liveblocks/client";

declare global {
  interface Liveblocks {
    UserMeta: MyUserMeta;
  }
}

// Quick debugging snippet to find root cause
const xxx: BaseUserMeta = {} as MyUserMeta;
//    ^?
//    The error will appear here

----------------------------------------

TITLE: Recommended New Room API in Liveblocks Client
DESCRIPTION: Demonstrates the new, recommended API for entering and leaving rooms in Liveblocks client that provides better support for multiple room connections and improved resource management.

LANGUAGE: typescript
CODE:
// New API we'll be recommending instead
const { room, leave } = client.enterRoom("my-room", options);
leave();

----------------------------------------

TITLE: Creating a Text Formatting Toolbar for Slate Editor
DESCRIPTION: Implements a toolbar component with buttons for basic text formatting (bold, italic, underline). Includes functions to toggle formatting marks and check their active state in the editor.

LANGUAGE: tsx
CODE:
import { Editor } from "slate";
import { useSlate } from "slate-react";
import styles from "./Toolbar.module.css";
import { CustomText } from "./types";

export function Toolbar() {
  const editor = useSlate();

  return (
    <div className={styles.toolbar}>
      <button
        className={styles.button}
        data-active={isMarkActive(editor, "bold") || undefined}
        onClick={(event) => {
          event.preventDefault();
          toggleMark(editor, "bold");
        }}
      >
        B
      </button>
      <button
        className={styles.button}
        data-active={isMarkActive(editor, "italic") || undefined}
        onClick={(event) => {
          event.preventDefault();
          toggleMark(editor, "italic");
        }}
      >
        i
      </button>
      <button
        className={styles.button}
        data-active={isMarkActive(editor, "underline") || undefined}
        onClick={(event) => {
          event.preventDefault();
          toggleMark(editor, "underline");
        }}
      >
        u
      </button>
    </div>
  );
}

function toggleMark(editor: Editor, format: keyof CustomText) {
  const isActive = isMarkActive(editor, format);

  if (isActive) {
    Editor.removeMark(editor, format);
  } else {
    Editor.addMark(editor, format, true);
  }
}

function isMarkActive(editor: Editor, format: keyof CustomText) {
  const marks = Editor.marks(editor);
  return marks ? marks?.[format] === true : false;
}

----------------------------------------

TITLE: Manual Project Setup with NPM and Environment Configuration
DESCRIPTION: Commands for manually setting up the project by installing dependencies and running the development server, after creating an environment file with the Liveblocks secret key.

LANGUAGE: bash
CODE:
npm install

----------------------------------------

TITLE: Using Json Type for Unknown Values in TypeScript
DESCRIPTION: This snippet demonstrates how to fix an invalid Presence type by using the Json type from @liveblocks/client instead of unknown, ensuring all values will be valid JSON.

LANGUAGE: typescript
CODE:
import type { Json } from "@liveblocks/client";

declare global {
  interface Liveblocks {
    Presence: {
      cursor: unknown; // ❌ Unknowns could contain non-JSON
      cursor: Json; // ✅ Prefer using Json
    };
  }
}

----------------------------------------

TITLE: Installing the Liveblocks Tldraw Whiteboard Example with API Key
DESCRIPTION: Command to create a new Liveblocks application based on the tldraw whiteboard example. This automatically downloads the example code and prompts for API key configuration.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-tldraw-whiteboard-storage --api-key

----------------------------------------

TITLE: Installing the Linear-like Issue Tracker Example with Liveblocks CLI
DESCRIPTION: Command to set up the Linear-like issue tracker example using the Liveblocks CLI. This automatically downloads the example project and guides you through setting up your API key from your Liveblocks account.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-linear-like-issue-tracker --api-key

----------------------------------------

TITLE: Global Type Definition for Liveblocks Configuration in TypeScript
DESCRIPTION: Example of globally declaring Liveblocks interfaces to share types across all Liveblocks APIs, improving developer experience by allowing types to be specified once and used everywhere.

LANGUAGE: typescript
CODE:
// ❌ Before
export const {
  suspense: {
    RoomProvider,
    useRoom,
    // etc
  },
} = createRoomContext<Presence, Storage>(client);

// ✅ After
declare global {
  interface Liveblocks {
    Presence: Presence;
    Storage: Storage;
  }
}

----------------------------------------

TITLE: Filtering Threads by Absence of Metadata in React
DESCRIPTION: Demonstrates how to filter threads that do not have specific metadata attributes using the useThreads hook with a query. This allows filtering for threads that are pinned but don't have a color attribute set.

LANGUAGE: ts
CODE:
useThreads({
  query: {
    // Filter any "pinned" threads that don't have a color set
    metadata: {
      pinned: true,
      color: null, // ✨
    },
  },
});

----------------------------------------

TITLE: Formatting MDX Guide for Liveblocks Tutorials in Markdown
DESCRIPTION: Example of how to structure the frontmatter in a guide.mdx file to specify which files are open and visible in the tutorial interface.

LANGUAGE: markdown
CODE:
---
// which file is open on page load
openFile: "/liveblocks.config.ts"

// which files are visible in the project
showFiles: [ 
  "/liveblocks.config.ts",
  "/pages/index.tsx",
]
---

[MDX guide here]

----------------------------------------

TITLE: Configuring Collaborative Tiptap Editor with Liveblocks and Yjs
DESCRIPTION: JavaScript implementation that sets up a collaborative Tiptap text editor using Liveblocks and Yjs. Creates a Liveblocks client, enters a multiplayer room, configures the Yjs provider, and initializes the Tiptap editor with collaboration extensions.

LANGUAGE: javascript
CODE:
import { createClient } from "@liveblocks/client";
import { getYjsProviderForRoom } from "@liveblocks/yjs";
import * as Y from "yjs";
import { Editor } from "@tiptap/core";
import StarterKit from "@tiptap/starter-kit";
import Collaboration from "@tiptap/extension-collaboration";
import CollaborationCursor from "@tiptap/extension-collaboration-cursor";

// Set up Liveblocks client
const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

// Enter a multiplayer room
const { room, leave } = client.enterRoom("my-room");

// Set up Yjs document and Liveblocks Yjs provider
const yProvider = getYjsProviderForRoom(room);
const yDoc = yProvider.getYDoc();

// Set up the Tiptap editor
const element = document.querySelector("editor");
const editor = new Editor({
  element,
  extensions: [
    StarterKit.configure({
      // The Collaboration extension comes with its own history handling
      history: false,
    }),
    // Register the Yjs document with Tiptap
    Collaboration.configure({
      document: yDoc,
    }),
    CollaborationCursor.configure({
      provider: yProvider,
    }),
  ],
});

----------------------------------------

TITLE: Adding New Person Mutation for LiveList
DESCRIPTION: Implements a useMutation function to add a new person to the LiveList. Creates a new LiveObject with default values for name and age, then pushes it to the people LiveList in storage.

LANGUAGE: tsx
CODE:
// Add person mutation
const addPerson = useMutation(({ storage }) => {
  const newPerson = new LiveObject({ name: "Grace", age: 45 });
  storage.get("people").push(newPerson);
}, []);

----------------------------------------

TITLE: Implementing Hierarchical Permissions in Liveblocks
DESCRIPTION: This snippet demonstrates how to implement hierarchical permissions using access tokens, granting different access levels at various organizational levels. It shows full access to specific rooms and read-only access to all rooms in an organization.

LANGUAGE: typescript
CODE:
const session = liveblocks.prepareSession("olivier@example.com");

// Giving full access to one room
session.allow("Vu78Rt:design:9Hdu73", session.FULL_ACCESS);

// Give full access to every room with an ID beginning with "Vu78Rt:product:"
session.allow("Vu78Rt:product:*", session.FULL_ACCESS);

// Give read-only access to every room in the `Vu78Rt` organization
session.allow("Vu78Rt:*", session.READ_ACCESS);

const { body, status } = await session.authorize();

----------------------------------------

TITLE: Importing Hooks Directly in Liveblocks v2.0
DESCRIPTION: Shows how to import Liveblocks React hooks directly from the package rather than from the configuration file, improving developer experience and simplifying imports.

LANGUAGE: typescript
CODE:
// ❌ Before: get hooks exported from your Liveblocks config
import { RoomProvider, useRoom, ... } from "./liveblocks.config";

// ✅ After: import hooks directly
import { RoomProvider, useRoom, ... } from "@liveblocks/react";
import { RoomProvider, useRoom, ... } from "@liveblocks/react/suspense";

----------------------------------------

TITLE: Adding Todo Container to HTML Structure
DESCRIPTION: HTML markup that adds a container element for rendering the to-do items in the interface.

LANGUAGE: html
CODE:
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Liveblocks - Todo list</title>
    <link rel="stylesheet" href="index.css" />
  </head>
  <body>
    <div class="container">
      <div id="who_is_here" class="who_is_here"></div>
      <input id="todo_input" type="text" placeholder="What needs to be done?" />
      <div id="someone_is_typing" class="someone_is_typing"></div>
      <div id="todos_container"></div>
    </div>
    <script src="app.js"></script>
  </body>
</html>

----------------------------------------

TITLE: Implementing User Notification Settings with React
DESCRIPTION: React component that lets users customize their notification preferences for different channels. Uses the useNotificationSettings hook from @liveblocks/react/suspense.

LANGUAGE: tsx
CODE:
import { useNotificationSettings } from "@liveblocks/react/suspense";

function NotificationSettings() {
  const [{ settings }, updateSettings] = useNotificationSettings();

  return (
    <>
      <label>
        Receive thread notifications by email:
        <input
          type="checkbox"
          checked={settings.email?.thread}
          onChange={(e) =>
            updateSettings({ email: { thread: e.target.checked } })
          }
        />
      </label>
      {/* Other checkboxes */}
    </>
  );
}

----------------------------------------

TITLE: Old Method: Handling Loading State
DESCRIPTION: Previous approach for handling the loading state of Liveblocks data, requiring null checks and conditional rendering.

LANGUAGE: tsx
CODE:
function Component() {
  const camera = useObject("camera");
  const items = useList("items");

  // 👎
  if (camera == null || items == null) {
    return <div>Still loading...</div>;
  }

  return <MyRealComponent camera={camera} items={items} />;
}

----------------------------------------

TITLE: Managing Notification Settings with Liveblocks Node.js Client
DESCRIPTION: Demonstrates how to use the Liveblocks Node.js client to manage user notification settings. The snippet shows methods for getting, updating, and deleting notification settings for a specific user.

LANGUAGE: tsx
CODE:
import { Liveblocks } from "@liveblocks/node";
const liveblocks = new Liveblocks({ secret: "sk_xxx" });

const settings = await liveblocks.getNotificationSettings({ userId });
// { email: { thread: true, ... }, slack: { thread: false, ... }, ... }
console.log(settings);

const updatedSettings = await liveblocks.updateNotificationSettings({
  userId,
  data: {
    teams: {
      $fileUploaded: true,
    },
  },
});
await liveblocks.deleteNotificationSettings({ userId });

----------------------------------------

TITLE: Installing Live Cursors Example with Liveblocks CLI
DESCRIPTION: Command to set up the Live Cursors example locally using the Liveblocks CLI. This automatically downloads the example and helps you connect it to your Liveblocks account.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example vuejs-live-cursors --api-key

----------------------------------------

TITLE: Styling the Collaborative Text Editor
DESCRIPTION: CSS module that provides styling for the collaborative text editor. Defines styles for the container, editor, placeholder, and other UI elements.

LANGUAGE: css
CODE:
.container {
  display: flex;
  flex-direction: column;
  position: relative;
  border-radius: 12px;
  background: #fff;
  width: 100%;
  height: 100%;
  color: #111827;
}

.editorHeader {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.editor {
  border-radius: inherit;
  flex-grow: 1;
  width: 100%;
  height: 100%;
  padding: 1rem;
}

.editor:focus {
  outline: none;
}

.editorContainer {
  position: relative;
  height: 100%;
}

.placeholder {
  pointer-events: none;
  position: absolute;
  inset: 0;
  opacity: 0.3;
  padding: 0 1em;
}

----------------------------------------

TITLE: Deploying Collaborative Text Editor to Vercel
DESCRIPTION: Command to set up the collaborative text editor example and deploy it to Vercel using the Liveblocks CLI, which provides a streamlined deployment process.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-tiptap --vercel

----------------------------------------

TITLE: Debugging Technique for Finding Invalid LSON Types
DESCRIPTION: This code snippet shows a debugging technique to find the root cause of LSON type issues by attempting to assign the custom Storage type to LsonObject, which will generate helpful type errors.

LANGUAGE: typescript
CODE:
import type { LsonObject } from "@liveblocks/client";

declare global {
  interface Liveblocks {
    Storage: MyStorage;
  }
}

// Quick debugging snippet to find root cause
const xxx: LsonObject = {} as MyStorage;
//    ^?
//    The error will appear here

----------------------------------------

TITLE: Using Pagination with useThreads Hook
DESCRIPTION: Example showing how to use the pagination features added to the useThreads and useUserThreads_experimental hooks to incrementally load threads as users interact with the app.

LANGUAGE: tsx
CODE:
const {
  threads,
  isLoading,
  error,

  // ✨ New in Liveblocks 2.9
  fetchMore,
  isFetchingMore,
  hasFetchedAll,
  fetchMoreError,
} = useThreads({ query });

----------------------------------------

TITLE: Using Special Tokens in Liveblocks Tutorials
DESCRIPTION: Lists the available token placeholders that can be used in tutorial files to be replaced with actual values at runtime.

LANGUAGE: markdown
CODE:
{% LIVEBLOCKS_PUBLIC_KEY %} - Public API key
{% LIVEBLOCKS_SECRET_KEY %} - Secret API key
{% ROOM_ID %} - The room name that is being used
{% RANDOM_ID %} - A random id
{% DEFAULT_SCRIPTS %} - Needed in _app.tsx of every project
{% DEFAULT_STYLES %} - Needed in globals.css file in every project

----------------------------------------

TITLE: Using Notification Settings Hooks in React
DESCRIPTION: Example of using the useNotificationSettings hook in React components to manage user notification preferences. The hook provides loading states, error handling, and setting management.

LANGUAGE: tsx
CODE:
// A suspense version of this hook is available
import { useNotificationSettings } from "@liveblocks/react";

const [{ isLoading, error, settings }, updateSettings] =
  useNotificationSettings();
// { email: { thread: true, ... }, slack: { thread: false, ... }, ... }
console.log(settings);

const onSave = () => {
  updateSettings({
    slack: {
      textMention: true,
    },
  });
};

----------------------------------------

TITLE: Configuring Environment Variables for Liveblocks Tutorials
DESCRIPTION: Example of environment variables setup for Liveblocks tutorials using token placeholders that will be replaced with actual values at runtime.

LANGUAGE: shell
CODE:
LIVEBLOCKS_SECRET_KEY={% LIVEBLOCKS_SECRET_KEY %}
NEXT_PUBLIC_LIVEBLOCKS_PUBLIC_KEY={% LIVEBLOCKS_PUBLIC_KEY %}

----------------------------------------

TITLE: Accessing and Modifying LiveObject Properties
DESCRIPTION: Demonstrates how to retrieve a LiveObject from storage and modify its properties using get and set methods.

LANGUAGE: typescript
CODE:
const person = storage.get("person");
person.set("name", "Albert");

----------------------------------------

TITLE: Creating Comments with useCreateComment in Liveblocks
DESCRIPTION: Demonstrates how to use useCreateComment hook to add a comment to a thread.

LANGUAGE: tsx
CODE:
import { useCreateComment } from "@liveblocks/react/suspense";

const createComment = useCreateComment();
const comment = createComment({
  threadId: "th_xxx",
  body: {},
  attachments: [],
});

----------------------------------------

TITLE: Implementing Comment Notification Emails with Resend and Liveblocks in TypeScript
DESCRIPTION: This code sets up a webhook endpoint that listens for new comments in Liveblocks, retrieves comment data and participants, converts the comment body to HTML, and sends email notifications using Resend. It requires API keys from both Liveblocks and Resend.

LANGUAGE: typescript
CODE:
import { Liveblocks, WebhookHandler, stringifyCommentBody } from "@liveblocks/node";
import { Resend } from "resend";

// Create Resend client (add your API key)
const resend = new Resend("re_123456789");

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";
const liveblocks = new Liveblocks({ secret: API_SECRET });

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When a comment has been created
  if (event.type === "commentCreated") {
    const { roomId, threadId, commentId } = event.data;

    try {
      // Get comment data and participants
      const [comment, { participantIds }] = await Promise.all([
        liveblocks.getComment({ roomId, threadId, commentId }),
        liveblocks.getThreadParticipants({ roomId, threadId }),
      ]);

      // HTML comment body
      const htmlComment = stringifyCommentBody(comment.body, {
        format: "html",

        async resolveUsers({ userIds }) {
          // Get the correct users from your database
          const users = await __getUsers__(userIds);

          return users.map((user) => ({
            name: user.name,
          }));
        },
      });

      // Get participating users from your database
      const users = await __getUsers__(participantIds);

      // Send email to the users' email addresses
      try {
        const data = await resend.emails.send({
          from: "My company <hello@my-company.com>",
          to: [users.map((user) => user.email)],
          subject: "New comment",
          html: htmlComment,
        });
      } catch (err) {
        console.error(err);
      }
    } catch (err) {
      console.log(err);
      return new Response("Could not fetch comment data", { status: 500 });
    }
  }

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Rendering Custom Notification Types in Liveblocks
DESCRIPTION: Advanced implementation showing how to render different components for specific notification kinds, with an example of a custom $fileUploaded notification type.

LANGUAGE: tsx
CODE:
import { InboxNotification } from "@liveblocks/react-ui";
import { useInboxNotifications } from "../liveblocks.config";

function Component() {
  const { inboxNotifications } = useInboxNotifications();

  return (
    <>
      {inboxNotifications.map((inboxNotification) => (
        <InboxNotification
          key={inboxNotification.id}
          inboxNotification={inboxNotification}
          kinds={{
            $fileUploaded: (props) => (
              <InboxNotification.Custom {...props} title="New file" aside="📁">
                A new file has been uploaded
              </InboxNotification.Custom>
            ),
          }}
        />
      ))}
    </>
  );
}

----------------------------------------

TITLE: Installing @liveblocks/zustand v0.19 with npm
DESCRIPTION: Command to install version 0.19 of @liveblocks/client and @liveblocks/zustand packages using npm.

LANGUAGE: bash
CODE:
npm install @liveblocks/client@0.19 @liveblocks/zustand@0.19

----------------------------------------

TITLE: Checking Storage Loading State with Liveblocks Redux
DESCRIPTION: Uses useSelector to check if the Liveblocks room storage is currently loading.

LANGUAGE: js
CODE:
const connection = useSelector((state) => state.liveblocks.isStorageLoading);

----------------------------------------

TITLE: Running Development Server
DESCRIPTION: Command for running the development server after manual setup, which will make the application available at http://localhost:3000.

LANGUAGE: bash
CODE:
npm run dev

----------------------------------------

TITLE: Integrating Toolbar Component into Lexical Editor
DESCRIPTION: Code snippet showing how to import and integrate the custom Toolbar component into the main Editor component. The toolbar is placed within the editor header section of the Lexical editor structure.

LANGUAGE: tsx
CODE:
import { Toolbar } from "./Toolbar";
// ...

export default function Editor() {
  // ...

  return (
    <div className={styles.container}>
      <LexicalComposer initialConfig={initialConfig}>
        <div className={styles.editorHeader}>
          <Toolbar />
        </div>
        <div className={styles.editorContainer}>{/* ... */}</div>
      </LexicalComposer>
    </div>
  );
}

----------------------------------------

TITLE: Running the Liveblocks Collaborative Text Editor Example Locally
DESCRIPTION: Command to set up the collaborative text editor example project with Liveblocks CLI, which downloads the example and helps obtain an API key from a Liveblocks account.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-tiptap --api-key

----------------------------------------

TITLE: Setting Wildcard Permissions in Liveblocks Auth Endpoint
DESCRIPTION: This code snippet demonstrates how to configure your Liveblocks authentication endpoint to allow access to multiple rooms using wildcards. It grants full access to all rooms with the 'orga1' prefix, which is necessary when handling requests where the room property is undefined.

LANGUAGE: javascript
CODE:
session.allow("orga1*", session.FULL_ACCESS);

----------------------------------------

TITLE: Creating Liveblocks Client - Before and After v2.0
DESCRIPTION: Example showing the transition from using createClient directly to using the LiveblocksProvider component in v2.0.

LANGUAGE: typescript
CODE:
// ❌ Before
const client = createClient(/* options */);

// ✅ After
<LiveblocksProvider /* options */>
  <App />
</LiveblocksProvider>

----------------------------------------

TITLE: Liveblocks configuration file
DESCRIPTION: Shows a Liveblocks configuration file that manages the Liveblocks client and Room context setup. This would typically be located in a file named 'liveblocks.config.ts' in a project.

LANGUAGE: typescript
CODE:
file="liveblocks.config.ts"

----------------------------------------

TITLE: Managing User Notification Settings with @liveblocks/node
DESCRIPTION: Example showing how to get, update, and delete user notification settings using the Liveblocks Node.js client. It demonstrates retrieving current settings, updating specific notification preferences, and completely removing notification settings for a user.

LANGUAGE: tsx
CODE:
import { Liveblocks } from "@liveblocks/node";
const liveblocks = new Liveblocks({ secret: "sk_xxx" });

const settings = await liveblocks.getNotificationSettings({ userId });
// { email: { thread: true, ... }, slack: { thread: false, ... }, ... }
console.log(settings);

const updatedSettings = await liveblocks.updateNotificationSettings({
  userId,
  data: {
    teams: {
      $fileUploaded: true,
    },
  },
});
await liveblocks.deleteNotificationSettings({ userId });

----------------------------------------

TITLE: Running remove-yjs-default-export Codemod in Shell
DESCRIPTION: Executes the codemod that replaces the default import of @liveblocks/yjs with a named LiveblocksYjsProvider import and updates its usage accordingly.

LANGUAGE: shell
CODE:
npx @liveblocks/codemod@latest remove-yjs-default-export

----------------------------------------

TITLE: Using AI to Open Toolbar with Prompt in Tiptap
DESCRIPTION: Example showing how to use the askAi Tiptap command to manually open the AI toolbar, optionally providing a prompt to directly start the request.

LANGUAGE: typescript
CODE:
editor.commands.askAi("Explain this text")

----------------------------------------

TITLE: Valid and Invalid Storage Updates with Scalar Types
DESCRIPTION: Demonstrates valid and invalid updates to a Storage object based on scalar type constraints. Shows proper type validation in action with strings, numbers, booleans, and null values.

LANGUAGE: typescript
CODE:
// ✅ Valid storage updates
root.set("name", "Marie Curie");
root.set("age", 66);
root.set("hasSiblings", true);
root.set("favoritePet", "Cooper");
root.set("favoritePet", null);

// ❌ Invalid storage updates
root.set("name", true);
root.set("hasSiblings", null);
root.set("favoritePet", 0);

----------------------------------------

TITLE: Fully Custom Thread Implementation with Comment Primitives
DESCRIPTION: Example of fully customizing threads by implementing a custom Thread component using Comment primitives. Shows how to access and render thread comments directly.

LANGUAGE: tsx
CODE:
import { Comment } from "@liveblocks/react-ui/primitives";

<FloatingThreads
  threads={threads}
  className="my-floating-thread"
  components={{
    Thread: (props) => (
      // +++
      <div>
        {props.thread.comments.map((comment) => (
          <Comment.Body
            key={comment.id}
            body={comment.body}
            components={/* ... */}
          />
        ))}
      </div>
      // +++
    ),
  }}
/>;

----------------------------------------

TITLE: Deploying Liveblocks Avatar Stack to Vercel
DESCRIPTION: Command to install the Liveblocks avatar stack example with Vercel deployment configuration.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example solidjs-live-avatars --vercel

----------------------------------------

TITLE: Converting Local Webhook URL to Public localtunnel URL
DESCRIPTION: Example of how to replace your localhost URL with the generated localtunnel URL to create a publicly accessible webhook endpoint for testing.

LANGUAGE: shell
CODE:
# Take your local URL
http://localhost:3000/api/liveblocks-notifications

# Replace localhost with the generated domain, then copy it
https://my-localtunnel-url.loca.lt/api/liveblocks-notifications

----------------------------------------

TITLE: Fetching User Information with useUser Hook
DESCRIPTION: Example of using the useUser hook to fetch user information based on a user ID. This retrieves user data like name, avatar, and custom properties defined in the resolveUsers function.

LANGUAGE: tsx
CODE:
import { useUser } from "../liveblocks.config";

function Component() {
  const { user } = useUser("olivier@example.com");

  // { name: "Olivier", avatar: "https://...", color: "red" }
  console.log(user);

  return <img src={user.avatar} alt={user.name} />;
}

----------------------------------------

TITLE: CSS Variables for Comments - After
DESCRIPTION: Updated approach to styling tooltips and elevations in Liveblocks 1.10, targeting specific class selectors instead of using global variables.

LANGUAGE: css
CODE:
/* ✅ After - Liveblocks 1.10 */
.lb-tooltip {
  --lb-foreground: white;
}

.lb-elevation {
  --lb-background: red;
}

----------------------------------------

TITLE: Filtering Threads by Absence of Metadata in Liveblocks React
DESCRIPTION: Shows how to filter threads by the absence of metadata attributes using the useThreads hook with the query parameter. The example demonstrates filtering for threads that are pinned but don't have a color set.

LANGUAGE: ts
CODE:
useThreads({
  query: {
    // Filter any "pinned" threads that don't have a color set
    metadata: {
      pinned: true,
      color: null, // ✨
    },
  },
});

----------------------------------------

TITLE: Setting up Liveblocks Comments Project with NPM
DESCRIPTION: Commands for installing dependencies, setting up environment variables, and running the development server for the Liveblocks comments example.

LANGUAGE: bash
CODE:
npm install
npm run dev

----------------------------------------

TITLE: Setting up Liveblocks Authentication with Next.js App Router
DESCRIPTION: Implementation of the authentication endpoint using the Next.js App Router. This endpoint creates a session for the current user and authorizes access to a Liveblocks room.

LANGUAGE: typescript
CODE:
import { Liveblocks } from "@liveblocks/node";
import { NextRequest } from "next/server";

const API_KEY = "{{SECRET_KEY}}";

const liveblocks = new Liveblocks({
  secret: API_KEY!,
});

export async function POST(request: NextRequest) {
  // Get the current user's info from your database
  const user = {
    id: "charlielayne@example.com",
    info: {
      name: "Charlie Layne",
      color: "#D583F0",
      picture: "https://liveblocks.io/avatars/avatar-1.png",
    },
  };

  // Create a session for the current user
  // userInfo is made available in Liveblocks presence hooks, e.g. useOthers
  const session = liveblocks.prepareSession(user.id, {
    userInfo: user.info,
  });

  // Give the user access to the room
  const { room } = await request.json();
  session.allow(room, session.FULL_ACCESS);

  // Authorize the user and return the result
  const { body, status } = await session.authorize();
  return new Response(body, { status });
}

----------------------------------------

TITLE: Deploying TipTap Notifications Email Example to Vercel
DESCRIPTION: Command to download the example and deploy it to Vercel. This streamlines the process of setting up both local development and cloud deployment.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-tiptap-emails-resend --vercel

----------------------------------------

TITLE: Using useNotificationSettings Hook with @liveblocks/react
DESCRIPTION: Example of using the useNotificationSettings hook to retrieve and update notification settings. This hook returns both the current settings and a function to update them.

LANGUAGE: tsx
CODE:
// A suspense version of this hook is available
import { useNotificationSettings } from "@liveblocks/react";

const [{ isLoading, error, settings }, updateSettings] =
  useNotificationSettings();
// { email: { thread: true, ... }, slack: { thread: false, ... }, ... }
console.log(settings);

const onSave = () => {
  updateSettings({
    slack: {
      textMention: true,
    },
  });
};

----------------------------------------

TITLE: Using Pagination Support with useThreads Hook in React
DESCRIPTION: Example of using the pagination support added to the useThreads hook in Liveblocks 2.9. This allows for more efficient loading of thread data with fetchMore capabilities.

LANGUAGE: tsx
CODE:
const {
  threads,
  isLoading,
  error,

  // ✨ New in Liveblocks 2.9
  fetchMore,
  isFetchingMore,
  hasFetchedAll,
  fetchMoreError,
} = useThreads({ query });

----------------------------------------

TITLE: Configuring Custom Text Styles with Lexical Editor Theme
DESCRIPTION: Snippet showing how to customize the Lexical editor theme by defining CSS classes for text formatting styles like bold, italic, and underline. These theme settings are included in the initialConfig of the editor.

LANGUAGE: tsx
CODE:
import styles from "./Editor.module.css";
// ...

// Set up editor config and theme
const initialConfig = {
  // NOTE: This is critical for collaboration plugin to set editor state to null. It
  // would indicate that the editor should not try to set any default state
  // (not even empty one), and let collaboration plugin do it instead
  editorState: null,
  namespace: "Demo",
  nodes: [],
  onError: (error: unknown) => {
    throw error;
  },
  theme: {
    text: {
      bold: styles.textBold,
      italic: styles.textItalic,
      underline: styles.textUnderline,
    },
    paragraph: styles.paragraph,
  },
};

// ...

----------------------------------------

TITLE: Using LiveblocksClient to Manage Notification Settings in JavaScript/TypeScript
DESCRIPTION: This snippet demonstrates how to use the createClient method from @liveblocks/client to fetch and update user notification settings. It shows how to retrieve current settings and then update them by disabling email thread notifications.

LANGUAGE: typescript
CODE:
import { createClient } from '@liveblocks/client'
const client = createClient({ ... })

const settings = await client.getNotificationSettings();
// { email: { thread: true, ... }, slack: { thread: false, ... }, ... }
console.log(settings);

const updatedSettings = await client.updateNotificationSettings({
  email: {
    thread: false,
  }
});

----------------------------------------

TITLE: Using LiveList.set Method to Update List Elements
DESCRIPTION: Example of using the LiveList.set method introduced in v0.16.0 to update a specific element at a given index in a LiveList.

LANGUAGE: typescript
CODE:
const list = new LiveList(["🦁", "🦊", "🐵"]);
list.set(0, "🐺");
list.toArray(); // equals ["🐺", "🦊", "🐵"]

----------------------------------------

TITLE: Defining ThreadMarkedAsResolvedEvent Schema and Example in TypeScript
DESCRIPTION: TypeScript definition for ThreadMarkedAsResolvedEvent which is triggered when a thread is marked as resolved. This event includes information about who resolved the thread and when.

LANGUAGE: typescript
CODE:
// Schema
type ThreadMarkedAsResolvedEvent = {
  type: "threadMarkedAsResolved";
  data: {
    projectId: string;
    roomId: string;
    threadId: string;
    updatedAt: string;
    updatedBy: string;
  };
};

// Example
const ThreadMarkedAsResolvedEvent = {
  type: "threadMarkedAsResolved",
  data: {
    projectId: "my-project-id",
    roomId: "my-room-id",
    threadId: "my-thread-id",
    updatedAt: "2021-10-06T01:45:56.558Z",
    updatedBy: "my-user-id",
  },
};

----------------------------------------

TITLE: Subscribing to Storage Status Changes in Liveblocks
DESCRIPTION: This snippet demonstrates how to subscribe to storage status changes in a Liveblocks room. It uses the 'storage-status' event and handles the different status values: 'not-loaded', 'loading', 'synchronizing', and 'synchronized'.

LANGUAGE: typescript
CODE:
room.subscribe("storage-status", (status) => {
  switch (status) {
    case "not-loaded":
      break;
    case "loading":
      break;
    case "synchronizing":
      break;
    case "synchronized":
      break;
    default:
      break;
  }
});

----------------------------------------

TITLE: Checking Text Mention Events and User Permissions
DESCRIPTION: This code checks if the webhook event is a text mention notification on the email channel and verifies if the user has access to the room. It demonstrates how to use isTextMentionNotificationEvent and implement permission checking before sending notifications.

LANGUAGE: typescript
CODE:
import {
  WebhookHandler,
  isTextMentionNotificationEvent,
} from "@liveblocks/node";

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // +++
  // When an inbox notification has been created on the email channel
  if (isTextMentionNotificationEvent(event) && event.data.channel === "email") {
    // Check if user has access to room
    if (!__hasRoomAccess__(event.userId, event.roomId)) {
      return new Response(null, { status: 200 });
    }

    // The user to send the email to
    const emailAddress = __getEmailAddressFromDB__(event.userId);

    // Send notifications
    // ...
  }
  // +++

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Importing Default Styles for Liveblocks React UI
DESCRIPTION: Imports the default CSS styles for Liveblocks React UI comments components. This is the first step when using the default components.

LANGUAGE: typescript
CODE:
import "@liveblocks/react-ui/styles.css";

----------------------------------------

TITLE: Creating a New Thread with the Composer Component
DESCRIPTION: Example showing how to implement the Composer component to create a new thread. By default, submitting the composer will create a new thread in the room.

LANGUAGE: tsx
CODE:
import { Composer } from "@liveblocks/react-ui";

// Creates a new thread
function Component() {
  return <Composer />;
}

----------------------------------------

TITLE: Example of Invalid LSON in Liveblocks Storage with unknown Type
DESCRIPTION: This code snippet demonstrates the issue with using unknown types in a LiveList, which could potentially contain non-LSON values, and shows the correct approach using the Lson type.

LANGUAGE: typescript
CODE:
import type { Lson } from "@liveblocks/client";

declare global {
  interface Liveblocks {
    Storage: {
      layers: LiveMap<string, LiveObject<Layer>>;
      layerIds: LiveList<unknown>; // ❌ Unknowns could contain non-LSON
      layerIds: LiveList<Lson>; // ✅ Prefer using Lson
    };
  }
}

----------------------------------------

TITLE: Installing the Liveblocks Collaborative Whiteboard Example with CLI
DESCRIPTION: Command to set up the advanced whiteboard example using the Liveblocks CLI tool, which downloads the example and helps obtain an API key from liveblocks.io.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-whiteboard-advanced --api-key

----------------------------------------

TITLE: Complete TextEditor Implementation with ThreadsConfiguration
DESCRIPTION: A complete example showing how to integrate useThreads hook with AnchoredThreads in a BlockNote editor implementation.

LANGUAGE: tsx
CODE:
// +++
import { useThreads } from "@liveblocks/react/suspense";
// +++
import {
  FloatingComposer,
  // +++
  AnchoredThreads,
  // +++
  useCreateBlockNoteWithLiveblocks,
} from "@liveblocks/react-blocknote";
import { BlockNoteView } from "@blocknote/mantine";

function TextEditor() {
  const editor = useCreateBlockNoteWithLiveblocks({});

  // +++
  const { threads } = useThreads();
  // +++

  return (
    <div>
      <BlockNoteView editor={editor} />
      <FloatingComposer editor={editor} style={{ width: "350px" }} />
      // +++
      <AnchoredThreads
        editor={editor}
        threads={threads}
        style={{ width: "350px" }}
      />
      // +++
    </div>
  );
}

----------------------------------------

TITLE: Deploying the Video Comments Example to Vercel
DESCRIPTION: Command to download the example and deploy it to Vercel. This approach handles both the deployment process and local development setup.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-comments-video --vercel

----------------------------------------

TITLE: Accessing User Metadata with useSelf Hook
DESCRIPTION: Example of how to access user metadata in a React component using the useSelf hook. This allows components to display personalized information about the current user.

LANGUAGE: tsx
CODE:
export { useSelf } from "@liveblocks/react/suspense";

function Component() {
  const { name, avatar, colors } = useSelf((me) => me.info);
}

----------------------------------------

TITLE: Using useNotificationSettings Hook in React
DESCRIPTION: Demonstrates how to use the useNotificationSettings hook to get and update user notification settings in a React component.

LANGUAGE: tsx
CODE:
// A suspense version of this hook is available
import { useNotificationSettings } from "@liveblocks/react";

const [{ isLoading, error, settings }, updateSettings] =
  useNotificationSettings();
// { email: { thread: true, ... }, slack: { thread: false, ... }, ... }
console.log(settings);

const onSave = () => {
  updateSettings({
    slack: {
      textMention: true,
    },
  });
};

----------------------------------------

TITLE: Adding Cursors Component to Monaco Editor
DESCRIPTION: Code snippet showing how to integrate the Cursors component into a Monaco Editor setup. This connects the Yjs provider to enable real-time cursor visualization for collaborative editing.

LANGUAGE: tsx
CODE:
import { Cursors } from "@/components/Cursors";
// ...

export function CollaborativeEditor() {
  // ...

  return (
    <div className={styles.container}>
      {provider ? <Cursors yProvider={provider} /> : null}
      <div className={styles.editorContainer}>
        <Editor
          onMount={handleOnMount}
          height="100%"
          width="100hw"
          theme="vs-light"
          defaultLanguage="typescript"
          defaultValue=""
          options={{
            tabSize: 2,
            padding: { top: 20 },
          }}
        />
      </div>
    </div>
  );
}

----------------------------------------

TITLE: Typing Others' Presence with Liveblocks Zustand Middleware
DESCRIPTION: Demonstrates how to type the 'others' presence information when using the Liveblocks middleware with Zustand. This allows for proper type checking when accessing other users' presence data.

LANGUAGE: typescript
CODE:
type Presence = {
  isTyping: true;
}

const useStore = create(
  middleware<State, Presence>(/* ... */, {
    client,
    presenceMapping: { isTyping: true },
    storageMapping: { todos: true }
  })
);

// In your component
useStore(state => state.liveblocks.others[0].presence?.isTyping)

----------------------------------------

TITLE: Installing Liveblocks Email Package with npm
DESCRIPTION: Command to install the required Liveblocks packages for email functionality. This installs both the @liveblocks/node and @liveblocks/emails packages which are needed to implement email functionality based on Liveblocks notification events.

LANGUAGE: bash
CODE:
npm install @liveblocks/node @liveblocks/emails

----------------------------------------

TITLE: Using Liveblocks Hooks and Components for Notifications
DESCRIPTION: Implementation of useInboxNotifications hook along with InboxNotificationList and InboxNotification components to retrieve and display project notifications.

LANGUAGE: tsx
CODE:
"use client";

import { useInboxNotifications } from "@liveblocks/react/suspense";
import {
  InboxNotification,
  InboxNotificationList,
} from "@liveblocks/react-ui";

export function CollaborativeApp() {
  const { inboxNotifications } = useInboxNotifications();

  return (
    <InboxNotificationList>
      {inboxNotifications.map((inboxNotification) => (
        <InboxNotification
          key={inboxNotification.id}
          inboxNotification={inboxNotification}
        />
      ))}
    </InboxNotificationList>
  );
}

----------------------------------------

TITLE: Using asChild to Merge with Design System Components in React
DESCRIPTION: Demonstrates how to use the asChild property to merge Liveblocks primitives with design system components, avoiding nested HTML elements and maintaining proper accessibility.

LANGUAGE: tsx
CODE:
<Comment.Link href={href} style={{ color: "purple " }} asChild>
  <DesignSystemLink url={href}>{children}</DesignSystemLink>
</Comment.Link>

// ===================================================================

// ✅ Renders one combined <a> tag
<a href="https://liveblocks.io" style="color: purple" target="_blank">
  https://liveblocks.io
</a>

----------------------------------------

TITLE: Checking Text Format with isTextFormatActive in Liveblocks Lexical
DESCRIPTION: This snippet demonstrates how to use the isTextFormatActive utility function to check if a specific text format (like bold, italic) is active in the current editor selection. It takes a Lexical editor instance and returns a boolean.

LANGUAGE: tsx
CODE:
import { isTextFormatActive } from "@liveblocks/react-lexical";

// "true" | "false"
const isActive = isTextFormatActive(editor, "bold");

----------------------------------------

TITLE: Installing Collaborative To-do List Example with Liveblocks
DESCRIPTION: Command to set up the collaborative to-do list example locally without API key or Vercel deployment. This downloads the example and installs its dependencies.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example javascript-todo-list --no-api-key --no-vercel

----------------------------------------

TITLE: Creating React-Based Emails for Thread Notifications
DESCRIPTION: This complete example demonstrates how to generate different emails based on notification types (unreadMention or unreadReplies). It renders React components for email content, showing the comment author, timestamp, and comment body.

LANGUAGE: tsx
CODE:
import {
  Liveblocks,
  WebhookHandler,
  isThreadNotificationEvent,
} from "@liveblocks/node";
import { prepareThreadNotificationEmailAsReact } from "@liveblocks/emails";

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";
const liveblocks = new Liveblocks({ secret: API_SECRET });

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When an inbox notification has been created on the email channel
  if (isThreadNotificationEvent(event) && event.data.channel === "email") {
    // Check if user has access to room
    if (!__hasRoomAccess__(event.userId, event.roomId)) {
      return new Response(null, { status: 200 });
    }

    // The user to send the email to
    const emailAddress = __getEmailAddressFromDB__(event.userId);

    let emailData;

    try {
      emailData = await prepareThreadNotificationEmailAsReact(
        liveblocks,
        event
      );
    } catch (err) {
      console.log(err);
      return new Response("Could not fetch thread notification data", {
        status: 500,
      });
    }

    // All comments have already been read
    if (!emailData) {
      return new Response(null, { status: 200 });
    }

    // +++
    let email;
    switch (emailData.type) {
      case "unreadMention": {
        email = (
          <div>
            <div>
              @{emailData.comment.author.id} at {emailData.comment.createdAt}
            </div>
            <div>{emailData.comment.reactBody}</div>
          </div>
        );
        break;
      }

      case "unreadReplies": {
        email = (
          <div>
            {emailData.comments.map((comment) => (
              <div key={comment.id}>
                <div>
                  @{comment.author.id} at {comment.createdAt}
                </div>
                <div>{comment.reactBody}</div>
              </div>
            ))}
          </div>
        );
        break;
      }
    }
    // +++

    // Send emails
    // ...
  }

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Example Mention Search Text and Expected User IDs
DESCRIPTION: This shell example illustrates the mention search mechanism. When a user types "@mar", Liveblocks will pass "mar" as the search text, and your implementation should return matching user IDs.

LANGUAGE: shell
CODE:
# If "@mar" has been typed, this is `text`
"mar"

# Return matching `usersIds`
["marc@example.com", "marissa@example.com"]

----------------------------------------

TITLE: Replying to a Thread with Composer Component
DESCRIPTION: Example showing how to use the Composer component to add a reply to an existing thread by providing a threadId. When a threadId is provided, submissions create new comments within that thread.

LANGUAGE: tsx
CODE:
import { Composer } from "@liveblocks/react-ui";

// Adds a new comment to a thread
function Component({ threadId }) {
  return <Composer threadId={threadId} />;
}

----------------------------------------

TITLE: Toolbar.Toggle variations with icons and shortcuts
DESCRIPTION: Demonstrates various configurations of Toolbar.Toggle including text-only, keyboard shortcuts, custom icons, Liveblocks icons, and passing custom props to the underlying button element.

LANGUAGE: tsx
CODE:
import { Toolbar } from "@liveblocks/react-tiptap";
import { Icon } from "@liveblocks/react-ui";

// Button says "Highlight"
<Toolbar.Toggle
  name="Highlight"
  active={/* ... */}
  onClick={/* ... */}
/>

// Tooltip says "Highlight [⌘+H]"
<Toolbar.Toggle
  name="Highlight"
  shortcut="CMD+H"
  active={/* ... */}
  onClick={/* ... */}
/>

// Custom icon, replaces the name in the button
<Toolbar.Toggle
  name="Highlight"
  icon={<div>🖊</div>}
  active={/* ... */}
  onClick={/* ... */}
/>

// Using a Liveblocks icon, replaces the name in the button
<Toolbar.Toggle
  name="Highlight"
  icon={<Icon.QuestionMark />}
  active={/* ... */}
  onClick={/* ... */}
/>

// Passing children visually replaces the `name` and `icon`
<Toolbar.Toggle
  name="Highlight"
  active={/* ... */}
  onClick={/* ... */}
>
  🖊️Highlight
</Toolbar.Toggle>

// Props are passed to the inner `button`
<Toolbar.Toggle
  name="Highlight"
  active={/* ... */}
  onClick={/* ... */}
  style={{ marginLeft: 10 }}
  className="custom-toggle"
  onMouseOver={() => console.log("Hovered")}
/>

----------------------------------------

TITLE: Toolbar.Toggle variations with icons and shortcuts
DESCRIPTION: Demonstrates various configurations of Toolbar.Toggle including text-only, keyboard shortcuts, custom icons, Liveblocks icons, and passing custom props to the underlying button element.

LANGUAGE: tsx
CODE:
import { Toolbar } from "@liveblocks/react-tiptap";
import { Icon } from "@liveblocks/react-ui";

// Button says "Highlight"
<Toolbar.Toggle
  name="Highlight"
  active={/* ... */}
  onClick={/* ... */}
/>

// Tooltip says "Highlight [⌘+H]"
<Toolbar.Toggle
  name="Highlight"
  shortcut="CMD+H"
  active={/* ... */}
  onClick={/* ... */}
/>

// Custom icon, replaces the name in the button
<Toolbar.Toggle
  name="Highlight"
  icon={<div>🖊</div>}
  active={/* ... */}
  onClick={/* ... */}
/>

// Using a Liveblocks icon, replaces the name in the button
<Toolbar.Toggle
  name="Highlight"
  icon={<Icon.QuestionMark />}
  active={/* ... */}
  onClick={/* ... */}
/>

// Passing children visually replaces the `name` and `icon`
<Toolbar.Toggle
  name="Highlight"
  active={/* ... */}
  onClick={/* ... */}
>
  🖊️Highlight
</Toolbar.Toggle>

// Props are passed to the inner `button`
<Toolbar.Toggle
  name="Highlight"
  active={/* ... */}
  onClick={/* ... */}
  style={{ marginLeft: 10 }}
  className="custom-toggle"
  onMouseOver={() => console.log("Hovered")}
/>

----------------------------------------

TITLE: Importing Liveblocks Hooks Directly in React Component
DESCRIPTION: Comparison between old and new approach for importing hooks in @liveblocks/react, showing how hooks can now be imported directly from the package rather than through a configuration file.

LANGUAGE: typescript
CODE:
// ❌ Before: get hooks exported from your Liveblocks config
import { RoomProvider, useRoom, ... } from "./liveblocks.config";

// ✅ After: import hooks directly
import { RoomProvider, useRoom, ... } from "@liveblocks/react";
import { RoomProvider, useRoom, ... } from "@liveblocks/react/suspense";

----------------------------------------

TITLE: Updating metadata filtering from undefined to null (Before)
DESCRIPTION: Example showing the previous (pre-2.16) way of filtering threads by absence of metadata using undefined, which will no longer work after upgrading.

LANGUAGE: ts
CODE:
const threads = useThreads({
  query: {
    metadata: {
      // ❌ Before - Will have no effect in 2.16
      // +++
      color: undefined,
      // +++
      label: "important",
    },
  },
});

----------------------------------------

TITLE: Installing the Collaborative Text Editor Example Project using Liveblocks CLI
DESCRIPTION: Command to download and set up the collaborative text editor example project using the Liveblocks CLI. This automatically sets up the necessary files and retrieves an API key from your Liveblocks account.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-lexical --api-key

----------------------------------------

TITLE: Advanced Authentication Endpoint Configuration with Custom Headers
DESCRIPTION: Advanced configuration for the Liveblocks client using a callback function to pass custom headers and body data to the authentication endpoint.

LANGUAGE: typescript
CODE:
import { createClient } from "@liveblocks/client";

// Passing custom headers and body to your endpoint
const client = createClient({
  authEndpoint: async (room) => {
    const headers = {
      // Custom headers
      // ...

      "Content-Type": "application/json",
    };

    const body = JSON.stringify({
      // Custom body
      // ...

      room,
    });

    const response = await fetch("/api/liveblocks-auth", {
      method: "POST",
      headers,
      body,
    });

    return await response.json();
  },
});

----------------------------------------

TITLE: Installing Liveblocks Redux Dependencies
DESCRIPTION: Command to install the required packages for integrating Liveblocks with Redux. This requires both the client library and the Redux-specific package.

LANGUAGE: bash
CODE:
npm install @liveblocks/client @liveblocks/redux

----------------------------------------

TITLE: Typing Custom Notification Kinds in TypeScript Configuration
DESCRIPTION: This code shows how to type your Liveblocks application to receive hints for custom notifications. It extends the global Liveblocks interface to include custom activity data for a custom notification kind called $documentInvite.

LANGUAGE: typescript
CODE:
declare global {
  interface Liveblocks {
    // Custom activities data for custom notification kinds
    ActivitiesData: {
      // +++
      $documentInvite: {
        documentId: string; // Example
      };
      // +++
    };

    // ...
  }
}

----------------------------------------

TITLE: Filtering Threads by Metadata Absence in React
DESCRIPTION: This code demonstrates how to filter threads by the absence of metadata using the useThreads hook in @liveblocks/react. It shows how to query for threads that have a specific attribute (pinned) but don't have another attribute (color).

LANGUAGE: ts
CODE:
useThreads({
  query: {
    // Filter any "pinned" threads that don't have a color set
    metadata: {
      pinned: true,
      color: null, // ✨
    },
  },
});

----------------------------------------

TITLE: Using synchronization status hook with React
DESCRIPTION: Example of using the useSyncStatus hook in React to track synchronization status of local changes, useful for displaying a saving indicator in applications.

LANGUAGE: TSX
CODE:
const {
  inboxNotifications,
  isLoading,
  error,

  // ✨ New in Liveblocks 2.9
  fetchMore,
  isFetchingMore,
  hasFetchedAll,
  fetchMoreError,
} = useInboxNotifications();

----------------------------------------

TITLE: Adding a Floating Comments Composer to Tiptap Editor
DESCRIPTION: Implements the FloatingComposer component to enable text annotations and comments in the Tiptap editor.

LANGUAGE: tsx
CODE:
<FloatingComposer editor={editor} />

----------------------------------------

TITLE: Installing Liveblocks Live Cursors Example with API Key Setup
DESCRIPTION: Command to download and set up the SvelteKit live cursors example with automatic API key configuration. This creates a new project with the Liveblocks live cursors functionality and opens a browser to link your Liveblocks account.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example sveltekit-live-cursors --api-key

----------------------------------------

TITLE: Integrating Liveblocks Storage Data with Vercel Postgres
DESCRIPTION: A complete implementation that synchronizes Liveblocks Storage data with a Vercel Postgres database. This code handles webhook verification, fetches the Storage data via REST API, and creates/updates records in a Postgres database.

LANGUAGE: typescript
CODE:
import { WebhookHandler } from "@liveblocks/node";
import { sql } from "@vercel/postgres";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When Storage document data has been updated
  if (event.type === "storageUpdated") {
    const { roomId } = event.data;

    // Get Storage data from Liveblocks REST API
    const url = `https://api.liveblocks.io/v2/rooms/${roomId}/storage`;
    const response = await fetch(url, {
      headers: { Authorization: `Bearer ${API_SECRET}` },
    });

    if (!response.ok) {
      return new Response("Problem accessing Liveblocks REST APIs", {
        status: 500,
      });
    }

    // Your JSON Storage document data as a string
    const storageData = await response.text();

    // Update database
    try {
      await sql`
        CREATE TABLE IF NOT EXISTS documents (
          roomId VARCHAR(255) PRIMARY KEY,
          storageData TEXT NOT NULL
        );
      `;
      await sql`
        INSERT INTO documents (roomId, storageData)
        VALUES (${roomId}, ${storageData})
        ON CONFLICT (roomId)
        DO UPDATE SET
          storageData = EXCLUDED.storageData
      `;
    } catch (err) {
      return new Response("Problem inserting data into database", {
        status: 500,
      });
    }
  }

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Accessing User Data with useUser Hook in React Component
DESCRIPTION: This snippet demonstrates how to access user information in a React component using the useUser hook. This allows you to retrieve user metadata including custom properties that were returned from the resolveUsers function.

LANGUAGE: tsx
CODE:
function Component() {
  const { user } = useUser("marc@example.com");

  // { color: "red", name: "Marc", avatar: "https://example.com/marc.png" }
  console.log(user);

  // ...
}

----------------------------------------

TITLE: Displaying a Comment Component with LiveBlocks
DESCRIPTION: Simple example of using the Comment component to display a single comment in a LiveBlocks React UI application.

LANGUAGE: tsx
CODE:
<Comment comment={comment} />

----------------------------------------

TITLE: Basic Usage of useThreads Hook in Liveblocks React
DESCRIPTION: Shows how to use the useThreads hook to retrieve threads within a room. Returns threads along with loading and error states.

LANGUAGE: tsx
CODE:
import { useThreads } from "@liveblocks/react/suspense";

const { threads, error, isLoading } = useThreads();

----------------------------------------

TITLE: Basic Usage of useThreads Hook in Liveblocks React
DESCRIPTION: Shows how to use the useThreads hook to retrieve threads within a room. Returns threads along with loading and error states.

LANGUAGE: tsx
CODE:
import { useThreads } from "@liveblocks/react/suspense";

const { threads, error, isLoading } = useThreads();

----------------------------------------

TITLE: Setting Anonymous User Properties for Liveblocks
DESCRIPTION: How to provide properties for anonymous users in authorizeLiveblocks.ts.

LANGUAGE: typescript
CODE:
// Anonymous user info
const anonymousUser: User = {
  randomNumber: Math.random(),
  // ...
};

----------------------------------------

TITLE: Using getSyncStatus Method in Liveblocks Client (TypeScript)
DESCRIPTION: Example of the new client.getSyncStatus() method introduced in version 2.12.0 that allows tracking synchronization status of pending local changes.

LANGUAGE: typescript
CODE:
client.getSyncStatus()

----------------------------------------

TITLE: Installing Live Cursors Example with npx
DESCRIPTION: Command to set up the JavaScript live cursors example locally without API key or Vercel deployment. This downloads the example and installs dependencies automatically.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example javascript-live-cursors --no-api-key --no-vercel

----------------------------------------

TITLE: Installing Supabase Client in Node.js
DESCRIPTION: This command installs the Supabase JavaScript client library for interacting with a Supabase database from a Node.js application.

LANGUAGE: bash
CODE:
npm i @supabase/supabase-js

----------------------------------------

TITLE: Declaring Global Types in Liveblocks Configuration
DESCRIPTION: Example showing how to define global Liveblocks type definitions in a configuration file, demonstrating the improved DX in version 2.0 where types are specified once and shared across all Liveblocks APIs.

LANGUAGE: typescript
CODE:
// ❌ Before
export const {
  suspense: {
    RoomProvider,
    useRoom,
    // etc
  },
} = createRoomContext<Presence, Storage>(client);

// ✅ After
declare global {
  interface Liveblocks {
    Presence: Presence;
    Storage: Storage;
  }
}

----------------------------------------

TITLE: Verifying Webhook Requests with Liveblocks Node
DESCRIPTION: Code to verify webhook requests using the WebhookHandler from @liveblocks/node. This ensures requests are coming from Liveblocks by verifying the signature using your webhook secret key.

LANGUAGE: typescript
CODE:
import { WebhookHandler } from "@liveblocks/node";

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // Use webhook event
  // ...

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Using useUpdateNotificationSettings Hook for Simple Settings Updates in React
DESCRIPTION: Example showing the useUpdateNotificationSettings hook which provides a more focused way to update notification settings without fetching the current state, useful for simple actions like unsubscribe buttons.

LANGUAGE: tsx
CODE:
// A suspense version of this hook is available
import { useUpdateNotificationSettings } from "@liveblocks/react";

const updateSettings = useUpdateNotificationSettings();

const onUnsubscribe = () => {
  updateSettings({
    slack: {
      thread: false,
    },
  });
};

----------------------------------------

TITLE: Demonstrating Old Room API in Liveblocks Client
DESCRIPTION: Shows the deprecated methods for entering, retrieving, and leaving rooms in the Liveblocks client. These methods will continue to work but are no longer recommended.

LANGUAGE: typescript
CODE:
// Old APIs we'll no longer be recommending (but that will remain working)
const room = client.enter("my-room", options);
client.getRoom("my-room");
client.leave("my-room");

----------------------------------------

TITLE: Implementing Zustand Store with Liveblocks Middleware
DESCRIPTION: Example showing how to integrate the Liveblocks middleware with a Zustand store. This demonstrates moving the State type parameter to the middleware level and configuring presence and storage mappings.

LANGUAGE: typescript
CODE:
import create from "zustand";
import { createClient } from "@liveblocks/client";
import { middleware } from "@liveblocks/zustand";

const client = createClient({ /*...*/ });

type State = {
  draft: string;
  isTyping: boolean;
  todos: Todo[];
  setDraft: (draft: string) => void;
  addTodo: () => void;
  deleteTodo: (index: number) => void;
};

create(
  middleware<State>(/* ... */, {
    client,
    presenceMapping: { isTyping: true },
    storageMapping: { todos: true }
  })
);

----------------------------------------

TITLE: UserMeta Type Rules and Examples
DESCRIPTION: A comprehensive example showing valid and invalid type definitions for UserMeta, including rules for id and info fields, and illustrating restrictions for name and avatar properties.

LANGUAGE: tsx
CODE:
declare global {
  interface Liveblocks {
    UserMeta: {
      id: string; // ✅ Valid
      id?: string; // ✅ Valid
      id?: number; // ❌ Invalid, not assignable to string | undefined

      info: {
        name: string; // ✅ Valid
        name?: string; // ✅ Valid
        name: number; // ❌ Invalid, not assignable to string | undefined

        avatar: string; // ✅ Valid
        avatar?: string; // ✅ Valid
        avatar: number; // ❌ Invalid, not assignable to string | undefined

        // Other field names are not special and are free-form
        custom: string; // ✅ Valid
        custom?: string; // ✅ Valid
        custom: number; // ✅ Valid
        custom: Json; // ✅ Valid, can take _any_ valid Json value

        // However, they still need to be valid JSON
        custom: unknown; // ❌ Invalid, not value JSON
      };
    };
  }
}

----------------------------------------

TITLE: Checking if Component is Inside a Room with useIsInsideRoom in Liveblocks
DESCRIPTION: Using the useIsInsideRoom hook to determine if the current component is being rendered inside a RoomProvider context. Useful for conditional rendering based on whether Liveblocks collaboration is available.

LANGUAGE: ts
CODE:
import { useIsInsideRoom } from "@liveblocks/react/suspense";

const isInsideRoom = useIsInsideRoom();

----------------------------------------

TITLE: Setting Up localtunnel for Local Webhook Testing
DESCRIPTION: Command to create a temporary public URL that tunnels to your local development server, allowing Liveblocks webhooks to reach your localhost endpoint during development.

LANGUAGE: bash
CODE:
npx localtunnel --port 3000

----------------------------------------

TITLE: Setting User ID During Authentication with Liveblocks
DESCRIPTION: This snippet demonstrates how to set a user's ID when authenticating your application using liveblocks.prepareSession. The ID (in this case an email address) will be used in Comments to represent the current user.

LANGUAGE: typescript
CODE:
const session = liveblocks.prepareSession("charlie.layne@example.com", {
  userInfo: {
    // Custom user info to be used in Presence
    // This is NOT used in Comments
    // ...
  },
});

----------------------------------------

TITLE: Using Yjs APIs to access ProseMirror state on the server
DESCRIPTION: This code demonstrates an alternative approach to accessing ProseMirror state on the server using Yjs APIs directly. It fetches the Yjs document as a binary update, creates a Y.Doc instance, applies the update, and converts it to ProseMirror JSON format.

LANGUAGE: typescript
CODE:
import * as Y from "yjs";
import { Liveblocks } from "@liveblocks/node";
import { yDocToProsemirrorJSON } from "y-prosemirror";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export async function POST() {
  // Get your Yjs data as a binary update
  const update = await liveblocks.getYjsDocumentAsBinaryUpdate("my-room-name");

  // Create a Yjs document
  const yDoc = new Y.Doc();

  // Apply the binary update to `yDoc`
  Y.applyUpdate(yDoc, new Uint8Array(update));

  // Get ProseMirror state from the default Yjs property it uses, "prosemirror"
  const prosemirrorState = yDocToProsemirrorJSON(yDoc, "prosemirror");

  // { type: "doc", content: [{ type: "paragraph", content: [...] }] }
  console.log(prosemirrorState);
}

----------------------------------------

TITLE: Using LiveblocksProvider Instead of createClient
DESCRIPTION: Demonstrates the transition from using createClient to the new component-based LiveblocksProvider approach in Liveblocks v2.0.

LANGUAGE: typescript
CODE:
// ❌ Before
const client = createClient(/* options */);

// ✅ After
<LiveblocksProvider /* options */>
  <App />
</LiveblocksProvider>

----------------------------------------

TITLE: Retrieving Yjs Document Data from Liveblocks REST API
DESCRIPTION: This code sets up a webhook handler to verify incoming webhook requests and fetches Yjs document data from the Liveblocks REST API when a 'ydocUpdated' event is received. It uses the Liveblocks Node.js SDK and requires a webhook signing secret and API secret key.

LANGUAGE: typescript
CODE:
import { WebhookHandler } from "@liveblocks/node";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When Yjs document data has been updated
  if (event.type === "ydocUpdated") {
    const { roomId } = event.data;

    // Get Yjs data from Liveblocks REST API
    const url = `https://api.liveblocks.io/v2/rooms/${roomId}/ydoc`;
    const response = await fetch(url, {
      headers: { Authorization: `Bearer ${API_SECRET}` },
    });

    if (!response.ok) {
      return new Response("Problem accessing Liveblocks REST APIs", {
        status: 500,
      });
    }

    // Your JSON Yjs document data as a string
    const yDocData = await response.text();

    // Update database
    // ...
  }

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Creating a Liveblocks Room Component
DESCRIPTION: Defines a Room component that provides the Liveblocks context to its children, connecting them to a specific collaboration room.

LANGUAGE: tsx
CODE:
"use client";

import { ReactNode } from "react";
import {
  LiveblocksProvider,
  RoomProvider,
  ClientSideSuspense,
} from "@liveblocks/react/suspense";

export function Room({ children }: { children: ReactNode }) {
  return (
    <LiveblocksProvider authEndpoint="/api/liveblocks-auth">
      <RoomProvider id="my-room">
        <ClientSideSuspense fallback={<div>Loading…</div>}>
          {children}
        </ClientSideSuspense>
      </RoomProvider>
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Using allowOutsideRoom Option with useRoom Hook
DESCRIPTION: Example of using the allowOutsideRoom option with the useRoom hook to prevent errors when used outside of a room context.

LANGUAGE: javascript
CODE:
// Add optional `useRoom({ allowOutsideRoom: true })` option. When this option is
// set, the hook will return `null` when used outside of a room, whereas the
// default behavior of the hook is be to throw.

----------------------------------------

TITLE: Updating a Yjs Document with Liveblocks REST API in TypeScript
DESCRIPTION: This code demonstrates how to create a Yjs document, make changes to it by inserting text, encode the document state as a binary update, and send it to Liveblocks using sendYjsBinaryUpdate method. This is useful for making server-side updates to collaborative documents.

LANGUAGE: typescript
CODE:
import * as Y from "yjs";
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});
const roomId = "my-room-name";

export async function POST() {
  // Create a Yjs document
  const yDoc = new Y.Doc();

  // Create your data structures and make your update
  // Each editor is different, you probably need to change these two lines
  const yText = yDoc.getText("text");
  yText.insert(0, "Hello world");

  // Encode the document state as an update
  const yUpdate = Y.encodeStateAsUpdate(yDoc);

  // Insert the update
  await liveblocks.sendYjsBinaryUpdate(roomId, yUpdate);
}

----------------------------------------

TITLE: Integrating Zustand with Liveblocks Middleware
DESCRIPTION: Example showing how to enhance a Zustand store with Liveblocks middleware for real-time collaboration. It demonstrates the mapping of state properties to presence and storage features.

LANGUAGE: typescript
CODE:
import create from "zustand";
import { createClient } from "@liveblocks/client";
import { middleware } from "@liveblocks/zustand";

const client = createClient({ /*...*/ });

type State = {
  draft: string;
  isTyping: boolean;
  todos: Todo[];
  setDraft: (draft: string) => void;
  addTodo: () => void;
  deleteTodo: (index: number) => void;
};

create(
  middleware<State>(/* ... */, {
    client,
    presenceMapping: { isTyping: true },
    storageMapping: { todos: true }
  })
);

----------------------------------------

TITLE: Using Pagination with useInboxNotifications Hook
DESCRIPTION: Example showing how to use the pagination features introduced in Liveblocks 2.9 with the useInboxNotifications hook to incrementally load more notifications.

LANGUAGE: tsx
CODE:
const {
  inboxNotifications,
  isLoading,
  error,

  // ✨ New in Liveblocks 2.9
  fetchMore,
  isFetchingMore,
  hasFetchedAll,
  fetchMoreError,
} = useInboxNotifications();

----------------------------------------

TITLE: Initializing Liveblocks Configuration File
DESCRIPTION: Creates a liveblocks.config.ts file which can be used later to define types for your application. Uses the create-liveblocks-app utility.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --init --framework react

----------------------------------------

TITLE: Canceling Attachment Uploads with AbortSignal in TypeScript
DESCRIPTION: Shows how to cancel an attachment upload after a specified timeout using the AbortSignal API. This is useful for preventing long-running uploads from continuing indefinitely.

LANGUAGE: typescript
CODE:
const attachment = room.prepareAttachment(file);

// Cancel the upload after 5 seconds
room.uploadAttachment(attachment, { signal: AbortSignal.timeout(5000) });

----------------------------------------

TITLE: Querying PlanetScale Database to Verify Synchronization
DESCRIPTION: SQL query to check if the Liveblocks Yjs document data was successfully synchronized with the PlanetScale database. This query retrieves all entries from the documents table to verify that data is being properly stored.

LANGUAGE: sql
CODE:
SELECT * FROM documents;

----------------------------------------

TITLE: Editing an Existing Comment with Composer Component
DESCRIPTION: Example showing how to edit an existing comment by providing both threadId and commentId to the Composer component. This configuration lets users modify previously submitted comments.

LANGUAGE: tsx
CODE:
import { Composer } from "@liveblocks/react-ui";

// Edits an existing comment
function Component({ threadId, commentId }) {
  return <Composer threadId={threadId} commentId={commentId} />;
}

----------------------------------------

TITLE: Customizing AI Component Names in Liveblocks TipTap Integration
DESCRIPTION: This snippet shows how to customize the name used by AI components through the ai.name option. The specified name will be used throughout AI components in place of the default 'AI' term.

LANGUAGE: tsx
CODE:
import { useLiveblocksExtension } from "@liveblocks/react-tiptap";
import { useEditor } from "@tiptap/react";

function TextEditor() {
  const liveblocks = useLiveblocksExtension({
    ai: {
      // +++
      // "Ask Liveblocks anything…", "Liveblocks is thinking…", etc
      name: "Liveblocks",
      // +++
    },
  });

  const editor = useEditor({
    extensions: [
      liveblocks,
      // ...
    ],
  });

  // ...
}

----------------------------------------

TITLE: Converting localhost URL to localtunnel URL
DESCRIPTION: Example showing how to replace the localhost domain with the generated localtunnel domain to create a publicly accessible webhook URL for testing.

LANGUAGE: shell
CODE:
# Take your local URL
http://localhost:3000/api/liveblocks-database-sync

# Replace localhost with the generated domain, then copy it
https://my-localtunnel-url.loca.lt/api/liveblocks-database-sync

----------------------------------------

TITLE: Implementing Text Formatting Toolbar for Quill Editor in React
DESCRIPTION: This component creates a basic text formatting toolbar for a Quill editor with bold, italic, and underline buttons. It accepts a getQuill function to retrieve the current Quill editor instance and applies formatting to the selected text.

LANGUAGE: tsx
CODE:
import styles from "./Toolbar.module.css";
import { QuillEditorType } from "@/components/CollaborativeEditor";
import { useCallback } from "react";

type Props = {
  getQuill: () => QuillEditorType | null;
};

type Formats = "bold" | "italic" | "underline";

export function Toolbar({ getQuill }: Props) {
  const formatSelection = useCallback(
    (format: Formats) => {
      const quill = getQuill();
      if (!quill) {
        return;
      }

      const selection = quill.getSelection();
      if (!selection) {
        return;
      }

      const { index, length } = selection;
      const hasFormat = quill.getFormat(index, length)[format];

      quill.formatText(
        index,
        length,
        {
          [format]: !hasFormat,
        },
        "user"
      );
    },
    [getQuill]
  );

  return (
    <div className={styles.toolbar}>
      <button
        className={styles.button}
        onClick={() => formatSelection("bold")}
        aria-label="bold"
      >
        B
      </button>
      <button
        onClick={() => formatSelection("italic")}
        className={styles.button}
        aria-label="italic"
      >
        I
      </button>
      <button
        onClick={() => formatSelection("underline")}
        className={styles.button}
        aria-label="underline"
      >
        U
      </button>
    </div>
  );
}

----------------------------------------

TITLE: Basic Zustand Store Structure Without Liveblocks Middleware
DESCRIPTION: Example of a basic Zustand store setup without Liveblocks integration. This shows the standard pattern for creating a to-do list application store with state types and actions.

LANGUAGE: typescript
CODE:
import create from "zustand";

type State = {
  draft: string;
  isTyping: boolean;
  todos: Todo[];
  setDraft: (draft: string) => void;
  addTodo: () => void;
  deleteTodo: (index: number) => void;
};

create<State>(/* ... */);

----------------------------------------

TITLE: Problematic Content Setting in Tiptap with Yjs
DESCRIPTION: This example shows the incorrect way to set initial content in Tiptap when using Yjs, which will cause content duplication issues because Yjs treats it as an append command rather than a default value.

LANGUAGE: tsx
CODE:
function Editor({ doc, provider }: EditorProps) {
  const editor = useEditor({
    content: "<p>This will duplicate on load</p>",

    // Options
    // ...
  });

  return <EditorContent editor={editor} />;
}

----------------------------------------

TITLE: Using Pagination with useInboxNotifications Hook (TSX)
DESCRIPTION: Example of using the pagination features added to useInboxNotifications in version 2.9.0, allowing incremental loading of notifications as users interact with the app.

LANGUAGE: tsx
CODE:
const {
  inboxNotifications,
  isLoading,
  error,

  // ✨ New in Liveblocks 2.9
  fetchMore,
  isFetchingMore,
  hasFetchedAll,
  fetchMoreError,
} = useInboxNotifications();

----------------------------------------

TITLE: Demonstrating Deprecated Room Entry/Exit API in TypeScript
DESCRIPTION: Shows the old API pattern for entering and leaving rooms that is still supported but no longer recommended. This approach uses separate methods for entering, getting, and leaving rooms.

LANGUAGE: typescript
CODE:
// Old APIs we'll no longer be recommending (but that will remain working)
const room = client.enter("my-room", options);
client.getRoom("my-room");
client.leave("my-room");

----------------------------------------

TITLE: Editing Thread Metadata with useEditThreadMetadata in Liveblocks
DESCRIPTION: Demonstrates how to use useEditThreadMetadata hook to edit a thread's metadata. Set a property value to null to delete it.

LANGUAGE: tsx
CODE:
import { useEditThreadMetadata } from "@liveblocks/react/suspense";

const editThreadMetadata = useEditThreadMetadata();
editThreadMetadata({ threadId: "th_xxx", metadata: {} });

----------------------------------------

TITLE: Initializing Liveblocks Configuration File
DESCRIPTION: Command to initialize the liveblocks.config.ts file which can be used later to define types for the application.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --init --framework react

----------------------------------------

TITLE: Implementing Liveblocks in a Vanilla Astro Component
DESCRIPTION: This snippet shows how to set up real-time functionality with Liveblocks in a vanilla .astro component. It subscribes to a LiveObject to sync an input field's value across clients, and attaches an event listener to update the LiveObject when the input changes.

LANGUAGE: html
CODE:
<script>
  import { room, myLiveObject } from "../liveblocksSetup.js";

  const input = document.querySelector("#vanilla");

  room.subscribe(myLiveObject, (updatedLiveObject) => {
    input.value = updatedLiveObject.get("text");
  });

  room.addEventListener("input", (e) => {
    myLiveObject.set("text", e.target.value);
  });
</script>

<input id="vanilla" type="text" onClick="this.select()" />

----------------------------------------

TITLE: Rendering a Thread Component in React with Liveblocks
DESCRIPTION: Basic usage of the Thread component to display a single thread of comments. This component displays a thread with its comments and provides a composer for creating replies.

LANGUAGE: tsx
CODE:
<Thread thread={thread} />

----------------------------------------

TITLE: Running react-comments-to-react-ui Codemod in Shell
DESCRIPTION: Executes the codemod that updates @liveblocks/react-comments to @liveblocks/react-ui and renames <CommentsConfig /> to <LiveblocksUIConfig />.

LANGUAGE: shell
CODE:
npx @liveblocks/codemod@latest react-comments-to-react-ui

----------------------------------------

TITLE: Defining Instead of Importing Presence Types in Liveblocks
DESCRIPTION: Demonstrates the new pattern for working with Presence types. Instead of importing a generic Presence type from the library, you should define your own type that matches your application's needs.

LANGUAGE: tsx
CODE:
// ❌ No longer need to _import_ Presence
import type { Presence } from "@liveblocks/client";

client.enter<Presence>("myRoom");

LANGUAGE: tsx
CODE:
// ✅ Just define the shape your app needs
type Presence = {
  cursor: { x: number; y: number } | null;
};

client.enter<Presence>("myRoom");

----------------------------------------

TITLE: Fetching Thread Notification Data for Emails
DESCRIPTION: This code demonstrates how to use @liveblocks/emails to fetch unread comments data for email notifications. It sets up the Liveblocks client with a secret key and handles cases where the data might not be available.

LANGUAGE: typescript
CODE:
import {
  // +++
  Liveblocks,
  // +++
  WebhookHandler,
  isThreadNotificationEvent,
} from "@liveblocks/node";
// +++
import { prepareThreadNotificationEmailAsReact } from "@liveblocks/emails";
// +++

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// +++
// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";
const liveblocks = new Liveblocks({ secret: API_SECRET });
// +++

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When an inbox notification has been created on the email channel
  if (isThreadNotificationEvent(event) && event.data.channel === "email") {
    // Check if user has access to room
    if (!__hasRoomAccess__(event.userId, event.roomId)) {
      return new Response(null, { status: 200 });
    }

    // The user to send the email to
    const emailAddress = __getEmailAddressFromDB__(event.userId);

    // +++
    let emailData;

    try {
      emailData = await prepareThreadNotificationEmailAsReact(
        liveblocks,
        event
      );
    } catch (err) {
      console.log(err);
      return new Response("Could not fetch thread notification data", {
        status: 500,
      });
    }

    // All comments have already been read
    if (!emailData) {
      return new Response(null, { status: 200 });
    }

    // Create emails
    // ...
    // +++
  }

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Styling Live Cursors in CSS
DESCRIPTION: CSS styles for the collaborative cursors, providing visual cues for remote users' carets and labels. Includes styling for the cursor itself and the username label that appears above it.

LANGUAGE: css
CODE:
/* Give a remote user a caret */
.collaboration-cursor__caret {
  border-left: 1px solid #0d0d0d;
  border-right: 1px solid #0d0d0d;
  margin-left: -1px;
  margin-right: -1px;
  pointer-events: none;
  position: relative;
  word-break: normal;
}

/* Render the username above the caret */
.collaboration-cursor__label {
  font-style: normal;
  font-weight: 600;
  left: -1px;
  line-height: normal;
  position: absolute;
  user-select: none;
  white-space: nowrap;
  font-size: 14px;
  color: #fff;
  top: -1.4em;
  border-radius: 6px;
  border-bottom-left-radius: 0;
  padding: 2px 6px;
  pointer-events: none;
}

----------------------------------------

TITLE: Managing User Notification Settings with @liveblocks/node
DESCRIPTION: Demonstrates how to use the Liveblocks Node.js client to get, update, and delete user notification settings. The code initializes a Liveblocks client with a secret key and shows the three main methods for notification settings management.

LANGUAGE: tsx
CODE:
import { Liveblocks } from "@liveblocks/node";
const liveblocks = new Liveblocks({ secret: "sk_xxx" });

const settings = await liveblocks.getNotificationSettings({ userId });
// { email: { thread: true, ... }, slack: { thread: false, ... }, ... }
console.log(settings);

const updatedSettings = await liveblocks.updateNotificationSettings({
  userId,
  data: {
    teams: {
      $fileUploaded: true,
    },
  },
});
await liveblocks.deleteNotificationSettings({ userId });

----------------------------------------

TITLE: Integrating Liveblocks Webhooks with Supabase for Yjs Document Synchronization
DESCRIPTION: This TypeScript implementation demonstrates a complete webhook handler that verifies Liveblocks webhook requests, retrieves Yjs document data, and stores it in a Supabase database. It requires configuration with your Liveblocks webhook signing secret, API secret key, and Supabase project credentials.

LANGUAGE: typescript
CODE:
import { WebhookHandler } from "@liveblocks/node";
import { createClient } from "@supabase/supabase-js";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";

// Create a Supabase client
const supabase = createClient(
  "YOUR_SUPABASE_PROJECT_URL",
  "YOUR_SUPABASE_PUBLIC_ANON_KEY"
);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When Yjs document data has been updated
  if (event.type === "ydocUpdated") {
    const { roomId } = event.data;

    // Get Yjs data from Liveblocks REST API
    const url = `https://api.liveblocks.io/v2/rooms/${roomId}/ydoc`;
    const response = await fetch(url, {
      headers: { Authorization: `Bearer ${API_SECRET}` },
    });

    if (!response.ok) {
      return new Response("Problem accessing Liveblocks REST APIs", {
        status: 500,
      });
    }

    // Your JSON Yjs document data as a string
    const yDocData = await response.text();

    // Update database
    const { data, error } = await supabase
      .from("documents")
      .insert({ roomid: roomId, ydocdata: yDocData })
      .select();

    if (error) {
      return new Response("Problem inserting data into database", {
        status: 500,
      });
    }
  }

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Visualizing the Liveblocks Schema Language Build Process with Mermaid
DESCRIPTION: A flowchart diagram showing the build process for the Liveblocks schema language. It illustrates how grammar files generate TypeScript code and the relationships between different components like the parser, checker, prettifier, and planned components. The diagram shows npm build commands that generate code from grammar files.

LANGUAGE: mermaid
CODE:
flowchart LR
  subgraph npm run build
    build:ast
    build:parser
  end

  ast/ast.grammar --> build:ast[npm run build:ast] ==>|generates| ast/index.ts
  parser/schema.pegjs --> build:parser[npm run build:parser] ==>|generates| parser/generated-parser.ts

  parser/generated-parser.ts -.-> parser
  ast/index.ts -.-> parser
  ast/index.ts -.-> checker
  ast/index.ts -.-> prettifier
  ast/index.ts -.-> typescript-generator
  ast/index.ts -.-> infer-schema

  subgraph TODO
    typescript-generator
    infer-schema
  end

----------------------------------------

TITLE: RoomContext Creation in Liveblocks v1
DESCRIPTION: Shows the previous method for creating a room context with type parameters in Liveblocks v1, which has been simplified in v2 with global type declarations.

LANGUAGE: typescript
CODE:
// ❌ Before
export const {
  suspense: {
    RoomProvider,
    useRoom,
    // etc
  },
} = createRoomContext<Presence, Storage>(client);

----------------------------------------

TITLE: Setting Up Collaborative Lexical Text Editor with Liveblocks
DESCRIPTION: Configures a collaborative Lexical text editor using LiveblocksPlugin and FloatingToolbar from @liveblocks/react-lexical. This component sets up the rich text editor with collaborative features.

LANGUAGE: tsx
CODE:
"use client";

import { LexicalComposer } from "@lexical/react/LexicalComposer";
import { RichTextPlugin } from "@lexical/react/LexicalRichTextPlugin";
import { ContentEditable } from "@lexical/react/LexicalContentEditable";
import { LexicalErrorBoundary } from "@lexical/react/LexicalErrorBoundary";
import {
  liveblocksConfig,
  LiveblocksPlugin,
  FloatingToolbar,
} from "@liveblocks/react-lexical";
import { Threads } from "./Threads";

export function Editor() {
  // Wrap your Lexical config with `liveblocksConfig`
  const initialConfig = liveblocksConfig({
    namespace: "Demo",
    onError: (error: unknown) => {
      console.error(error);
      throw error;
    },
  });

  return (
    <LexicalComposer initialConfig={initialConfig}>
      <div className="editor">
        <RichTextPlugin
          contentEditable={<ContentEditable />}
          placeholder={<div className="placeholder">Start typing here…</div>}
          ErrorBoundary={LexicalErrorBoundary}
        />
        <LiveblocksPlugin>
          <Threads />
          <FloatingToolbar />
        </LiveblocksPlugin>
      </div>
    </LexicalComposer>
  );
}

----------------------------------------

TITLE: Using the Room Component in Next.js Page
DESCRIPTION: Demonstrates how to incorporate the Room component in a Next.js page component to enable Liveblocks functionality.

LANGUAGE: tsx
CODE:
import { Room } from "./Room";

export default function Page() {
  return <Room>{/* Your Liveblocks app */}</Room>;
}

----------------------------------------

TITLE: Using useIsEditorReady Hook in TipTap Editor
DESCRIPTION: This snippet demonstrates the basic usage of the useIsEditorReady hook, which allows checking if the editor content has been loaded. This is useful for implementing loading states and skeletons.

LANGUAGE: ts
CODE:
import { useIsEditorReady } from "@liveblocks/react-tiptap";

const status = useIsEditorReady();

----------------------------------------

TITLE: Using Pagination with useInboxNotifications Hook
DESCRIPTION: Example showing how to use the pagination features of the useInboxNotifications hook introduced in Liveblocks 2.9.0. This includes fetchMore, isFetchingMore, hasFetchedAll, and fetchMoreError properties.

LANGUAGE: tsx
CODE:
const {
  inboxNotifications,
  isLoading,
  error,

  // ✨ New in Liveblocks 2.9
  fetchMore,
  isFetchingMore,
  hasFetchedAll,
  fetchMoreError,
} = useInboxNotifications();

----------------------------------------

TITLE: Simplifying Type Annotations in Liveblocks Client
DESCRIPTION: Shows how to improve type annotations in client code. Instead of annotating each method separately, you can annotate once at the top level when entering a room, and the types will flow through to other methods.

LANGUAGE: tsx
CODE:
import { createClient } from "@liveblocks/client";
import { Author } from "./types";

const client = createClient({
  /* client options */
});

type Presence = {
  cursor: { x: number; y: number } | null;
};

type Storage = {
  author: LiveObject<Author>;
};

// ❌ In 0.16, you had to annotate each method separately
const room = client.enter("myRoom");
const { root } = await room.getStorage<Storage>();
const author = root.get<Author>("author");
const me = room.getPresence<Presence>();
const others = room.getOthers<Presence>();

// ✅ In 0.17, you can simply annotate it once, at the "top"
const room = client.enter<Presence, Storage>("myRoom");
const { root } = await room.getStorage();
const author = root.get("author");
const me = room.getPresence();
const others = room.getOthers();

----------------------------------------

TITLE: Fetching a Yjs Subdocument on the Server
DESCRIPTION: Explains how to fetch a Yjs subdocument on the server using Liveblocks Node.js SDK. This retrieves the document as a binary update that can be applied to a local Yjs document for reading.

LANGUAGE: ts
CODE:
import { Liveblocks } from "@liveblocks/node";
import * as Y from "yjs";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export function POST() {
  // Get your Yjs subdocument as a binary update
  const update = liveblocks.getYjsDocumentAsBinaryUpdate("my-room-id", {
    // The `guid` of your subdocument, as noted earlier
    guid: "c4a755...",
  });

  // Create a Yjs document for your subdoc and apply the update
  const subdoc = new Y.Doc();
  Y.applyUpdate(subdoc, new Uint8Array(update));

  // `subdoc` can now be read
  // ...
}

----------------------------------------

TITLE: Initializing Liveblocks Storage with LiveList for To-Do Items in JavaScript
DESCRIPTION: Code that initializes Liveblocks client, configures a room with initial storage using LiveList for todos, and implements adding new to-do items when the user presses Enter.

LANGUAGE: jsx
CODE:
import { createClient, LiveList } from "@liveblocks/client";

const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

async function run() {
  const { room, leave } = client.enterRoom("javascript-todo-app", {
    initialPresence: { isTyping: false },
    initialStorage: { todos: new LiveList() },
  });

  const whoIsHere = document.getElementById("who_is_here");
  const todoInput = document.getElementById("todo_input");
  const someoneIsTyping = document.getElementById("someone_is_typing");

  const { root } = await room.getStorage();

  let todos = root.get("todos");

  room.subscribe("others", (others) => {
    /* ... */
  });

  todoInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      room.updatePresence({ isTyping: false });
      todos.push({ text: todoInput.value });
      todoInput.value = "";
    } else {
      room.updatePresence({ isTyping: true });
    }
  });

  todoInput.addEventListener("blur", () => {
    room.updatePresence({ isTyping: false });
  });
}

run();

----------------------------------------

TITLE: Setting Environment Variables for Liveblocks E2E Tests
DESCRIPTION: Instructions for setting up the necessary environment variable to run end-to-end tests for the Liveblocks core package locally.

LANGUAGE: bash
CODE:
LIVEBLOCKS_PUBLIC_KEY="pk_YOUR_PUBLIC_API_KEY"

----------------------------------------

TITLE: Displaying Example Cards in JSX
DESCRIPTION: This JSX code renders a grid of example cards showcasing Liveblocks features like Live Cursors and Collaborative Whiteboard, along with supported technologies.

LANGUAGE: jsx
CODE:
<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Live Cursors",
      slug: "live-cursors",
      image: "/images/examples/thumbnails/live-cursors.jpg",
    }}
    technologies={["nextjs", "vuejs", "sveltekit", "solidjs", "javascript"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Collaborative Whiteboard",
      slug: "collaborative-whiteboard-advanced",
      image:
        "/images/examples/thumbnails/collaborative-whiteboard-advanced.jpg",
      advanced: true,
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
</ListGrid>

----------------------------------------

TITLE: Fetching Thread Data from Notifications with useInboxNotificationThread Hook
DESCRIPTION: This snippet demonstrates how to use the useInboxNotificationThread hook to retrieve thread data from an inbox notification.

LANGUAGE: tsx
CODE:
function Notification({ inboxNotification }) {
  const thread = useInboxNotificationThread(inboxNotification.id);

  // { type: "thread", id: "th_sf8s6sh...", ... }
  console.log(thread);

  // ...
}

----------------------------------------

TITLE: Subscribing to Current User's Presence in Liveblocks
DESCRIPTION: Shows how to subscribe to the current user's presence to receive updates when it changes through Room.updatePresence.

LANGUAGE: typescript
CODE:
const unsubscribe = room.subscribe("my-presence", (presence) => {
  // Do something
});

----------------------------------------

TITLE: Installing Liveblocks with npm
DESCRIPTION: Installs the required Liveblocks packages for Redux integration. Both client and Redux packages should use the same version.

LANGUAGE: bash
CODE:
npm install @liveblocks/client @liveblocks/redux

----------------------------------------

TITLE: Updating Storage with Undo Capability in Liveblocks React
DESCRIPTION: This example shows how to use useMutation to update a value in Liveblocks storage and implement an undo button. The component allows updating a scientist's first name and provides undo functionality to revert the change.

LANGUAGE: TSX
CODE:
import { useState } from "react";
import { useMutation, useUndo } from "@liveblocks/react/suspense";

function YourComponent() {
  const [text, setText] = useState("");
  const undo = useUndo();

  const updateName = useMutation(({ storage }, newName) => {
    storage.get("scientist").set("firstName", newName);
  });

  return (
    <>
      <input
        type="text"
        value={text}
        onChange={(e) => setText(e.target.value)}
      />
      <button onClick={() => updateName(text)}>Update Name</button>
      <button onClick={() => undo()}></button>
    </>
  );
}

----------------------------------------

TITLE: Structuring TipTap Editor with Offline Support and Threads
DESCRIPTION: This example demonstrates how to properly structure a TipTap editor with offline support, ensuring components like threads don't trigger loading screens. The threads component is separated and wrapped in ClientSideSuspense.

LANGUAGE: tsx
CODE:
"use client";

import { ClientSideSuspense, useThreads } from "@liveblocks/react/suspense";
import {
  useLiveblocksExtension,
  AnchoredThreads,
  FloatingComposer,
} from "@liveblocks/react-tiptap";
import { Editor, EditorContent, useEditor } from "@tiptap/react";

export function TiptapEditor() {
  const liveblocks = useLiveblocksExtension({
    offlineSupport_experimental: true,
  });

  const editor = useEditor({
    extensions: [
      liveblocks,
      // ...
    ],
    immediatelyRender: false,
  });

  return (
    <>
      <EditorContent editor={editor} />
      <FloatingComposer editor={editor} style={{ width: 350 }} />
      // +++
      <ClientSideSuspense fallback={null}>
        <Threads editor={editor} />
      </ClientSideSuspense>
      // +++
    </>
  );
}

// +++
function Threads({ editor }: { editor: Editor }) {
  const { threads } = useThreads();

  return <AnchoredThreads editor={editor} threads={threads} />;
}
// +++

----------------------------------------

TITLE: Customizing Email Comment Components in Liveblocks
DESCRIPTION: This code shows how to customize the appearance of comment components in email notifications using the components option. It demonstrates styling paragraphs, mentions, and links with custom React components while using the resolved user data.

LANGUAGE: tsx
CODE:
// ...

emailData = await prepareThreadNotificationEmailAsReact(liveblocks, event, {
  resolveUsers: async ({ userIds }) => {
    const usersData = await __getUsersFromDB__(userIds);

    return usersData.map((userData) => ({
      name: userData.name, // "Steven"
      avatar: userData.avatar.src, // "https://example.com/steven.jpg"
    }));
  },
  resolveRoomInfo: async ({ roomId }) => {
    const roomData = await __getRoomFromDB__(roomId);

    return {
      name: roomData.name, // "Untitled document"
      url: roomData.url, //`https://example.com/my-room-id`
    };
  },
  // +++
  components: {
    Paragraph: ({ children }) => <p style={{ margin: "12px 0" }}>{children}</p>,

    // `user` is the optional data returned from `resolveUsers`
    Mention: ({ element, user }) => (
      <span style={{ color: "red" }}>@{user?.name ?? element.id}</span>
    ),

    // If the link is rich-text render it, otherwise use the URL
    Link: ({ element, href }) => (
      <a href={href} style={{ textDecoration: "underline" }}>
        {element?.text ?? href}
      </a>
    ),
  },
  // +++
});

// ...

----------------------------------------

TITLE: Old Pattern: Optional Chaining with User Properties
DESCRIPTION: Example of code using optional chaining with user properties that can now be simplified as these fields are guaranteed to be present in version 0.18.

LANGUAGE: tsx
CODE:
user.info?.avatar;
//       ^
user.presence?.cursor.x;
//           ^

----------------------------------------

TITLE: Converting Local URL to ngrok URL
DESCRIPTION: Example showing how to replace the localhost domain with the ngrok-generated URL to create a publicly accessible webhook endpoint.

LANGUAGE: shell
CODE:
# Take your local URL
http://localhost:3000/api/liveblocks-webhook

# Replace localhost with the generated domain, then copy it
https://my-localtunnel-url.loca.lt/api/liveblocks-webhook

----------------------------------------

TITLE: Adding Typing Indicator Element to HTML
DESCRIPTION: Adds a div element with ID 'someone_is_typing' to the HTML structure. This element will display a message when other users are typing, providing real-time feedback on collaborative activity.

LANGUAGE: html
CODE:
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Liveblocks - Todo list</title>
    <link rel="stylesheet" href="index.css" />
  </head>
  <body>
    <div class="container">
      <div id="who_is_here" class="who_is_here"></div>
      <input id="todo_input" type="text" placeholder="What needs to be done?" />
      <div id="someone_is_typing" class="someone_is_typing"></div>
    </div>
    <script src="app.js"></script>
  </body>
</html>

----------------------------------------

TITLE: Implementing Liveblocks in Next.js Root Layout
DESCRIPTION: Integrates the Providers component into the Next.js root layout file to make Liveblocks available throughout the application.

LANGUAGE: tsx
CODE:
import { ReactNode } from "react";
import { Providers } from "./Providers";

export default function Layout({ children }: { children: ReactNode }) {
  return (
    <html lang="en">
      <body>
        <Providers>{children}</Providers>
      </body>
    </html>
  );
}

----------------------------------------

TITLE: Identifying a User Without Group Access in Liveblocks
DESCRIPTION: This snippet shows how to identify a user without assigning them to any groups, just providing a userId for authentication.

LANGUAGE: javascript
CODE:
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export async function POST(request: Request) {
  const { status, body } = await liveblocks.identifyUser({
    userId: "ellen@acme.inc"
  });

  return new Response(body, { status });
}

----------------------------------------

TITLE: Defining ThreadMetadataUpdatedEvent Schema and Example in TypeScript
DESCRIPTION: TypeScript definition for ThreadMetadataUpdatedEvent which is triggered when thread metadata is updated. This event is not throttled and includes information about who updated the thread and when.

LANGUAGE: typescript
CODE:
// Schema
type ThreadMetadataUpdatedEvent = {
  type: "threadMetadataUpdated";
  data: {
    projectId: string;
    roomId: string;
    threadId: string;
    updatedAt: string;
    updatedBy: string;
  };
};

// Example
const threadMetadataUpdatedEvent = {
  type: "threadMetadataUpdated",
  data: {
    projectId: "my-project-id",
    roomId: "my-room-id",
    threadId: "my-thread-id",
    updatedAt: "2021-10-06T01:45:56.558Z",
    updatedBy: "my-user-id",
  },
};

----------------------------------------

TITLE: Installing Liveblocks Client Package
DESCRIPTION: Command to install the Liveblocks client package via npm, which is required for implementing realtime collaboration features in a Svelte application.

LANGUAGE: bash
CODE:
npm install @liveblocks/client

----------------------------------------

TITLE: Using room.reconnect in a React Component
DESCRIPTION: Shows how to implement a reauthentication button in a React component using the useRoom hook from Liveblocks. This allows reconnecting to the room without refreshing the page while preserving client state.

LANGUAGE: tsx
CODE:
import { useRoom } from "../liveblocks.config";

export function App() {
  const room = useRoom();

  return <button onClick={room.reconnect}>Reauthenticate</button>;
}

----------------------------------------

TITLE: Basic AiToolbar Implementation with Tiptap Editor
DESCRIPTION: Shows how to implement the AiToolbar component that displays a floating AI toolbar near the current Tiptap selection for AI-powered text editing features.

LANGUAGE: tsx
CODE:
<AiToolbar editor={editor} />

----------------------------------------

TITLE: Deploying Collaborative Text Editor to Vercel
DESCRIPTION: Command to deploy the collaborative text editor example to Vercel using the Liveblocks CLI tool. This downloads the example and guides you through the Vercel deployment process.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-yjs-tiptap --vercel

----------------------------------------

TITLE: Migrating Redux Leave Room Action in Liveblocks 1.5
DESCRIPTION: The breaking change for Redux users when leaving a room. The new API no longer requires passing the room ID to the leaveRoom action.

LANGUAGE: tsx
CODE:
const dispatch = useDispatch();

// ❌ Before
dispatch(actions.leaveRoom("my-room-name"));

// ✅ After
dispatch(actions.leaveRoom());

----------------------------------------

TITLE: Defining Presence Types in TypeScript for Liveblocks
DESCRIPTION: This snippet shows how to define TypeScript types for user presence in Liveblocks. It declares a global interface for Liveblocks Presence that includes cursor position coordinates or null when the cursor is off-screen.

LANGUAGE: tsx
CODE:
declare global {
  interface Liveblocks {
    Presence: {
      cursor: { x: number; y: number } | null;
    };
  }
}

----------------------------------------

TITLE: Adding Persistent To-Do List Storage with Liveblocks
DESCRIPTION: Extends the Redux store to include to-do list items that are persisted using Liveblocks Storage. Adds reducers for adding and deleting todo items and configures the storageMapping to sync todos with Liveblocks Storage.

LANGUAGE: javascript
CODE:
import { createClient } from "@liveblocks/client";
import { liveblocksEnhancer } from "@liveblocks/redux";
import { configureStore, createSlice } from "@reduxjs/toolkit";

const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

const initialState = {
  todos: [],
  draft: "",
  isTyping: false,
};

const slice = createSlice({
  name: "state",
  initialState,
  reducers: {
    setDraft: (state, action) => {
      state.isTyping = action.payload === "" ? false : true;
      state.draft = action.payload;
    },
    addTodo: (state) => {
      state.isTyping = false;
      state.todos.push({ text: state.draft });
      state.draft = "";
    },
    deleteTodo: (state, action) => {
      state.todos.splice(action.payload, 1);
    },
  },
});

export const { setDraft, addTodo, deleteTodo } = slice.actions;

export function makeStore() {
  return configureStore({
    reducer: slice.reducer,
    enhancers: [
      liveblocksEnhancer({
        client,
        storageMapping: { todos: true },
        presenceMapping: { isTyping: true },
      }),
    ],
  });
}

const store = makeStore();

export default store;

----------------------------------------

TITLE: Pausing and Resuming History in Liveblocks
DESCRIPTION: This snippet demonstrates how to access the pause and resume functions for the Liveblocks history, which allows skipping intermediate states in the undo/redo history.

LANGUAGE: tsx
CODE:
import useStore from "../store";

const pause = useStore((state) => state.liveblocks.room?.history.pause);
const resume = useStore((state) => state.liveblocks.room?.history.resume);

----------------------------------------

TITLE: Setting up Authentication Endpoint in Nuxt.js
DESCRIPTION: Creates a server endpoint that handles user authentication for Liveblocks. This code identifies users and can include additional metadata about them.

LANGUAGE: typescript
CODE:
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export default defineEventHandler(async (event) => {
  // Get the current user from your database
  const user = __getUserFromDB__(event);

  // Identify the user and return the result
  const { status, body } = await liveblocks.identifyUser(
    {
      userId: user.id,
      groupIds, // Optional
    },
    { userInfo: user.metadata },
  );
  return body;
})

----------------------------------------

TITLE: RoomCreatedEvent Schema in TypeScript
DESCRIPTION: TypeScript schema and example for the RoomCreatedEvent webhook. This event is triggered when a new room is created, either through the API or when a user connects to a non-existent room.

LANGUAGE: typescript
CODE:
// Schema
type RoomCreatedEvent = {
  type: "roomCreated";
  data: {
    projectId: string;
    roomId: string;
    createdAt: string;
  };
};

// Example
const roomCreatedEvent = {
  type: "roomCreated",
  data: {
    projectId: "my-project-id",
    roomId: "my-room-id",
    createdAt: "2021-10-06T01:45:56.558Z",
  },
};

----------------------------------------

TITLE: Comparing Old and New Liveblocks Room APIs in TypeScript
DESCRIPTION: Demonstrates the transition from the deprecated room management API to the new recommended API in Liveblocks. The new API returns both the room and a leave function, supporting entering/leaving the same room multiple times.

LANGUAGE: typescript
CODE:
// Old APIs we'll no longer be recommending (but that will remain working)
const room = client.enter("my-room", options);
client.getRoom("my-room");
client.leave("my-room");

----------------------------------------

TITLE: Setting Up Liveblocks Client in Vue.js
DESCRIPTION: Code to create a Liveblocks client instance that will communicate with the backend, using a public API key for authentication.

LANGUAGE: typescript
CODE:
const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

----------------------------------------

TITLE: Handling Notification Webhooks with TypeScript
DESCRIPTION: A TypeScript webhook handler for Liveblocks notifications that verifies the webhook request and processes notification events. This basic implementation logs the event details but requires additional logic to handle specific notification kinds.

LANGUAGE: typescript
CODE:
import { WebhookHandler } from "@liveblocks/node";

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  if (event.type !== "notification") {
    return new Response("This is not a notification webhook", { status: 400 });
  }

  // {
  //   type: "notification",
  //   data: {
  // +++
  //     channel: "email",
  //     kind: "$myCustomNotification",
  // +++
  //     projectId: "my-project-id",
  //     roomId: "my-room-id",
  //     userId: "my-user-id",
  //     inboxNotificationId: "in_xt3p7ak...",
  //     createdAt: "2021-10-06T01:45:56.558Z",
  //   },
  // }
  console.log(event);

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Creating Fully Custom Thread Components with Comment Primitives
DESCRIPTION: Demonstrates how to build completely custom Thread components using Comment primitives from Liveblocks. This allows for full control over thread rendering.

LANGUAGE: tsx
CODE:
import { Comment } from "@liveblocks/react-ui/primitives";

<AnchoredThreads
  editor={editor}
  threads={threads}
  style={{ width: "350px" }}
  className="my-anchored-thread"
  components={{
    Thread: (props) => (
      // +++
      <div>
        {props.thread.comments.map((comment) => (
          <Comment.Body
            key={comment.id}
            body={comment.body}
            components={/* ... */}
          />
        ))}
      </div>
      // +++
    ),
  }}
/>;

----------------------------------------

TITLE: Updating LiveList Constructor Usage
DESCRIPTION: Shows how to update LiveList constructor calls to include an empty array parameter, as the parameter is no longer optional.

LANGUAGE: tsx
CODE:
// ❌ Before
const mylist = new LiveList();

// ✅ After
const mylist = new LiveList([]);

----------------------------------------

TITLE: Subscribing to Room User Presence in Vue.js
DESCRIPTION: Vue.js component that subscribes to the 'others' event to track other users in the room. It initializes a ref with current users, sets up a subscription, and properly cleans up on unmount.

LANGUAGE: javascript
CODE:
<script setup>
  import { onUnmounted, ref } from "vue";
  import { room } from "./room.js";

  const others = ref(room.getOthers());

  const unsubscribeOthers = room.subscribe("others", (updatedOthers) => {
    others.current = updatedOthers;
  });

  onUnmounted(() => {
    unsubscribeOthers();
  });
</script>

<template>
  <div>There are {{ others.length }} other user(s) online</div>
</template>

----------------------------------------

TITLE: Adding Redux Provider to React entry point
DESCRIPTION: Updates the main React index.js file to wrap the application with Redux Provider, making the store available throughout the component tree.

LANGUAGE: javascript
CODE:
import React from "react";
import ReactDOM from "react-dom";
import "./index.css";
import App from "./App";

import { Provider } from "react-redux";
import store from "./store";

ReactDOM.render(
  <React.StrictMode>
    <Provider store={store}>
      <App />
    </Provider>
  </React.StrictMode>,
  document.getElementById("root")
);

----------------------------------------

TITLE: Configuring Liveblocks Client with Firebase Authentication
DESCRIPTION: Sets up the client-side implementation by creating a Liveblocks client that uses the Firebase callable function for authentication. This replaces the publicApiKey option with authEndpoint that points to the Firebase function.

LANGUAGE: javascript
CODE:
import { createClient } from "@liveblocks/client";
import firebase from "firebase";
import "firebase/functions";

firebase.initializeApp({
  /* Firebase config */
});

const auth = firebase.functions().httpsCallable("liveblocks-auth");

// Create a Liveblocks client
const client = createClient({
  authEndpoint: async (room) => (await auth({ room })).data,
});

----------------------------------------

TITLE: Verifying Webhook Request with WebhookHandler
DESCRIPTION: Demonstrates how to verify an incoming webhook request using the WebhookHandler.verifyRequest method, which validates the request's authenticity.

LANGUAGE: typescript
CODE:
const event = webhookHandler.verifyRequest({
  headers: req.headers,
  rawBody: req.body,
});

----------------------------------------

TITLE: Initializing Liveblocks Configuration File
DESCRIPTION: Creates a liveblocks.config.ts file that can be used later to define types for the application.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --init --framework javascript

----------------------------------------

TITLE: Deploying the Collaborative Text Editor Example to Vercel
DESCRIPTION: Command to download the example and deploy it to Vercel. This sets up both local development and deployment configuration in one step.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-yjs-slate --vercel

----------------------------------------

TITLE: Mixing Default and Custom Toolbar Components in React-TipTap
DESCRIPTION: Demonstrates how to create a custom toolbar by combining default Liveblocks toolbar sections with custom buttons. This example adds the SectionHistory component alongside custom buttons for help and highlighting text.

LANGUAGE: tsx
CODE:
import { FloatingToolbar, Toolbar } from "@liveblocks/react-tiptap";
import { Icon } from "@liveblocks/react-ui";
import { Editor } from "@tiptap/react";

function CustomToolbar({ editor }: { editor: Editor | null }) {
  return (
    <FloatingToolbar editor={editor}>
      // +++
      <Toolbar.SectionHistory />
      <Toolbar.Separator />
      <Toolbar.Button
        name="Help"
        icon={<Icon.QuestionMark />}
        shortcut="CMD-H"
        onClick={() => console.log("help")}
      />
      <Toolbar.Toggle
        name="Highlight"
        icon={<div>🖊️</div>}
        active={editor?.isActive("highlight") ?? false}
        onClick={() => editor?.chain().focus().toggleHighlight().run()}
        disabled={!editor?.can().chain().focus().toggleHighlight().run()}
      />
      // +++
    </FloatingToolbar>
  );
}

----------------------------------------

TITLE: Running Codemod to Remove Unneeded Type Parameters
DESCRIPTION: Command to run the Liveblocks codemod that removes unnecessary type parameters from functions that use Liveblocks types.

LANGUAGE: bash
CODE:
npx @liveblocks/codemod@latest remove-unneeded-type-params

----------------------------------------

TITLE: Adding Liveblocks Room to Next.js Page Component
DESCRIPTION: Imports the Room component and wraps the CollaborativeApp with it to enable real-time collaboration features in the page. This connects the page to the Liveblocks infrastructure.

LANGUAGE: tsx file
CODE:
import { Room } from "./Room";
import { CollaborativeApp } from "./CollaborativeApp";

export default function Page() {
  return (
    <Room>
      <CollaborativeApp />
    </Room>
  );
}

----------------------------------------

TITLE: Adding Shape Deletion Functionality to Redux Store
DESCRIPTION: Extends the Redux store with a deleteShape action that removes the currently selected shape. When a shape is deleted, the selected shape state is also reset to null, ensuring proper UI updates and state synchronization across users.

LANGUAGE: javascript
CODE:
/* ... */

const initialState = {
  shapes: {},
  selectedShape: null,
};

const slice = createSlice({
  name: "state",
  initialState,
  reducers: {
    insertRectangle: (state) => {
      const shapeId = Date.now().toString();
      const shape = {
        x: getRandomInt(300),
        y: getRandomInt(300),
        fill: getRandomColor(),
      };
      state.shapes[shapeId] = shape;
      state.selectedShape = shapeId;
    },
    onShapePointerDown: (state, action) => {
      /* ... */
    },
    deleteShape: (state) => {
      if (state.selectedShape) {
        delete state.shapes[state.selectedShape];
        state.selectedShape = null;
      }
    },
  },
});

export const { insertRectangle, onShapePointerDown, deleteShape } =
  slice.actions;

export function makeStore() {
  return configureStore({
    reducer: slice.reducer,
    enhancers: [
      liveblocksEnhancer({
        client,
        presenceMapping: { selectedShape: true },
        storageMapping: { shapes: true },
      }),
    ],
  });
}

const store = makeStore();

export default store;

----------------------------------------

TITLE: Implementing Webhook Verification with @liveblocks/node
DESCRIPTION: Expands the webhook endpoint to verify incoming requests using the WebhookHandler from @liveblocks/node. This ensures that requests are genuine and come from Liveblocks by validating the request signature against your webhook secret.

LANGUAGE: typescript
CODE:
import { WebhookHandler } from "@liveblocks/node";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // Update database
  // ...

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Accessing User Information in Liveblocks
DESCRIPTION: Example of how to access the authenticated user's ID and information in a Liveblocks application using the room object.

LANGUAGE: typescript
CODE:
const self = room.getSelf(); // or useSelf() in React
console.log(self.id);
console.log(self.info);

----------------------------------------

TITLE: Using useInboxNotifications with pagination in React
DESCRIPTION: Updated implementation of useInboxNotifications hook that implements pagination support for fetching notifications in batches of 50.

LANGUAGE: tsx
CODE:
import { useInboxNotifications } from "@liveblocks/react/suspense";

function Notifications() {
  const {
    inboxNotifications,
    // +++
    fetchMore,
    isFetchingMore,
    hasFetchedAll,
    fetchMoreError,
    // +++
  } = useInboxNotifications();

  // +++
  const loadMore = fetchMoreError ? (
    <>
      <p>Error loading more notifications: {fetchMoreError.message}</p>
      <button onClick={fetchMore} disabled={isFetchingMore}>
        Retry
      </button>
    </>
  ) : (
    <button onClick={fetchMore} disabled={isFetchingMore}>
      Load more
    </button>
  );
  // +++

  return (
    <div>
      {inboxNotifications.map((notification) => (
        <InboxNotification key={notification.id} inboxNotification={no†ification} />
      ))}
      // +++
      {hasFetchedAll ? <div>🎉 You're all caught up!</div> : loadMore}
      // +++
    </div>
  );
}

----------------------------------------

TITLE: Installing @liveblocks/redux v0.19 with npm
DESCRIPTION: Command to install version 0.19 of @liveblocks/client and @liveblocks/redux packages using npm.

LANGUAGE: bash
CODE:
npm install @liveblocks/client@0.19 @liveblocks/redux@0.19

----------------------------------------

TITLE: Deploying Liveblocks Monaco Editor to Vercel
DESCRIPTION: Command to download the Liveblocks Monaco code editor example and deploy it directly to Vercel. This initializes the project and opens a browser for Vercel deployment configuration.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-yjs-monaco --vercel

----------------------------------------

TITLE: Customizing AnchoredThreads Component
DESCRIPTION: Example of styling the AnchoredThreads component with width, custom class, and other properties.

LANGUAGE: tsx
CODE:
<AnchoredThreads
  editor={editor}
  threads={threads}
  style={{ width: "350px" }}
  className="my-anchored-thread"
/>

----------------------------------------

TITLE: Updating useCreateThread to Support Attachments
DESCRIPTION: Example showing how to update the useCreateThread hook to include the new attachments parameter in Liveblocks 2.8.

LANGUAGE: tsx
CODE:
const createThread = useCreateThread();

// ❌ Before - Liveblocks 2.7
createThread({ body: {}, metadata: {} });

// ✅ After - Liveblocks 2.8
createThread({ body: {}, attachments: [], metadata: {} });

----------------------------------------

TITLE: Importing Liveblocks Default Styles in Next.js
DESCRIPTION: Importing the default CSS styles for Liveblocks React UI components into the root layout of the Next.js application. These styles are required for the proper appearance of notification components.

LANGUAGE: tsx
CODE:
import "@liveblocks/react-ui/styles.css";

----------------------------------------

TITLE: Initializing Storage with RoomProvider
DESCRIPTION: Configures the RoomProvider component to initialize storage with an empty LiveList for todos. This setup provides the foundation for persistent data across sessions and users.

LANGUAGE: tsx
CODE:
/* ... */

import { LiveList } from "@liveblocks/client";

/* WhoIsHere */
/* SomeoneIsTyping */
/* TodoList */

export default function Page() {
  return (
    <LiveblocksProvider publicApiKey={"{{SECRET_KEY}}"}>
      <RoomProvider
        id="my-room"
        initialPresence={{ isTyping: false }}
        // +++
        initialStorage={{ todos: new LiveList() }}
        // +++
      >
        <ClientSideSuspense fallback={<div>Loading…</div>}>
          <ToDoList />
        </ClientSideSuspense>
      </RoomProvider>
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Creating a PlanetScale MySQL Schema for Liveblocks Documents
DESCRIPTION: SQL script to create a 'documents' table in PlanetScale MySQL database. The table has a roomId field as the primary key and a yDocData field to store the stringified JSON Yjs data.

LANGUAGE: sql
CODE:
CREATE TABLE documents (
   roomId VARCHAR(255) PRIMARY KEY,
   yDocData TEXT NOT NULL
);

----------------------------------------

TITLE: Setting up Authentication Endpoint in SvelteKit
DESCRIPTION: Creates a SvelteKit server endpoint for authenticating users with Liveblocks. This endpoint grants permissions to rooms based on a naming pattern, allowing different access levels for organization rooms and group rooms.

LANGUAGE: typescript
CODE:
import { type RequestEvent } from "@sveltejs/kit";
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export async function POST({ request }: RequestEvent) {
  // Get the current user from your database
  const user = __getUserFromDB__(request);

  // Start an auth session inside your endpoint
  const session = liveblocks.prepareSession(
    user.id,
    { userInfo: user.metadata },  // Optional
  );

  // Use a naming pattern to allow access to rooms with wildcards
  // Giving the user read access on their org, and write access on their group
  session.allow(`${user.organization}:*`, session.READ_ACCESS);
  session.allow(`${user.organization}:${user.group}:*`, session.FULL_ACCESS);

  // Authorize the user and return the result
  const { status, body } = await session.authorize();
  return new Response(body, { status });
}

----------------------------------------

TITLE: Defining Custom RoomInfo Type for Liveblocks
DESCRIPTION: Example showing how to define a custom RoomInfo type to improve typing when using resolveRoomsInfo and useRoomInfo APIs.

LANGUAGE: tsx
CODE:
declare global {
  interface Liveblocks {
    RoomInfo: {
      /* your custom type definition here */
    };
  }
}

----------------------------------------

TITLE: Subscribing to storage status changes in Room class
DESCRIPTION: Example of using the room.subscribe method to listen for storage status changes. The method returns an unsubscribe function and provides different status values to handle.

LANGUAGE: typescript
CODE:
room.subscribe("storage-status", (status) => {
  // Implement your logic here
  switch (status) {
    case "not-loaded":
      break;
    case "loading":
      break;
    case "synchronizing":
      break;
    case "synchronized":
      break;
    default:
      break;
  }
});

----------------------------------------

TITLE: Deploying Collaborative Text Editor to Vercel with Liveblocks CLI
DESCRIPTION: Command to set up and deploy the collaborative text editor example to Vercel. This creates a new project based on the template and guides through the Vercel deployment process.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-yjs-lexical --vercel

----------------------------------------

TITLE: Retrieving Lexical Editor State
DESCRIPTION: Shows how to get the Lexical editorState object using the getEditorState method. This provides access to the complete state of the Lexical editor.

LANGUAGE: typescript
CODE:
const editorState = await withLexicalDocument(
  { roomId: "my-room-id", client: liveblocks },
  async (doc) => {
    return doc.getEditorState();
  }
);

----------------------------------------

TITLE: Debugging Type Issues with JSON Compatibility
DESCRIPTION: A debugging technique to identify which part of a custom RoomEvent type is not compatible with JSON. This snippet uses TypeScript's type system to pinpoint exactly where the type error occurs.

LANGUAGE: typescript
CODE:
import type { Json } from "@liveblocks/client";

declare global {
  interface Liveblocks {
    RoomEvent: MyRoomEvent;
  }
}

// Quick debugging snippet to find root cause
const xxx: Json = {} as MyRoomEvent;
//    ^?
//    The error will appear here

----------------------------------------

TITLE: Granting User Access to a Room in Liveblocks
DESCRIPTION: This snippet demonstrates how to grant write access to a specific user for a room by updating the usersAccesses property with liveblocks.updateRoom().

LANGUAGE: typescript
CODE:
const room = await liveblocks.updateRoom("a32wQXid4A9", {
  usersAccesses: {
    "ellen@acme.inc": ["room:write"],
  },
});

----------------------------------------

TITLE: Installing Liveblocks, Yjs, and Quill Packages
DESCRIPTION: Installs the necessary npm packages for implementing a collaborative Quill editor with Liveblocks and Yjs. All Liveblocks packages should use the same version.

LANGUAGE: bash
CODE:
npm install @liveblocks/client @liveblocks/yjs yjs quill quill-cursors y-quill

----------------------------------------

TITLE: Checking Thread Notification Events and User Permissions
DESCRIPTION: This code extends the webhook verification to check for thread notification events specifically on the email channel. It also verifies if users have access to the room and retrieves their email addresses.

LANGUAGE: typescript
CODE:
import { WebhookHandler, isThreadNotificationEvent } from "@liveblocks/node";

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // +++
  // When an inbox notification has been created on the email channel
  if (isThreadNotificationEvent(event) && event.data.channel === "email") {
    // Check if user has access to room
    if (!__hasRoomAccess__(event.userId, event.roomId)) {
      return new Response(null, { status: 200 });
    }

    // The user to send the email to
    const emailAddress = __getEmailAddressFromDB__(event.userId);

    // Send notifications
    // ...
  }
  // +++

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Old Method: Setting Up Multiple Subscriptions
DESCRIPTION: Previous approach for subscribing to multiple storage values and computing derived data, requiring manual setup of effect hooks and subscriptions.

LANGUAGE: tsx
CODE:
function Component() {
  const objA = useObject("a");
  const objB = useObject("b");

  const room = useRoom();
  const [sum, setSum] = useState();
  //     ^^^ We're trying to compute the result of a.x + b.x in here

  useEffect(() => {
    function onChange() {
      setSum(objA.get("x") + objB.get("x"));
    }

    const unsubA = room.subscribe(objA, onChange);
    const unsubB = room.subscribe(objB, onChange);

    return () => {
      unsubA();
      unsubB();
    };
  }, [room, objA, objB]);
}

----------------------------------------

TITLE: Running Codemod to Remove Liveblocks Config Contexts with Suspense
DESCRIPTION: Command to run the Liveblocks codemod that removes the createRoomContext pattern in favor of global type definitions when using Suspense hooks.

LANGUAGE: bash
CODE:
npx @liveblocks/codemod@latest remove-liveblocks-config-contexts --suspense

----------------------------------------

TITLE: Running Codemod for React-Comments Package Rename
DESCRIPTION: Command to automatically update imports after the package rename from @liveblocks/react-comments to @liveblocks/react-ui.

LANGUAGE: bash
CODE:
npx @liveblocks/codemod@latest react-comments-to-react-ui

----------------------------------------

TITLE: Defining Storage Type with LiveObject in TypeScript
DESCRIPTION: Defines a Storage type with a LiveObject called 'person' that contains name and age properties.

LANGUAGE: typescript
CODE:
Storage: {
  person: LiveObject<{
    name: string;
    age: number;
  }>;
}

----------------------------------------

TITLE: Formatting Examples for stringifyCommentBody
DESCRIPTION: Various examples of formatting outputs using stringifyCommentBody with different options, demonstrating plain text, user resolution, markdown, HTML, and custom mention formatting.

LANGUAGE: typescript
CODE:
// "Hello marc@example.com from https://liveblocks.io"
await stringifyCommentBody(comment.body);

// "Hello @Marc from https://liveblocks.io"
await stringifyCommentBody(comment.body, {
  resolveUsers({ userIds }) {
    return [{ name: "Marc" }];
  },
});

// "**Hello** @Marc from [https://liveblocks.io](https://liveblocks.io)"
await stringifyCommentBody(comment.body, {
  format: "markdown",

  resolveUsers() {
    return [{ name: "Marc" }];
  },
});

// "<b>Hello</b> <span data-mention>@Marc</span> from
// <a href="https://liveblocks.io">https://liveblocks.io</a>"
await stringifyCommentBody(comment.body, {
  format: "html",

  resolveUsers() {
    return [{ name: "Marc" }];
  },
});

// "<b>Hello</b> <a href="https://example.com" data-id="marc@example.com">@Marc</a> from
// <a href="https://liveblocks.io">https://liveblocks.io</a>"
await stringifyCommentBody(comment.body, {
  format: "html",

  mention: ({ element, user }) =>
    `<a href="${user.profileUrl}" data-id="${element.id}">${user.name}</a>`,

  resolveUsers() {
    return [{ name: "Marc", profileUrl: "https://example.com" }];
  },
});

----------------------------------------

TITLE: Invalid ThreadMetadata Type Definition in TypeScript
DESCRIPTION: Example of an incorrect ThreadMetadata type definition with two problems: using null values and complex object structures, both of which are not allowed in ThreadMetadata.

LANGUAGE: typescript
CODE:
declare global {
  interface Liveblocks {
    ThreadMetadata: {
      // Your custom fields go here...
      pinned: boolean;
      color: string | null; // ❌ Values may not be null
      position: { x: number; y: number }; // ❌ Values must be simple
      zIndex?: number;
    };
  }
}

----------------------------------------

TITLE: Attaching User Metadata in Authentication Endpoint
DESCRIPTION: Adding user metadata when identifying a user in the authentication endpoint. This metadata will be accessible throughout the application through the useSelf hook.

LANGUAGE: typescript
CODE:
// Get the current user from your database
const user = __getUserFromDB__(request);

// Identify the user and return the result
const { status, body } = await liveblocks.identifyUser(
  {
    userId: user.id,
    groupIds, // Optional
  },
  {
    userInfo: {
      name: user.name,
      avatar: user.avatarUrl,
      colors: user.colorArray,
    }
  },
);

----------------------------------------

TITLE: Implementing Collaborative CodeMirror Editor in Svelte
DESCRIPTION: Creates a Svelte component that integrates Liveblocks with CodeMirror and Yjs to provide real-time collaborative editing. The component handles room connection, document synchronization, and editor setup with JavaScript language support.

LANGUAGE: html
CODE:
<script>
import { onMount, onDestroy } from "svelte";
import { createClient } from "@liveblocks/client";
import { getYjsProviderForRoom } from "@liveblocks/yjs";
import * as Y from "yjs";
import { yCollab } from "y-codemirror.next";
import { EditorView, basicSetup } from "codemirror";
import { EditorState } from "@codemirror/state";
import { javascript } from "@codemirror/lang-javascript";

let parent;

// Set up Liveblocks client
const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

onMount(() => {
  // Enter a multiplayer room
  const { room, leave } = client.enterRoom("my-room");

  // Set up Yjs document, shared text, undo manager, and Liveblocks Yjs provider
  const yProvider = getYjsProviderForRoom(room);
  const yDoc = yProvider.getYDoc();
  const yText = yDoc.getText("codemirror");
  const undoManager = new Y.UndoManager(yText);

  // Set up CodeMirror and extensions
  const state = EditorState.create({
    doc: yText.toString(),
    extensions: [
      basicSetup,
      javascript(),
      yCollab(yText, yProvider.awareness, { undoManager }),
    ],
  });

  // Attach CodeMirror to element
  const view = new EditorView({
    state,
    parent,
  });

  return () => {
    view.destroy();
    leave();
  };
});
</script>

<div bind:this={parent}></div>

----------------------------------------

TITLE: Implementing Typing Detection with Liveblocks Presence
DESCRIPTION: Sets up event listeners to detect when a user is typing and updates their presence state accordingly. Uses 'keydown' and 'blur' events to track when typing begins and ends, and updates the Liveblocks room presence with the user's typing status.

LANGUAGE: javascript
CODE:
import { createClient } from "@liveblocks/client";

const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

function run() {
  const { room, leave } = client.enterRoom("javascript-todo-app", {
    initialPresence: { isTyping: false },
  });

  const whoIsHere = document.getElementById("who_is_here");
  const todoInput = document.getElementById("todo_input");

  room.subscribe("others", (others) => {
    whoIsHere.innerHTML = `There are ${others.count} other users online`;
  });

  todoInput.addEventListener("keydown", (e) => {
    // Clear the input when the user presses "Enter".
    // We'll add todo later on
    if (e.key === "Enter") {
      room.updatePresence({ isTyping: false });
      todoInput.value = "";
    } else {
      room.updatePresence({ isTyping: true });
    }
  });

  todoInput.addEventListener("blur", () => {
    room.updatePresence({ isTyping: false });
  });
}

run();

----------------------------------------

TITLE: Updating imports in @liveblocks/zustand
DESCRIPTION: Code showing the migration from old middleware and LiveblocksState imports to the new liveblocks and WithLiveblocks imports in @liveblocks/zustand.

LANGUAGE: ts
CODE:
import { middleware } from "@liveblocks/zustand";
import type { LiveblocksState } from "@liveblocks/zustand";

LANGUAGE: ts
CODE:
import { liveblocks } from "@liveblocks/zustand";
import type { WithLiveblocks } from "@liveblocks/zustand";

----------------------------------------

TITLE: Running Codemod for Yjs Default Export Change
DESCRIPTION: Command to automatically update imports after the default export in @liveblocks/yjs was changed to a named export.

LANGUAGE: bash
CODE:
npx @liveblocks/codemod@latest remove-yjs-default-export

----------------------------------------

TITLE: Upgrading Liveblocks packages to version 2.2 with npx
DESCRIPTION: Command to automatically upgrade all Liveblocks packages to the latest version 2.2. This uses the create-liveblocks-app tool with the upgrade flag to handle the update process.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --upgrade

----------------------------------------

TITLE: Creating a Parameterized Mutation for Name Updates
DESCRIPTION: Creates a reusable mutation that accepts a parameter to update the name property in storage. This is meant to be added to Room.tsx.

LANGUAGE: typescript
CODE:
// Add mutation
const updateName = useMutation(({ storage }, newName: string) => {
  const person = storage.get("person");
  person.set("name", newName);
}, []);

----------------------------------------

TITLE: Retrieving Inbox Notifications with getInboxNotifications in TypeScript
DESCRIPTION: Demonstrates how to retrieve a user's inbox notifications using the liveblocks.getInboxNotifications method, including examples of retrieving all notifications and filtering for unread notifications.

LANGUAGE: typescript
CODE:
const { data: inboxNotifications, nextCursor } =
  await liveblocks.getInboxNotifications({ userId: "steven@example.com" });

// [{ id: "in_3dH7sF3...", kind: "thread", ... }, { id: "in_3dH7sF3...", kind: "textMention", ... }, ...]
console.log(inboxNotifications);

// Filter unread notifications
const { data: unreadInboxNotifications, nextCursor } =
  await liveblocks.getInboxNotifications({
    userId: "steven@example.com",
    query: { unread: true },
  });

----------------------------------------

TITLE: Corrected ThreadMetadata Type Definition in TypeScript
DESCRIPTION: Fixed version of the ThreadMetadata type definition that follows Liveblocks requirements. It uses optional properties instead of null and flattens complex objects into simple key/value pairs.

LANGUAGE: typescript
CODE:
declare global {
  interface Liveblocks {
    ThreadMetadata: {
      // Your custom fields go here...
      pinned: boolean;
      color?: string; // ✅
      positionX: number; // ✅
      positionY: number; // ✅
      zIndex?: number;
    };
  }
}

----------------------------------------

TITLE: Implementing Collaborative CodeMirror Editor with Yjs and Liveblocks
DESCRIPTION: Complete implementation of a collaborative code editor using CodeMirror, Yjs, and Liveblocks. This component connects to a Liveblocks room, sets up Yjs awareness, and renders a collaborative CodeMirror instance with JavaScript syntax highlighting.

LANGUAGE: tsx
CODE:
"use client";

import * as Y from "yjs";
import { yCollab } from "y-codemirror.next";
import { EditorView, basicSetup } from "codemirror";
import { EditorState } from "@codemirror/state";
import { javascript } from "@codemirror/lang-javascript";
import { useCallback, useEffect, useState } from "react";
import { getYjsProviderForRoom } from "@liveblocks/yjs";
import { useRoom } from "@/liveblocks.config";
import styles from "./Editor.module.css";

export default function Editor() {
  const room = useRoom();
  const yProvider = getYjsProviderForRoom(room);
  const [element, setElement] = useState<HTMLElement>();

  const ref = useCallback((node: HTMLElement | null) => {
    if (!node) return;

    setElement(node);
  }, []);

  // Set up Liveblocks Yjs provider and attach CodeMirror editor
  useEffect(() => {
    let view: EditorView;

    if (!element || !room) {
      return;
    }

    // Get document
    const yDoc = yProvider.getYDoc();
    const yText = yDoc.getText("codemirror");
    const undoManager = new Y.UndoManager(yText);

    // Set up CodeMirror and extensions
    const state = EditorState.create({
      doc: yText.toString(),
      extensions: [
        basicSetup,
        javascript(),
        yCollab(yText, yProvider.awareness, { undoManager }),
      ],
    });

    // Attach CodeMirror to element
    view = new EditorView({
      state,
      parent: element,
    });

    return () => {
      view?.destroy();
    };
  }, [element, room]);

  return <div ref={ref} className={styles.editor} />;
}

----------------------------------------

TITLE: Setting Up Liveblocks Authentication Endpoint (Pages Router)
DESCRIPTION: Alternative version of the authentication endpoint using Next.js Pages Router API format for generating Liveblocks access tokens.

LANGUAGE: typescript
CODE:
import { Liveblocks } from "@liveblocks/node";
import type { NextApiRequest, NextApiResponse } from "next";

const API_KEY = "{{SECRET_KEY}}";

const liveblocks = new Liveblocks({
  secret: API_KEY!,
});

export default async function handler(
  request: NextApiRequest,
  response: NextApiResponse
) {
  // Get the current user's info from your database
  const user = {
    id: "charlielayne@example.com",
    info: {
      name: "Charlie Layne",
      color: "#D583F0",
      picture: "https://liveblocks.io/avatars/avatar-1.png",
    },
  };

  // Create a session for the current user
  // userInfo is made available in Liveblocks presence hooks, e.g. useOthers
  const session = liveblocks.prepareSession(user.id, {
    userInfo: user.info,
  });

  // Give the user access to the room
  const { room } = request.body;
  session.allow(room, session.FULL_ACCESS);

  // Authorize the user and return the result
  const { body, status } = await session.authorize();
  response.status(status).send(body);
}

----------------------------------------

TITLE: Moving Resolver Functions from createRoomContext to createClient - After
DESCRIPTION: Updated implementation in Liveblocks 1.10 where resolver functions are moved to createClient and no longer receive roomId as a parameter, enabling their use across multiple rooms.

LANGUAGE: tsx
CODE:
// ✅ After - Liveblocks 1.10
const client = createClient({
  authEndpoint: "/api/auth/liveblocks-auth",
  async resolveUsers({ userIds }) {
    // ...
  },
  async resolveMentionSuggestions({ text }) {
    // ...
  },
});

const { RoomProvider } = createRoomContext();

----------------------------------------

TITLE: Running the Liveblocks Upgrade Command
DESCRIPTION: Command to upgrade all Liveblocks dependencies to their latest versions using the create-liveblocks-app utility.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --upgrade

----------------------------------------

TITLE: Starting the Development Server
DESCRIPTION: Command to start the Next.js development server after setting up the authentication. This allows you to see your authentication in action and use the collaborative features of the starter kit.

LANGUAGE: bash
CODE:
npm run dev

----------------------------------------

TITLE: Rendering LiveList with Interactive Elements in React
DESCRIPTION: Maps through the people array to render input fields for each person's name, passing the index to the updateName mutation. Includes an Add button that calls the addPerson mutation to demonstrate working with nested data structures.

LANGUAGE: tsx
CODE:
return (
  <div>
    {people.map((person, index) => (
      <input
        key={index}
        type="text"
        value={person.name}
        onChange={(e) => updateName(e.target.value, index)}
      />
    ))}
    <button onClick={addPerson}>Add</button>
  </div>
);

----------------------------------------

TITLE: Installing Liveblocks Node Package
DESCRIPTION: Command to install the @liveblocks/node package, which is required for server-side authentication handling.

LANGUAGE: bash
CODE:
npm install @liveblocks/node

----------------------------------------

TITLE: CommentReactionAddedEvent Schema in TypeScript
DESCRIPTION: TypeScript schema and example for the CommentReactionAddedEvent webhook. This event is triggered when a user adds a reaction emoji to a comment.

LANGUAGE: typescript
CODE:
// Schema
type CommentReactionAddedEvent = {
  type: "commentReactionAdded";
  data: {
    projectId: string;
    roomId: string;
    threadId: string;
    commentId: string;
    emoji: string;
    addedAt: string;
    addedBy: string;
  };
};

// Example
const commentReactionAddedEvent = {
  type: "commentReactionAdded",
  data: {
    projectId: "my-project-id",
    roomId: "my-room-id",
    threadId: "my-thread-id",
    commentId: "my-comment-id",
    emoji: "👍",
    addedAt: "2021-10-06T01:45:56.558Z",
    addedBy: "my-user-id",
  },
};

----------------------------------------

TITLE: Installing Liveblocks Node Package
DESCRIPTION: Command to install the @liveblocks/node package which is required for authentication setup in the SvelteKit application.

LANGUAGE: bash
CODE:
npm install @liveblocks/node

----------------------------------------

TITLE: Styling Tiptap Editor with CSS
DESCRIPTION: CSS styles for customizing the Tiptap editor appearance, including responsive layout for both desktop and mobile views. Includes specific styling for threads to appear differently on different screen sizes.

LANGUAGE: css
CODE:
.editor {
  position: relative;
  display: flex;
  width: 100%;
  height: 100%;
}

.tiptap {
  padding: 2px 12px;
  outline: none;
  width: 100%;
}

/* For mobile */
.floating-threads {
  display: none;
}

/* For desktop */
.anchored-threads {
  display: block;
  max-width: 300px;
  width: 100%;
  position: absolute;
  right: 12px;
}

@media (max-width: 640px) {
  .floating-threads {
    display: block;
  }

  .anchored-threads {
    display: none;
  }
}

----------------------------------------

TITLE: Adding the Collaborative Editor to Next.js Page
DESCRIPTION: Code showing how to integrate the CollaborativeEditor component within a Next.js page, wrapping it in the Room component to enable collaboration.

LANGUAGE: tsx
CODE:
import { Room } from "./Room";
import CollaborativeEditor from "@/components/Editor";

export default function Page() {
  return (
    <Room>
      <CollaborativeEditor />
    </Room>
  );
}

----------------------------------------

TITLE: Running Codemod to Remove Liveblocks Config Contexts with Classic Hooks
DESCRIPTION: Command to run the Liveblocks codemod that removes the createRoomContext pattern in favor of global type definitions when using classic hooks.

LANGUAGE: bash
CODE:
npx @liveblocks/codemod@latest remove-liveblocks-config-contexts

----------------------------------------

TITLE: Creating a Liveblocks Node.js Client
DESCRIPTION: Creates a Node.js client instance to interact with the Liveblocks REST API using your secret key.

LANGUAGE: tsx
CODE:
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "sk_prod_xxxxxxxxxxxxxxxxxxxxxxxx",
});

----------------------------------------

TITLE: Extending UserInfo Type for Liveblocks Presence
DESCRIPTION: How to modify the UserInfo type in liveblocks.config.ts to include properties in Liveblocks presence.

LANGUAGE: typescript
CODE:
export type UserInfo = Pick<User, "randomNumber" /* ... */>;

----------------------------------------

TITLE: Defining Cursor Position in JavaScript
DESCRIPTION: Example of a cursor position object in JavaScript that can be shared with other users through Liveblocks presence.

LANGUAGE: javascript
CODE:
cursor: { x: 256, y: 367 }

----------------------------------------

TITLE: Solving TypeScript Lson constraint error by converting interface to type
DESCRIPTION: Solution 1 for the TypeScript error 'Type does not satisfy the constraint Lson'. This approach converts an interface to a type to ensure JSON serializability for Liveblocks data structures.

LANGUAGE: typescript
CODE:
type Person = {
  name: string;
  age: number;
};

const people = new LiveList<Person>();
//                          ^^^^^^ ✅ All good now

----------------------------------------

TITLE: Advanced Liveblocks Client Configuration with Custom Headers
DESCRIPTION: An advanced configuration for the Liveblocks client that shows how to pass custom headers and body data to the authentication endpoint using a callback approach.

LANGUAGE: typescript
CODE:
import { createClient } from "@liveblocks/client";

// Passing custom headers and body to your endpoint
const client = createClient({
  authEndpoint: async (room) => {
    const headers = {
      // Custom headers
      // ...

      "Content-Type": "application/json",
    };

    const body = JSON.stringify({
      // Custom body
      // ...

      room,
    });

    const response = await fetch("/api/liveblocks-auth", {
      method: "POST",
      headers,
      body,
    });

    return await response.json();
  },
});

----------------------------------------

TITLE: Initializing Liveblocks Config File
DESCRIPTION: Command to create and initialize the liveblocks.config.ts file, which can be used to define TypeScript types for the application later.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --init --framework javascript

----------------------------------------

TITLE: Creating a Liveblocks Room Component with React
DESCRIPTION: Implementation of a Room component that sets up the LiveblocksProvider and RoomProvider to enable collaboration in a specific room. Uses client-side suspense for loading states.

LANGUAGE: tsx
CODE:
"use client";

import { ReactNode } from "react";
import {
  LiveblocksProvider,
  RoomProvider,
  ClientSideSuspense,
} from "@liveblocks/react/suspense";

export function Room({ children }: { children: ReactNode }) {
  return (
    <LiveblocksProvider authEndpoint="/api/liveblocks-auth">
      <RoomProvider id="my-room">
        <ClientSideSuspense fallback={<div>Loading…</div>}>
          {children}
        </ClientSideSuspense>
      </RoomProvider>
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Defining Optional Fields in Liveblocks Schema
DESCRIPTION: Demonstrates how to make fields optional using the ? operator. Optional fields can be deleted, while non-optional fields cannot be removed from the object.

LANGUAGE: typescript
CODE:
type Storage {
  name: string
  age?: number
  height: number
  hasSiblings: boolean
}

----------------------------------------

TITLE: Object Updates with Validation
DESCRIPTION: Shows valid and invalid updates to objects based on schema constraints. Illustrates that all required fields must be provided when setting an object value.

LANGUAGE: typescript
CODE:
// ✅
root.set("scientist", { name: "Marie Curie", age: 66 });

// ❌ Required field 'age' is missing
root.set("scientist", { name: "Marie Curie" });

----------------------------------------

TITLE: Retrieving Tiptap Document Text Content in TypeScript
DESCRIPTION: This snippet demonstrates how to get the text content of a Tiptap document using withProsemirrorDocument and api.getText from @liveblocks/node-prosemirror. It initializes a Liveblocks client with a secret key and retrieves the plain text content from a specific room.

LANGUAGE: typescript
CODE:
import { Liveblocks } from "@liveblocks/node";
import { withProsemirrorDocument } from "@liveblocks/node-prosemirror";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

// +++
const textContent = await withProsemirrorDocument(
  { roomId: "your-room-id", client: liveblocks },
  async (api) => {
    return api.getText();
  }
);
// +++

// "My content"
console.log(textContent);

----------------------------------------

TITLE: Listening for Incoming Events with useEventListener
DESCRIPTION: Implements the useEventListener hook to receive broadcast events from other users. When a TOAST event is received, it triggers a toast notification with the provided message.

LANGUAGE: tsx
CODE:
// Listen for incoming events
useEventListener(({ event }) => {
  if (event.type === "TOAST") {
    toast(event.message);
  }
});

----------------------------------------

TITLE: User Notification Preferences Component with React
DESCRIPTION: A React component that utilizes the useNotificationSettings hook to fetch and update user notification preferences. This example demonstrates how to create a checkbox control for toggling email notifications for threads.

LANGUAGE: tsx
CODE:
import { useNotificationSettings } from "@liveblocks/react";

function NotificationSettings() {
  // +++
  const [{ isLoading, error, settings }, updateSettings] =
    useNotificationSettings();
  // +++

  if (isLoading || error) {
    return null;
  }

  return (
    <form>
      <input
        type="checkbox"
        // +++
        checked={settings.email?.thread}
        onChange={(e) =>
          updateSettings({ email: { thread: e.target.checked } })
        }
        // +++
        id="setting-email-thread"
      />
      <label htmlFor="setting-email-thread">
        Receive thread notifications by email
      </label>
    </form>
  );
}

----------------------------------------

TITLE: Using Liveblocks API v1 Base URL
DESCRIPTION: The base URL to use for all Liveblocks API v1 endpoints.

LANGUAGE: bash
CODE:
https://liveblocks.net/api/v1/

----------------------------------------

TITLE: Setting up Authentication Endpoint with Express
DESCRIPTION: Implementation of an Express endpoint that handles authentication for Liveblocks. This code creates an authentication session and sets up access permissions using room naming patterns and wildcards.

LANGUAGE: typescript
CODE:
const express = require("express");
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

const app = express();
app.use(express.json());

app.post("/api/liveblocks-auth", (req, res) => {
  // Get the current user from your database
  const user = __getUserFromDB__(req);

  // Start an auth session inside your endpoint
  const session = liveblocks.prepareSession(
    user.id,
    { userInfo: user.metadata },  // Optional
  );

  // Use a naming pattern to allow access to rooms with wildcards
  // Giving the user read access on their org, and write access on their group
  session.allow(`${user.organization}:*`, session.READ_ACCESS);
  session.allow(`${user.organization}:${user.group}:*`, session.FULL_ACCESS);

  // Authorize the user and return the result
  const { status, body } = await session.authorize();
  return res.status(status).end(body);
});

----------------------------------------

TITLE: Exporting Suspense Hooks from Liveblocks Config
DESCRIPTION: This snippet shows how to export the Suspense version of Liveblocks hooks from the liveblocks.config.ts file.

LANGUAGE: tsx
CODE:
// ...

export const {
  suspense: {
    // Export from here to use Suspense hooks
    useInboxNotifications,
    useUser,
  },
} = createLiveblocksContext(client, {});

----------------------------------------

TITLE: Configuring Liveblocks Storage with Redux
DESCRIPTION: Updates the Redux store configuration to include shapes storage and configures the Liveblocks enhancer to automatically sync the shapes object with Liveblocks Storage for persistence.

LANGUAGE: javascript
CODE:
import { createClient } from "@liveblocks/client";
import { liveblocksEnhancer } from "@liveblocks/redux";
import { configureStore, createSlice } from "@reduxjs/toolkit";

export const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

const initialState = {
  shapes: {},
};

const slice = createSlice({
  name: "state",
  initialState,
  reducers: {
    /* Reducer logic will go there */
  },
});

export function makeStore() {
  return configureStore({
    reducer: slice.reducer,
    enhancers: [
      liveblocksEnhancer({
        client,
        storageMapping: { shapes: true },
      }),
    ],
  });
}

const store = makeStore();

export default store;

----------------------------------------

TITLE: CommentEditedEvent Schema in TypeScript
DESCRIPTION: TypeScript schema and example for the CommentEditedEvent webhook. This event is triggered when an existing comment is edited by a user.

LANGUAGE: typescript
CODE:
// Schema
type CommentEditedEvent = {
  type: "commentEdited";
  data: {
    projectId: string;
    roomId: string;
    threadId: string;
    commentId: string;
    editedAt: string;
  };
};

// Example
const commentEditedEvent = {
  type: "commentEdited",
  data: {
    projectId: "my-project-id",
    roomId: "my-room-id",
    threadId: "my-thread-id",
    commentId: "my-comment-id",
    editedAt: "2021-10-06T01:45:56.558Z",
  },
};

----------------------------------------

TITLE: Initializing Liveblocks Configuration
DESCRIPTION: Command to create a liveblocks.config.ts file that will be used for defining types and configuration for the Liveblocks application.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --init --framework react

----------------------------------------

TITLE: Configuring Next.js to Transpile Slate-Yjs
DESCRIPTION: Adds transpilePackages configuration to next.config.js to ensure @slate-yjs/react is bundled correctly with Next.js.

LANGUAGE: javascript
CODE:
module.exports = {
  transpilePackages: ["@slate-yjs/react"],

  // ...
};

----------------------------------------

TITLE: Importing Hooks Directly in Liveblocks v2.0
DESCRIPTION: Demonstration of the improved import pattern in Liveblocks v2.0, where hooks can be imported directly from @liveblocks/react instead of from a configuration file.

LANGUAGE: typescript
CODE:
// ❌ Before: get hooks exported from your Liveblocks config
import { RoomProvider, useRoom, ... } from "./liveblocks.config";

// ✅ After: import hooks directly
import { RoomProvider, useRoom, ... } from "@liveblocks/react";
import { RoomProvider, useRoom, ... } from "@liveblocks/react/suspense";

----------------------------------------

TITLE: Enhanced Webhook Handler with Custom Notification Logic
DESCRIPTION: An improved TypeScript webhook handler that can process specific notification kinds based on the channel and kind properties. This implementation demonstrates how to selectively handle custom notification types for email delivery.

LANGUAGE: typescript
CODE:
import { WebhookHandler } from "@liveblocks/node";

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  if (event.type !== "notification") {
    return new Response("This is not a notification webhook", { status: 400 });
  }

  // +++
  if (
    event.data.channel === "email" &&
    event.data.kind === "$myCustomNotification"
  ) {
    // Send an email to your user for this custom notification
    // ...

    return new Response(null, { status: 200 });
  }
  // +++

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: JWT Token Response Format in Liveblocks
DESCRIPTION: Example response format when obtaining a JWT token from the Liveblocks authorization endpoint.

LANGUAGE: json
CODE:
{ "token": "YOUR_JWT_TOKEN" }

----------------------------------------

TITLE: Setting Up Liveblocks Authentication API Route (App Router)
DESCRIPTION: API route using Next.js App Router that handles Liveblocks authentication. Creates a session for the user and authorizes access to a specified room using an API key.

LANGUAGE: typescript
CODE:
import { Liveblocks } from "@liveblocks/node";
import { NextRequest } from "next/server";

const API_KEY = "{{SECRET_KEY}}";

const liveblocks = new Liveblocks({
  secret: API_KEY!,
});

export async function POST(request: NextRequest) {
  // Get the current user's info from your database
  const user = {
    id: "charlielayne@example.com",
    info: {
      name: "Charlie Layne",
      color: "#D583F0",
      picture: "https://liveblocks.io/avatars/avatar-1.png",
    },
  };

  // Create a session for the current user
  // userInfo is made available in Liveblocks presence hooks, e.g. useOthers
  const session = liveblocks.prepareSession(user.id, {
    userInfo: user.info,
  });

  // Give the user access to the room
  const { room } = await request.json();
  session.allow(room, session.FULL_ACCESS);

  // Authorize the user and return the result
  const { body, status } = await session.authorize();
  return new Response(body, { status });
}

----------------------------------------

TITLE: Styling Liveblocks Primitives with Regular Props
DESCRIPTION: Demonstrates styling Liveblocks primitive components using regular HTML props. This approach treats primitives like any other React component.

LANGUAGE: tsx
CODE:
import { Composer } from "@liveblocks/react-ui/primitives";

function Component() {
  return (
    <Composer.Submit className="btn-primary" style={{ color: "#ffffff" }}>
      Reply
    </Composer.Submit>
  );
}

----------------------------------------

TITLE: Creating a new React app with create-react-app
DESCRIPTION: Command to initialize a new React application using create-react-app, which sets up the basic structure for the to-do list project.

LANGUAGE: bash
CODE:
npx create-react-app redux-todo-app

----------------------------------------

TITLE: Solving TypeScript Lson constraint error using EnsureJson helper
DESCRIPTION: Solution 3 for the TypeScript error 'Type does not satisfy the constraint Lson'. This approach uses the EnsureJson utility type to wrap an interface from an external package for use with Liveblocks data structures.

LANGUAGE: typescript
CODE:
import type { LiveList, EnsureJson } from "@liveblocks/client";
import { Person } from "some-external-package";

const people = new LiveList<EnsureJson<Person>>();
//                          ^^^^^^^^^^^^^^^^^^ ✅ All good now

----------------------------------------

TITLE: Creating a Liveblocks Provider Component in Next.js
DESCRIPTION: Creating a NotificationsProvider client component that wraps the LiveblocksProvider from @liveblocks/react. This provider connects users to Liveblocks and enables them to receive notifications from the same project.

LANGUAGE: tsx
CODE:
"use client";

import { ReactNode } from "react";
import { LiveblocksProvider } from "@liveblocks/react";

export function NotificationsProvider({ children }: { children: ReactNode }) {
  return (
    <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>      {children}
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Adding Build Script to package.json
DESCRIPTION: JSON configuration to add a build script that uses esbuild to bundle the application code.

LANGUAGE: json
CODE:
"scripts": {
  "build": "esbuild app.js --bundle --outfile=static/app.js"
},

----------------------------------------

TITLE: Using useUpdateNotificationSettings Hook for Simple Settings Updates
DESCRIPTION: Example of how to use the useUpdateNotificationSettings hook from @liveblocks/react to update user notification settings without needing to retrieve the current settings. Useful for simple updates like unsubscribe buttons.

LANGUAGE: tsx
CODE:
// A suspense version of this hook is available
import { useUpdateNotificationSettings } from "@liveblocks/react";

const updateSettings = useUpdateNotificationSettings();

const onUnsubscribe = () => {
  updateSettings({
    slack: {
      thread: false,
    },
  });
};

----------------------------------------

TITLE: Setting initialContent in BlockNote (Problematic with Yjs)
DESCRIPTION: This example shows the standard way to set initial content in BlockNote, which causes duplication problems when used with Yjs because it appends the initial content to any existing data.

LANGUAGE: tsx
CODE:
function Editor({ doc, provider }: EditorProps) {
  const editor: BlockNoteEditor = useCreateBlockNote({
    // +++
    initialContent: [{ type: "paragraph", content: "Hello world" }],
    // +++

    // Other options
    // ...
  });

  return <BlockNoteView editor={editor} />;
}

----------------------------------------

TITLE: Request Body Format for Initializing Room Storage in Liveblocks
DESCRIPTION: Example JSON request body for initializing a room's storage, demonstrating how to structure LiveObject, LiveList, and LiveMap data.

LANGUAGE: json
CODE:
{
  "liveblocksType": "LiveObject",
  "data": {
    "aLiveObject": {
      "liveblocksType": "LiveObject",
      "data": {
        "a": 1
      }
    },
    "aLiveList": {
      "liveblocksType": "LiveList",
      "data": ["a", "b"]
    },
    "aLiveMap": {
      "liveblocksType": "LiveMap",
      "data": {
        "a": 1,
        "b": 2
      }
    }
  }
}

----------------------------------------

TITLE: Implementing Rich Text Leaf Component for Slate
DESCRIPTION: A React component that renders text nodes with formatting applied. It handles bold, italic, and underline formatting by wrapping children in the appropriate HTML elements based on the leaf's properties.

LANGUAGE: tsx
CODE:
import { PropsWithChildren } from "react";
import { CustomText } from "@/src/types";

type Props = PropsWithChildren<{
  attributes: Record<string, string>;
  leaf: CustomText;
}>;

export function Leaf({ attributes, children, leaf }: Props) {
  if (leaf.bold) {
    children = <strong>{children}</strong>;
  }

  if (leaf.italic) {
    children = <em>{children}</em>;
  }

  if (leaf.underline) {
    children = <u>{children}</u>;
  }

  return <span {...attributes}>{children}</span>;
}

----------------------------------------

TITLE: Component-Level String Overrides in Liveblocks Composer
DESCRIPTION: Shows how to override specific strings at the component level using the overrides prop. This allows for customizing text in specific instances of components.

LANGUAGE: tsx
CODE:
import { Composer } from "@liveblocks/react-ui";

function Component() {
  return (
    <Composer
      overrides={{
        COMPOSER_PLACEHOLDER: "Reply to thread…",
      }}
    />
  );
}

----------------------------------------

TITLE: Creating the SomeoneIsTyping Component with useOthers Hook
DESCRIPTION: Implementation of the SomeoneIsTyping component that checks if any other user is currently typing and displays an indicator message.

LANGUAGE: tsx
CODE:
import {
  LiveblocksProvider,
  RoomProvider,
  ClientSideSuspense,
  useOthers,
  useUpdateMyPresence,
} from "@liveblocks/react/suspense";
import { useState } from "react";

/* WhoIsHere */

function SomeoneIsTyping() {
  const someoneIsTyping = useOthers((others) =>
    others.some((other) => other.presence.isTyping)
  );

  return (
    <div className="someone_is_typing">
      {someoneIsTyping ? "Someone is typing..." : ""}
    </div>
  );
}

function TodoList() {
  const [draft, setDraft] = useState("");
  const updateMyPresence = useUpdateMyPresence();

  return (
    <div className="container">
      <WhoIsHere />
      <input {/* ... */ } />
      <SomeoneIsTyping />
    </div>
  );
}

/* Page */

----------------------------------------

TITLE: Invalid RoomInfo Type Definition in TypeScript
DESCRIPTION: An example of an incorrect RoomInfo type definition that uses URL as a field type, which isn't valid JSON. This causes the type error because only JSON-serializable values are allowed.

LANGUAGE: typescript
CODE:
declare global {
  interface Liveblocks {
    RoomInfo: {
      // Your custom fields go here...
      name: string;
      url: URL; // ❌ The issue is here
      geo: {
        city: string;
        country: string;
      };
    };
  }
}

----------------------------------------

TITLE: Installing Liveblocks Packages with npm
DESCRIPTION: Command to install the required Liveblocks packages (@liveblocks/client, @liveblocks/react, and @liveblocks/react-ui) using npm. All packages should use the same version for compatibility.

LANGUAGE: bash
CODE:
npm install @liveblocks/client @liveblocks/react @liveblocks/react-ui

----------------------------------------

TITLE: Verifying Webhook Requests with @liveblocks/node
DESCRIPTION: Setting up webhook verification using WebhookHandler to ensure requests come from Liveblocks. This code uses the webhook secret key to verify incoming requests and handle errors appropriately.

LANGUAGE: typescript
CODE:
import { WebhookHandler } from "@liveblocks/node";

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // Send notifications
  // ...

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Basic Zustand Store Without Liveblocks Middleware
DESCRIPTION: Example of a basic Zustand store setup without Liveblocks middleware integration. This shows the standard approach to creating a to-do list store with Zustand.

LANGUAGE: typescript
CODE:
import create from "zustand";

type State = {
  draft: string;
  isTyping: boolean;
  todos: Todo[];
  setDraft: (draft: string) => void;
  addTodo: () => void;
  deleteTodo: (index: number) => void;
};

create<State>(/* ... */);

----------------------------------------

TITLE: Installing Supabase JavaScript Client
DESCRIPTION: Command to install the Supabase JavaScript client library using npm.

LANGUAGE: bash
CODE:
npm i @supabase/supabase-js

----------------------------------------

TITLE: Configuring Basic Page Navigation in JSON
DESCRIPTION: Demonstrates how to define a documentation page in the routes.json file, specifying its title and path which reflects both its URL and location in the pages directory.

LANGUAGE: json
CODE:
{
  "title": "React",
  "path": "/get-started/react" // Will fetch the page from /docs/pages/get-started/react.mdx
}

----------------------------------------

TITLE: Setting Up Liveblocks Authentication Endpoint (Next.js App Router)
DESCRIPTION: Creates an authentication endpoint using Next.js App Router to generate access tokens for Liveblocks. This handles user authorization and room access.

LANGUAGE: typescript
CODE:
import { Liveblocks } from "@liveblocks/node";
import { NextRequest } from "next/server";

const API_KEY = "{{SECRET_KEY}}";

const liveblocks = new Liveblocks({
  secret: API_KEY!,
});

export async function POST(request: NextRequest) {
  // Get the current user's info from your database
  const user = {
    id: "charlielayne@example.com",
    info: {
      name: "Charlie Layne",
      color: "#D583F0",
      picture: "https://liveblocks.io/avatars/avatar-1.png",
    },
  };

  // Create a session for the current user
  // userInfo is made available in Liveblocks presence hooks, e.g. useOthers
  const session = liveblocks.prepareSession(user.id, {
    userInfo: user.info,
  });

  // Give the user access to the room
  const { room } = await request.json();
  session.allow(room, session.FULL_ACCESS);

  // Authorize the user and return the result
  const { body, status } = await session.authorize();
  return new Response(body, { status });
}

----------------------------------------

TITLE: Creating a Custom FloatingToolbar in React-Lexical
DESCRIPTION: Shows how to create a fully custom FloatingToolbar by passing elements as children. This approach allows complete control over the toolbar's content and layout.

LANGUAGE: tsx
CODE:
import { FloatingToolbar } from "@liveblocks/react-lexical";

function CustomToolbar() {
  return (
    <FloatingToolbar>
      Hello <strong>world</strong>
    </FloatingToolbar>
  );
}

----------------------------------------

TITLE: Implementing User Resolution for Liveblocks Notifications
DESCRIPTION: Complete example of the resolveUsers function that returns user information in the required format. This provides the names and avatars for users that will be displayed in notification components.

LANGUAGE: tsx
CODE:
<LiveblocksProvider
  resolveUsers={async ({ userIds }) => {
    // ["marc@example.com", ...]
    console.log(userIds);

    // Return a list of users
    return [
      {
        name: "Marc",
        avatar: "https://example.com/marc.png",

        // Your custom metadata
        // ...
      },
      // ...
    ];
  }}

  // ...
/>;

----------------------------------------

TITLE: Debugging Technique for ThreadMetadata Type Issues
DESCRIPTION: A diagnostic snippet to help identify the specific issue with a custom ThreadMetadata type. This assigns the custom type to BaseMetadata to trigger TypeScript errors that explain what's wrong with the type.

LANGUAGE: typescript
CODE:
import type { BaseMetadata } from "@liveblocks/client";

declare global {
  interface Liveblocks {
    ThreadMetadata: MyThreadMetadata;
  }
}

// Quick debugging snippet to find root cause
const xxx: BaseMetadata = {} as MyThreadMetadata;
//    ^?
//    The error will appear here

----------------------------------------

TITLE: Styling the BlockNote Editor and Threads
DESCRIPTION: CSS styles for positioning the editor and threads with responsive design considerations. Includes different layouts for desktop and mobile views.

LANGUAGE: css
CODE:
html {
  font-family: Inter, sans-serif;
  background: #f9f9f9;
}

@media (prefers-color-scheme: dark) {
  html {
    background: #0c0c0c;
  }
}

.editor {
  position: absolute;
  inset: 0;
  max-width: 1024px;
  margin: 0 auto;
  padding: 48px 0;
}

.bn-editor {
  padding: 36px 52px;
  min-height: 100%;
}

/* For mobile */
.floating-threads {
  display: none;
}

/* For desktop */
.anchored-threads {
  display: block;
  max-width: 300px;
  width: 100%;
  position: absolute;
  right: 12px;
}

@media (max-width: 640px) {
  .floating-threads {
    display: block;
  }

  .anchored-threads {
    display: none;
  }
}

----------------------------------------

TITLE: Implementing Liveblocks Webhook Handler with PlanetScale Database Integration
DESCRIPTION: Complete implementation that synchronizes Liveblocks Storage data with a PlanetScale MySQL database using webhooks. The code verifies webhook requests, retrieves Storage data, and updates the database when the 'storageUpdated' event is triggered.

LANGUAGE: typescript
CODE:
import { WebhookHandler } from "@liveblocks/node";
import mysql from "mysql2";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";

// Your PlanetScale database URL
const DATABASE_URL = "YOUR_DATABASE_URL";

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When Storage document data has been updated
  if (event.type === "storageUpdated") {
    const { roomId } = event.data;

    // Get Storage data from Liveblocks REST API
    const url = `https://api.liveblocks.io/v2/rooms/${roomId}/storage`;
    const response = await fetch(url, {
      headers: { Authorization: `Bearer ${API_SECRET}` },
    });

    if (!response.ok) {
      return new Response("Problem accessing Liveblocks REST APIs", {
        status: 500,
      });
    }

    // Your JSON Storage document data as a string
    const storageData = await response.text();

    // Update database
    const connection = await mysql.createConnection(DATABASE_URL);

    const sql = `
      INSERT INTO documents (roomId, storageData)
      VALUES (?, ?)
      ON DUPLICATE KEY UPDATE
          storageData = VALUES(storageData);
    `;

    try {
      await connection.query(sql, [roomId, storageData]);
    } catch (err) {
      return new Response("Problem inserting data into database", {
        status: 500,
      });
    }

    await connection.end();
  }

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Setting up Liveblocks client in React
DESCRIPTION: This code demonstrates how to create a Liveblocks client in a React application. It initializes the client with an authentication endpoint and creates a room provider and hooks for use in components.

LANGUAGE: javascript
CODE:
// liveblocks.config.js
import { createClient } from "@liveblocks/client";
import { createRoomContext } from "@liveblocks/react";

const client = createClient({
  authEndpoint: "/api/auth",
});

export const { RoomProvider, useMyPresence, useUpdateMyPresence, useOthers } =
  createRoomContext(client);

----------------------------------------

TITLE: Creating a Supabase Postgres Table Schema
DESCRIPTION: SQL statement to create a 'documents' table in Supabase with roomId as the primary key and storageData to store the JSON data from Liveblocks Storage.

LANGUAGE: sql
CODE:
CREATE TABLE documents ( roomId VARCHAR(255) PRIMARY KEY, storageData TEXT NOT NULL );

----------------------------------------

TITLE: Manual Project Setup with npm
DESCRIPTION: Command to install all project dependencies for manual setup of the live cursors example.

LANGUAGE: bash
CODE:
npm install

----------------------------------------

TITLE: Creating a Liveblocks Room Component with React
DESCRIPTION: Defines a Room component that provides Liveblocks context to child components using LiveblocksProvider and RoomProvider from @liveblocks/react/suspense.

LANGUAGE: tsx
CODE:
"use client";

import { ReactNode } from "react";
import {
  LiveblocksProvider,
  RoomProvider,
  ClientSideSuspense,
} from "@liveblocks/react/suspense";

export function Room({ children }: { children: ReactNode }) {
  return (
    <LiveblocksProvider authEndpoint="/api/liveblocks-auth">
      <RoomProvider id="my-room">
        <ClientSideSuspense fallback={<div>Loading…</div>}>
          {children}
        </ClientSideSuspense>
      </RoomProvider>
    </LiveblocksProvider>
  );
}

----------------------------------------

TITLE: Using Toolbar.SectionInline Component
DESCRIPTION: Shows how to add a section containing inline formatting actions such as bold, italic, and underline to a Toolbar using the Toolbar.SectionInline component. This section can also be placed inside a FloatingToolbar.

LANGUAGE: tsx
CODE:
import { Toolbar } from "@liveblocks/react-lexical";

<Toolbar>
  // +++
  <Toolbar.SectionInline />
  // +++
</Toolbar>;

----------------------------------------

TITLE: Configuring User Metadata in Access Tokens for Liveblocks Notifications
DESCRIPTION: Example of how to prepare a Liveblocks session with user metadata including name and avatar URL using access token authentication. This metadata will be used in notification components to display user information.

LANGUAGE: typescript
CODE:
const session = liveblocks.prepareSession("marc@example.com", {
  userInfo: {
    name: "Marc",
    avatar: "https://example.com/marc.png",

    // Your custom metadata
    // ...
  },
});

----------------------------------------

TITLE: Customizing Components with Class Names
DESCRIPTION: Shows how to apply more targeted styling to specific Liveblocks components using their class names, including support for contextual data attributes.

LANGUAGE: css
CODE:
.lb-notification {
  /* Customise notification */
}

.lb-avatar[data-loading] {
  /* Customise avatar loading state */
}

----------------------------------------

TITLE: Granting Access to a Specific Design Room in Liveblocks (TSX)
DESCRIPTION: This code shows how to grant access to a specific design room by using its exact room ID. While this works for individual rooms, it doesn't scale well as each room requires manual tracking and token refreshing when new access is granted.

LANGUAGE: tsx
CODE:
// Access to just this `design` room, but not scalable
session.allow("Vu78Rt:design:9Hdu73", session.FULL_ACCESS);

----------------------------------------

TITLE: Adding Selection to History in Liveblocks Store
DESCRIPTION: Advanced implementation that adds selection changes to history using updatePresence with addToHistory option. This enhances undo/redo behavior by including presence updates in the history stack.

LANGUAGE: typescript
CODE:
/* ... */

const useStore = create<WithLiveblocks<State>>()(
  liveblocks(
    (set, get) => ({
      isDragging: false,
      shapes: {},
      selectedShape: null,

      insertRectangle: () => {
        const { shapes, liveblocks } = get();

        const shapeId = Date.now().toString();
        const shape = {
          x: getRandomInt(300),
          y: getRandomInt(300),
          fill: getRandomColor(),
        };

        liveblocks.room?.updatePresence(
          { selectedShape: shapeId },
          { addToHistory: true }
        );
        set({
          shapes: { ...shapes, [shapeId]: shape },
        });
      },
      onShapePointerDown: (shapeId) => {
        const room = get().liveblocks.room;
        room?.history.pause();
        room?.updatePresence(
          { selectedShape: shapeId },
          { addToHistory: true }
        );
        set({ isDragging: true });
      },
      deleteShape: () => {
        const { shapes, selectedShape, liveblocks } = get();
        if (!selectedShape) {
          /* Nothing todo */
          return;
        }
        const { [selectedShape]: shapeToDelete, ...newShapes } = shapes;
        liveblocks.room?.updatePresence(
          { selectedShape: null },
          { addToHistory: true }
        );
        set({ shapes: newShapes });
      },
      onCanvasPointerUp: () => {
        /* ... */
      },
      onCanvasPointerMove: (e) => {
        /* ... */
      },
    }),
    {
      client,
      storageMapping: { shapes: true },
      presenceMapping: { selectedShape: true },
    }
  )
);

export default useStore;

----------------------------------------

TITLE: Using useUpdateNotificationSettings Hook in React
DESCRIPTION: This snippet demonstrates how to use the useUpdateNotificationSettings hook from @liveblocks/react for updating user notification settings. It's useful when only update functionality is needed, such as for an unsubscribe button.

LANGUAGE: tsx
CODE:
// A suspense version of this hook is available
import { useUpdateNotificationSettings } from "@liveblocks/react";

const updateSettings = useUpdateNotificationSettings();

const onUnsubscribe = () => {
  updateSettings({
    slack: {
      thread: false,
    },
  });
};

----------------------------------------

TITLE: Setting Up localtunnel for Local Webhook Testing
DESCRIPTION: Command to create a temporary public URL using localtunnel that forwards requests to your local development server. This allows Liveblocks webhooks to reach your locally running endpoint.

LANGUAGE: bash
CODE:
npx localtunnel --port 3000

----------------------------------------

TITLE: Installing the Liveblocks Comments Example with Next.js
DESCRIPTION: Command to set up the Liveblocks comments example locally. It downloads the example and prompts for permission to open the browser to automatically get an API key from your Liveblocks account.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-comments --api-key

----------------------------------------

TITLE: Initializing Liveblocks Configuration
DESCRIPTION: Command to initialize the Liveblocks configuration file using the CLI tool, setting up the client for React applications.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --init --framework react

----------------------------------------

TITLE: Setting content in a ProseMirror document
DESCRIPTION: Replace the entire content of a ProseMirror document with new content using the setContent method, then return the updated JSON representation of the document.

LANGUAGE: typescript
CODE:
const exampleDoc = {
  type: "doc",
  content: [
    {
      type: "paragraph",
      content: [
        {
          type: "text",
          text: "Example Text",
        },
      ],
    },
  ],
};

const json = await withProsemirrorDocument<string>(
  {
    client,
    roomId: "test-room",
  },
  async (api) => {
    // +++
    await api.setContent(exampleDoc);
    // +++
    return JSON.stringify(api.toJSON());
  }
);

----------------------------------------

TITLE: Managing Notification Settings with Liveblocks Node.js Client
DESCRIPTION: Example of using the Node.js client to manage user notification settings with three methods: getNotificationSettings, updateNotificationSettings, and deleteNotificationSettings. These methods allow fetching, updating, and deleting notification preferences for a user.

LANGUAGE: tsx
CODE:
import { Liveblocks } from "@liveblocks/node";
const liveblocks = new Liveblocks({ secret: "sk_xxx" });

const settings = await liveblocks.getNotificationSettings({ userId });
// { email: { thread: true, ... }, slack: { thread: false, ... }, ... }
console.log(settings);

const updatedSettings = await liveblocks.updateNotificationSettings({
  userId,
  data: {
    teams: {
      $fileUploaded: true,
    },
  },
});
await liveblocks.deleteNotificationSettings({ userId });

----------------------------------------

TITLE: Configuring User Cursor Information in Liveblocks
DESCRIPTION: This example shows how to configure user cursor information by specifying name and color properties in the userInfo object when authenticating users. This information is used to display customized cursors during real-time collaborative editing.

LANGUAGE: js
CODE:
userInfo: {
  name: "Marie",
  color: "#00ff00",
}

----------------------------------------

TITLE: Using useNotificationSettings Hook in React
DESCRIPTION: Demonstrates how to use the useNotificationSettings hook from @liveblocks/react to fetch and update user notification settings. The hook returns current settings and an update function.

LANGUAGE: tsx
CODE:
// A suspense version of this hook is available
import { useNotificationSettings } from "@liveblocks/react";

const [{ isLoading, error, settings }, updateSettings] =
  useNotificationSettings();
// { email: { thread: true, ... }, slack: { thread: false, ... }, ... }
console.log(settings);

const onSave = () => {
  updateSettings({
    slack: {
      textMention: true,
    },
  });
};

----------------------------------------

TITLE: Complete Liveblocks Email Notification Implementation with Resend
DESCRIPTION: A comprehensive example that demonstrates the entire workflow of handling webhook notifications, validating requests, preparing email content, and sending emails using Resend. It includes user and room resolution, custom component styling, and error handling.

LANGUAGE: ts
CODE:
import {
  Liveblocks,
  WebhookHandler,
  isThreadNotificationEvent,
} from "@liveblocks/node";
import { prepareThreadNotificationEmailAsReact } from "@liveblocks/emails";
import { Resend } from "resend";

// Create Resend client (add your API key)
const resend = new Resend("re_123456789");

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "sk_prod_xxxxxxxxxxxxxxxxxxxxxxxx";
const liveblocks = new Liveblocks({ secret: API_SECRET });

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When an inbox notification has been created
  if (isThreadNotificationEvent(event)) {
    // Check if user has access to room
    if (!__hasRoomAccess__(event.userId, event.roomId)) {
      return new Response(null, { status: 200 });
    }

    // The user to send the email to
    const emailAddress = __getEmailAddressFromDB__(event.userId);

    let emailData;

    try {
      emailData = await prepareThreadNotificationEmailAsReact(
        liveblocks,
        event,
        {
          resolveUsers: async ({ userIds }) => {
            const usersData = await __getUsersFromDB__(userIds);

            return usersData.map((userData) => ({
              name: userData.name, // "Steven"
              avatar: userData.avatar.src, // "https://example.com/steven.jpg"
            }));
          },
          resolveRoomInfo: async ({ roomId }) => {
            const roomData = await __getRoomFromDB__(roomId);

            return {
              name: roomData.name, // "Untitled document"
              url: roomData.url, //`https://example.com/my-room-id`
            };
          },
          components: {
            Paragraph: ({ children }) => (
              <p style={{ margin: "12px 0" }}>{children}</p>
            ),

            // `user` is the optional data returned from `resolveUsers`
            Mention: ({ element, user }) => (
              <span style={{ color: "red" }}>@{user?.name ?? element.id}</span>
            ),

            // If the link is rich-text render it, otherwise use the URL
            Link: ({ element, href }) => (
              <a href={href} style={{ textDecoration: "underline" }}>
                {element?.text ?? href}
              </a>
            ),
          },
        }
      );
    } catch (err) {
      console.log(err);
      return new Response("Could not fetch thread notification data", {
        status: 500,
      });
    }

    // All comments have already been read
    if (!emailData) {
      return new Response(null, { status: 200 });
    }

    let email;
    switch (emailData.type) {
      case "unreadMention": {
        email = (
          <div>
            <div>
              @{emailData.comment.author.id} at {emailData.comment.createdAt}
            </div>
            <div>{emailData.comment.reactBody}</div>
          </div>
        );
        break;
      }

      case "unreadReplies": {
        email = (
          <div>
            {emailData.comments.map((comment) => (
              <div key={comment.id}>
                <div>
                  @{comment.author.id} at {comment.createdAt}
                </div>
                <div>{comment.reactBody}</div>
              </div>
            ))}
          </div>
        );
        break;
      }
    }

    // Send email to the user's email address
    try {
      const data = await resend.emails.send({
        from: "My company <hello@my-company.com>",
        to: emailAddress,
        subject: "New comment",
        react: email,
      });
    } catch (err) {
      console.error(err);
    }
  }

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: New Recommended Client Room API in Liveblocks
DESCRIPTION: Demonstrates the new recommended API for entering and leaving rooms in Liveblocks client that supports entering the same room multiple times from different parts of the application.

LANGUAGE: typescript
CODE:
// New API we'll be recommending instead
const { room, leave } = client.enterRoom("my-room", options);
leave();

----------------------------------------

TITLE: Verifying Database Synchronization with SQL Query
DESCRIPTION: SQL query to check if the webhook synchronization is working correctly by displaying all entries in the documents table of the PlanetScale database.

LANGUAGE: sql
CODE:
SELECT * FROM documents;

----------------------------------------

TITLE: Deploying Live Cursors on Vercel
DESCRIPTION: Command to deploy the live cursors example to Vercel. This downloads the example and opens browser prompts to complete the Vercel deployment process.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-live-cursors --vercel

----------------------------------------

TITLE: Enabling Dark Mode with System Preferences
DESCRIPTION: Demonstrates how to enable dark mode using the system's theme preferences through prefers-color-scheme media query.

LANGUAGE: typescript
CODE:
// Dark mode using the system theme with `prefers-color-scheme`
import "@liveblocks/react-ui/styles/dark/media-query.css";

----------------------------------------

TITLE: Full Next.js Route Handler Example for Text Mention Notifications
DESCRIPTION: A complete example showing how to implement a Next.js route handler for processing Liveblocks webhook events, specifically for text mention notifications. It includes webhook verification, event handling, and email content preparation.

LANGUAGE: tsx
CODE:
import {
  isTextMentionNotificationEvent,
  WebhookHandler,
} from "@liveblocks/node";
import { Liveblocks } from "@liveblocks/node";
// +++
import { prepareTextMentionNotificationEmailAsHtml } from "@liveblocks/emails";
// +++

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

const webhookHandler = new WebhookHandler(
  process.env.LIVEBLOCKS_WEBHOOK_SECRET_KEY as string
);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // +++
  if (isTextMentionNotificationEvent(event)) {
    const emailData = await prepareTextMentionNotificationEmailAsHtml(
      liveblocks,
      event
    );

    const email = `
    <div>
      <div>
        @${emailData.mention.author.id} at ${emailData.mention.createdAt}
      </div>
      <div>${emailData.mention.htmlContent}</div>
    </div>
    `;

    // Send your email
    // ...
  }
  // +++

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Typing Others' Presence with Liveblocks Zustand Middleware
DESCRIPTION: Example showing how to specify the Presence type for other users when using Liveblocks with Zustand. Uses the TPresence generic argument on the middleware to provide typing for others' presence data.

LANGUAGE: typescript
CODE:
type Presence = {
  isTyping: true;
}

const useStore = create(
  middleware<State, Presence>(/* ... */, {
    client,
    presenceMapping: { isTyping: true },
    storageMapping: { todos: true }
  })
);

// In your component
useStore(state => state.liveblocks.others[0].presence?.isTyping)

----------------------------------------

TITLE: Creating a Custom Toolbar Button in Tiptap
DESCRIPTION: Shows how to create a custom button for the Tiptap toolbar with an icon, name, keyboard shortcut, and click handler.

LANGUAGE: tsx
CODE:
function CustomButton() {
  return (
    // +++
    <Toolbar.Button
      name="Help"
      icon={<Icon.QuestionMark />}
      shortcut="CMD-H"
      onClick={() => console.log("help")}
    />
    // +++
  );
}

----------------------------------------

TITLE: Styling the Lexical Text Editor
DESCRIPTION: CSS styles for customizing the appearance of the Lexical text editor, including responsive layout for desktop and mobile views, editor padding, and placeholder styling.

LANGUAGE: css
CODE:
.editor {
  position: relative;
  display: flex;
  width: 100%;
  height: 100%;
}

[data-lexical-editor] {
  padding: 2px 12px;
  outline: none;
}

[data-lexical-editor] p {
  margin: 0.8em 0;
}

/* For mobile */
.floating-threads {
  display: none;
}

/* For desktop */
.anchored-threads {
  display: block;
  max-width: 300px;
  width: 100%;
  position: absolute;
  right: 4px;
}

@media (max-width: 640px) {
  .floating-threads {
    display: block;
  }

  .anchored-threads {
    display: none;
  }
}

.placeholder {
  position: absolute;
  left: 12px;
  top: 16px;
  pointer-events: none;
  opacity: 0.5;
}

----------------------------------------

TITLE: Creating and Using a Liveblocks Client in TypeScript
DESCRIPTION: Shows how to create a Liveblocks client instance and use it to get and update user notification settings.

LANGUAGE: typescript
CODE:
import { createClient } from '@liveblocks/client'
const client = createClient({ ... })

const settings = await client.getNotificationSettings();
// { email: { thread: true, ... }, slack: { thread: false, ... }, ... }
console.log(settings);

const updatedSettings = await client.updateNotificationSettings({
  email: {
    thread: false,
  }
});

----------------------------------------

TITLE: Creating React-Based Email Content for Text Mentions
DESCRIPTION: This code builds upon the previous snippets to create React-based email content using the data fetched from prepareTextMentionNotificationEmailAsReact. It constructs a simple email component that displays the author and content of the text mention.

LANGUAGE: tsx
CODE:
import {
  Liveblocks,
  WebhookHandler,
  isTextMentionNotificationEvent,
} from "@liveblocks/node";
import { prepareTextMentionNotificationEmailAsReact } from "@liveblocks/emails";

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";
const liveblocks = new Liveblocks({ secret: API_SECRET });

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When an inbox notification has been created on the email channel
  if (isTextMentionNotificationEvent(event) && event.data.channel === "email") {
    // Check if user has access to room
    if (!__hasRoomAccess__(event.userId, event.roomId)) {
      return new Response(null, { status: 200 });
    }

    // The user to send the email to
    const emailAddress = __getEmailAddressFromDB__(event.userId);

    let emailData;

    try {
      emailData = await prepareTextMentionNotificationEmailAsReact(
        liveblocks,
        event
      );
    } catch (err) {
      console.log(err);
      return new Response("Could not fetch text mention notification data", {
        status: 500,
      });
    }

    // The text mention has already been read
    if (!emailData) {
      return new Response(null, { status: 200 });
    }

    // +++
    const email = (
      <div>
        <div>
          @{emailData.mention.author.id} at {emailData.mention.createdAt}
        </div>
        <div>{emailData.mention.reactContent}</div>
      </div>
    );
    // +++

    // Send emails
    // ...
  }

  return new Response(null, { status: 200 });
}

----------------------------------------

TITLE: Deploying Liveblocks Live Cursors Example to Vercel
DESCRIPTION: Command to create a new Liveblocks application with the advanced live cursors example and deploy it to Vercel. This downloads the example code and guides you through the Vercel deployment process.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-live-cursors-advanced --vercel

----------------------------------------

TITLE: Adding a Floating Comments Composer to BlockNote Editor
DESCRIPTION: A simple example of adding a floating comments composer to a BlockNote editor. This allows users to create new comments and annotations within the text editor by selecting text and using the floating interface.

LANGUAGE: tsx
CODE:
<FloatingComposer editor={editor} />

----------------------------------------

TITLE: Resolving User Data and Room Info for Thread Notification Emails in React
DESCRIPTION: This snippet demonstrates how to resolve user IDs into user information and room IDs into room details when preparing thread notification emails. This allows showing user names and avatars in the email and providing clickable room links.

LANGUAGE: tsx
CODE:
const emailData = await prepareThreadNotificationEmailAsReact(
  liveblocks,
  webhookEvent,
  {
    // +++
    resolveUsers: async ({ userIds }) => {
      const usersData = await __getUsersFromDB__(userIds);

      return usersData.map((userData) => ({
        name: userData.name, // "Nimesh"
        avatar: userData.avatar.src, // "https://..."
      }));
    },
    resolveRoomInfo({ roomId }) {
      return {
        name: roomId, // "my-room-name"
        url: `https://example.com/${roomId}`,
      };
    },
    // +++
  }
);

// { type: "unreadMention", comment: { ... }, ... }
console.log(emailData);

// { name: "Nimesh", avatar: "https://..." }
console.log(emailData.comment.author.info);

// { name: "my-room-name", url: "https://example.com/my-room-name" }
console.log(emailData.roomInfo);

----------------------------------------

TITLE: Running remove-liveblocks-config-contexts Codemod in Shell
DESCRIPTION: Executes the codemod that replaces createRoomContext and createLiveblocksContext in liveblock.config files with global Liveblocks types and updates all imports to @liveblocks/react accordingly.

LANGUAGE: shell
CODE:
npx @liveblocks/codemod@latest remove-liveblocks-config-contexts

----------------------------------------

TITLE: Modifying Tiptap Document Content Server-Side
DESCRIPTION: Uses withProsemirrorDocument to fetch and modify the text editor content from the server, enabling features like AI agents or other server-side text transformations.

LANGUAGE: tsx
CODE:
await withProsemirrorDocument(
  { roomId: "your-room-id", client: liveblocks },
  async (api) => {
    // get editor content
    const text = api.getText();

    await api.update((doc, tr) => {
      // Make real-time updates
      // ...
    });
  }
);

----------------------------------------

TITLE: Integrating Liveblocks Room in Next.js Page
DESCRIPTION: Imports and implements the Room component in a Next.js page file, containing the collaborative Editor component. This structure enables real-time collaboration within the specified room.

LANGUAGE: tsx
CODE:
import { Room } from "./Room";
import { Editor } from "./Editor";

export default function Page() {
  return (
    <Room>
      <Editor/>
    </Room>
  );
}

----------------------------------------

TITLE: Setting throttle option in createClient for improved animation performance
DESCRIPTION: Example of setting the throttle option in createClient to 16ms for improved cursor animation performance of up to 60fps. The default value is 100ms if not specified.

LANGUAGE: typescript
CODE:
import { createClient } from "@liveblocks/client";

const client = createClient({
  /* ... other options ... */
  throttle: 16,
});

----------------------------------------

TITLE: Installing Dependencies for Collaborative Editor
DESCRIPTION: Command to install all necessary packages including Slate for the editor, Yjs for collaboration, and Liveblocks for real-time functionality.

LANGUAGE: bash
CODE:
npm install @liveblocks/client @liveblocks/react @liveblocks/yjs @liveblocks/node yjs slate slate-react @slate-yjs/core @slate-yjs/react

----------------------------------------

TITLE: Installing Liveblocks Live Cursors Chat Example with Next.js
DESCRIPTION: Command to set up the example project locally with automatic API key configuration. This creates a new Liveblocks application based on the nextjs-live-cursors-chat example and prompts for API key generation.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-live-cursors-chat --api-key

----------------------------------------

TITLE: Using Pagination with useThreads in React
DESCRIPTION: Example of using the pagination API with useThreads, which allows for loading threads incrementally. This improves initial load performance and provides a better user experience by fetching more data as needed.

LANGUAGE: tsx
CODE:
const {
  threads,
  isLoading,
  error,

  // ✨ New in Liveblocks 2.9
  fetchMore,
  isFetchingMore,
  hasFetchedAll,
  fetchMoreError,
} = useThreads({ query });

----------------------------------------

TITLE: Rendering InboxNotification Components in React
DESCRIPTION: Demonstrates how to render a list of inbox notifications by mapping through the results from useInboxNotifications hook.

LANGUAGE: tsx
CODE:
import { InboxNotification } from "@liveblocks/react-ui";
import { useInboxNotifications } from "@liveblocks/react/suspense";

function Component() {
  const { inboxNotifications } = useInboxNotifications();

  return (
    <>
      {inboxNotifications.map((inboxNotification) => (
        <InboxNotification
          key={inboxNotification.id}
          inboxNotification={inboxNotification}
        />
      ))}
    </>
  );
}

----------------------------------------

TITLE: Defining Tutorial Folder Structure in Markdown
DESCRIPTION: Shows the basic folder structure for creating a tutorial page with initial state and solution. Two alternative structures are presented for different solution implementations.

LANGUAGE: markdown
CODE:
intial - The project shown when the page loads
solved - The project shown when you press the "Show solution" button 
guide.mdx - The markdown guide

----------------------------------------

TITLE: Editing Thread Metadata with Node.js API Client
DESCRIPTION: Example of using the @liveblocks/node package to edit thread metadata, specifically updating a thread's priority via the Liveblocks Node.js client.

LANGUAGE: ts
CODE:
import { Liveblocks } from "@liveblocks/node";

// Create a Node.js client
const liveblocks = new Liveblocks({ secret: "{{SECRET_KEY}}" });

// Edit a thread's `priority` metadata, passing the user ID that made the change
await liveblocks.editThreadMetadata({
  roomId: "my-room-id",
  threadId: "th_d75sF3...",

  data: {
    metadata: {
      priority: "IMPORTANT",
    },
    userId: "florent@example.com",
  },
});

----------------------------------------

TITLE: Implementing Collaborative Tiptap Text Editor
DESCRIPTION: React component that sets up a collaborative Tiptap text editor using useLiveblocksExtension. Configures the editor with the Liveblocks extension and StarterKit, disabling the default history handling in favor of Liveblocks' own.

LANGUAGE: tsx
CODE:
"use client";

import { useLiveblocksExtension, FloatingToolbar } from "@liveblocks/react-tiptap";
import { useEditor, EditorContent } from "@tiptap/react";
import StarterKit from "@tiptap/starter-kit";
import { Threads } from "./Threads";

export function Editor() {
  const liveblocks = useLiveblocksExtension();

  const editor = useEditor({
    extensions: [
      liveblocks,
      StarterKit.configure({
        // The Liveblocks extension comes with its own history handling
        history: false,
      }),
    ],
  });

  return (
    <div>
      <EditorContent editor={editor} className="editor" />
      <Threads editor={editor} />
      <FloatingToolbar editor={editor} />
    </div>
  );
}

----------------------------------------

TITLE: Updating Client to Use New Authentication Endpoint
DESCRIPTION: This snippet shows how to update the front-end configuration to point to the new authentication endpoint created for Liveblocks 1.2.

LANGUAGE: ts
CODE:
import { createClient } from "@liveblocks/client";

const client = createClient({
  authEndpoint: "/api/liveblocks-auth",
});

----------------------------------------

TITLE: Integrating Toolbar with Monaco Editor
DESCRIPTION: Code snippet showing how to add the Toolbar component to the collaborative editor interface. The toolbar is conditionally rendered when the editor reference is available.

LANGUAGE: tsx
CODE:
import { Toolbar } from "@/components/Toolbar";
// ...

export function CollaborativeEditor() {
  // ...

  return (
    <div className={styles.container}>
      {provider ? <Cursors yProvider={provider} /> : null}
      <div className={styles.editorHeader}>
        <div>{editorRef ? <Toolbar editor={editorRef} /> : null}</div>
      </div>
      <div className={styles.editorContainer}>
        <Editor
          onMount={handleOnMount}
          height="100%"
          width="100hw"
          theme="vs-light"
          defaultLanguage="typescript"
          defaultValue=""
          options={{
            tabSize: 2,
            padding: { top: 20 },
          }}
        />
      </div>
    </div>
  );
}

----------------------------------------

TITLE: Advanced App Structure with Server and Client Components
DESCRIPTION: Shows an advanced pattern for structuring a Next.js app with Liveblocks, combining server-rendered layouts with client components for realtime features.

LANGUAGE: tsx
CODE:
import { ReactNode } from "react";
import { Room } from "./Room";
import { LiveCanvas } from "./LiveCanvas";

export default function Page({ children }: { children: ReactNode }) {
  return (
    // Room.tsx is a client component that contains RoomProvider
    <Room>
      {/* This layout is server rendered */}
      <header style={{ height: "150px" }}>My drawing app</header>
      <main style={{ width: "100%" }}>
        {/* LiveCanvas is a client component using Liveblocks features */}
        <LiveCanvas />
      </main>
    </Room>
  );
}

----------------------------------------

TITLE: Using useErrorListener with expanded error types in Liveblocks 2.16
DESCRIPTION: Example of how to handle the expanded error types in useErrorListener, including new error types for thread creation and notification handling.

LANGUAGE: tsx
CODE:
import { useErrorListener } from "@liveblocks/react";

useErrorListener((error) => {
  switch (error.context.type) {
    // +++
    case "CREATE_THREAD_ERROR":
      const { roomId, threadId, commentId, body, metadata } = error.context;
      break;
    // +++

    // +++
    case "MARK_INBOX_NOTIFICATION_AS_READ_ERROR":
      const { inboxNotificationId, roomId } = error.context;
      break;
    // +++

    // Many other new errors
    // ...
  }
});

----------------------------------------

TITLE: Custom Link Component for Comment.Body
DESCRIPTION: Defines a custom Link component to be used within Comment.Body for displaying hyperlinks with proper attributes.

LANGUAGE: tsx
CODE:
<Comment.Body
  components={{
    Link: ({ href, children }) => (
      <Comment.Link href={href}>{children}</Comment.Link>
    ),
  }}
/>

----------------------------------------

TITLE: Using the Composer Component in React
DESCRIPTION: This example shows how to implement the Composer component from Liveblocks to create new threads. By default, it creates a new thread when the form is submitted.

LANGUAGE: tsx
CODE:
import { Composer } from "@liveblocks/react-ui";

// Creates a new thread
function Component() {
  return <Composer />;
}

----------------------------------------

TITLE: Configuring Liveblocks Client with Auth Endpoint
DESCRIPTION: Sets up the Liveblocks client on the front end by replacing the publicApiKey with the authEndpoint pointing to the authentication endpoint created earlier.

LANGUAGE: typescript
CODE:
import { createClient } from "@liveblocks/client";

const client = createClient({
  authEndpoint: "/api/liveblocks-auth",
});

----------------------------------------

TITLE: Installing Latest Liveblocks Packages with npm
DESCRIPTION: Command to upgrade Liveblocks packages to the latest version using npm. This example shows how to update the client, node, and react packages.

LANGUAGE: bash
CODE:
npm install @liveblocks/client@latest @liveblocks/node@latest @liveblocks/react@latest

----------------------------------------

TITLE: Declaring User Metadata Types for Liveblocks
DESCRIPTION: TypeScript declaration that extends the global Liveblocks interface to define the UserMeta type, providing type hints for user ID and metadata in the editor.

LANGUAGE: typescript
CODE:
declare global {
  interface Liveblocks {
    UserMeta: {
      id: string;

      info: {
        name: string;
        avatar: string;

        // Your custom metadata
        // ...
      };
    };
  }
}

----------------------------------------

TITLE: Installing Collaborative Text Editor Example with Liveblocks CLI
DESCRIPTION: Command to set up the collaborative text editor example using the Liveblocks CLI tool. This automatically downloads the example project and helps you connect it to your Liveblocks account to get an API key.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example nextjs-yjs-tiptap --api-key

----------------------------------------

TITLE: New createRoomContext API for Type Annotation in 0.17
DESCRIPTION: The new pattern using createRoomContext to define types once and have them propagate through all hooks, eliminating the need for generic parameters.

LANGUAGE: tsx
CODE:
import { createClient } from "@liveblocks/client";
import { createRoomContext } from "@liveblocks/react";

const client = createClient({
  /* client options */
});

type Presence = {
  cursor: { x: number; y: number };
};

// This is just to illustrate the API - read on for tips on where to put this!
const { RoomProvider, useMyPresence } = createRoomContext<Presence>(client);

function Root() {
  return (
    <RoomProvider
      id="my-room-id"
      initialPresence={{ cursor: { x: 100, y: 100 } }}
    >
      <Component />
    </RoomProvider>
  );
}

function Component() {
  const [myPresence] = useMyPresence();

  // We can now be sure that cursor is a valid property without any generic typed param
  const cursor = myPresence.cursor;

  /* ... */
}

----------------------------------------

TITLE: Setting Up Presence Mapping with Liveblocks Redux
DESCRIPTION: Configures presenceMapping to synchronize cursor position from Redux state with Liveblocks room presence.

LANGUAGE: js
CODE:
import { liveblocksEnhancer } from "@liveblocks/redux";

const initialState = {
  cursor: { x: 0, y: 0 },
};

const slice = createSlice({
  name: "state",
  initialState,
  reducers: {
    /* reducers */
  },
});

const store = configureStore({
  reducer: slice.reducer,
  enhancers: [
    liveblocksEnhancer({
      client,
      presenceMapping: { cursor: true },
    }),
  ],
});

----------------------------------------

TITLE: Installing Liveblocks Client Package
DESCRIPTION: Command to install the Liveblocks client package using npm. This is the primary dependency needed to implement Liveblocks functionality in a SolidJS application.

LANGUAGE: bash
CODE:
npm install @liveblocks/client

----------------------------------------

TITLE: Installing Liveblocks Node Package
DESCRIPTION: Command to install the @liveblocks/node package in your Firebase functions project using npm.

LANGUAGE: bash
CODE:
npm install @liveblocks/node

----------------------------------------

TITLE: Using upsertRoom Method to Combine Operations
DESCRIPTION: Shows how to use the new upsertRoom method which combines updateRoom and createRoom functionality.

LANGUAGE: javascript
CODE:
.upsertRoom()

----------------------------------------

TITLE: Deploying Live Avatar Stack Example to Vercel
DESCRIPTION: Command to deploy the Live Avatar Stack example to Vercel using create-liveblocks-app, which downloads the example and guides through the Vercel deployment process.

LANGUAGE: bash
CODE:
npx create-liveblocks-app@latest --example vuejs-live-avatars --vercel

----------------------------------------

TITLE: Using iterRooms Method for Automatic Pagination
DESCRIPTION: Shows how to use the new iterRooms method which handles pagination automatically compared to getRooms.

LANGUAGE: javascript
CODE:
.iterRooms()

----------------------------------------

TITLE: Importing Liveblocks Styles in Next.js Layout
DESCRIPTION: Imports the required CSS styles for Liveblocks, Liveblocks-Lexical integration, and custom global styles in the Next.js layout file.

LANGUAGE: tsx
CODE:
import "@liveblocks/react-ui/styles.css";
import "@liveblocks/react-lexical/styles.css";
import "./globals.css";

----------------------------------------

TITLE: Creating a Room with Specific Permissions
DESCRIPTION: Example of using the Liveblocks Node SDK to create a room with specific access permissions. This demonstrates how to set default, group, and user-specific access levels.

LANGUAGE: typescript
CODE:
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

const room = await liveblocks.createRoom("my-room-id", {
  defaultAccesses: ["room:read", "room:presence:write"],
  groupsAccesses: {
    "my-group-id": ["room:write"],
  },
  usersAccesses: {
    "my-user-id": ["room:write"],
  },
});

----------------------------------------

TITLE: Using LiveList.set Method in TypeScript
DESCRIPTION: Demonstrates how to use the LiveList.set method introduced in v0.16.0 to replace an element at a specific index in a LiveList. The example shows replacing the first animal emoji in a list with a wolf emoji.

LANGUAGE: typescript
CODE:
const list = new LiveList(["🦁", "🦊", "🐵"]);
list.set(0, "🐺");
list.toArray(); // equals ["🐺", "🦊", "🐵"]

----------------------------------------

TITLE: Installing Liveblocks Yjs Integration Package
DESCRIPTION: Command to install the @liveblocks/client and @liveblocks/yjs packages via npm, which are required to integrate Yjs applications with Liveblocks collaborative platform.

LANGUAGE: bash
CODE:
npm install @liveblocks/client @liveblocks/yjs

----------------------------------------

TITLE: Filtering Threads by Absence of Metadata in React
DESCRIPTION: Example demonstrating how to filter threads by absence of metadata using the useThreads hook. This shows filtering for threads with the 'pinned' attribute set to true but with no 'color' attribute.

LANGUAGE: typescript
CODE:
useThreads({
  query: {
    // Filter any "pinned" threads that don't have a color set
    metadata: {
      pinned: true,
      color: null, // ✨
    },
  },
});

----------------------------------------

TITLE: Integrating the Liveblocks Room into Next.js Page
DESCRIPTION: Implementation of the Room component in a Next.js page file. The Editor component is wrapped by the Room component to enable collaborative features.

LANGUAGE: tsx
CODE:
import { Room } from "./Room";
import { Editor } from "./Editor";

export default function Page() {
  return (
    <Room>
      <Editor/>
    </Room>
  );
}

----------------------------------------

TITLE: Enabling Dark Mode with System Theme Detection in Liveblocks
DESCRIPTION: Imports the CSS for enabling dark mode based on the system preference using the prefers-color-scheme media query. This automatically switches between light and dark modes based on user's system settings.

LANGUAGE: typescript
CODE:
// Dark mode using the system theme with `prefers-color-scheme`
import "@liveblocks/react-ui/styles/dark/media-query.css";

----------------------------------------

TITLE: Implementing Notification List for BlockNote Editor
DESCRIPTION: This component displays a list of notifications for users in a collaborative text editor. It uses the useInboxNotifications hook to retrieve notifications and renders them using the InboxNotification component.

LANGUAGE: tsx
CODE:
export function CollaborativeApp() {
  const { inboxNotifications } = useInboxNotifications();

  return (
    <InboxNotificationList>
      {inboxNotifications.map((inboxNotification) => (
        <InboxNotification
          key={inboxNotification.id}
          inboxNotification={inboxNotification}
        />
      ))}
    </InboxNotificationList>
  );
}

----------------------------------------

TITLE: Converting Local URL to localtunnel URL
DESCRIPTION: Example showing how to replace the localhost domain with the localtunnel-generated URL to create a publicly accessible webhook endpoint.

LANGUAGE: shell
CODE:
# Take your local URL
http://localhost:3000/api/liveblocks-webhook

# Replace localhost with the generated domain, then copy it
https://my-localtunnel-url.loca.lt/api/liveblocks-webhook

----------------------------------------

TITLE: Importing Default Styles in TypeScript
DESCRIPTION: Shows how to import the default CSS styles for Liveblocks notifications components.

LANGUAGE: typescript
CODE:
import "@liveblocks/react-ui/styles.css";

----------------------------------------

TITLE: Setting Up Liveblocks Authentication Endpoint (Pages Router)
DESCRIPTION: API route implementation for authenticating users with Liveblocks using the older Pages Router pattern in Next.js. This endpoint creates a session and grants access permissions to users.

LANGUAGE: typescript
CODE:
import { Liveblocks } from "@liveblocks/node";
import type { NextApiRequest, NextApiResponse } from "next";

const API_KEY = "{{SECRET_KEY}}";

const liveblocks = new Liveblocks({
  secret: API_KEY!,
});

export default async function handler(
  request: NextApiRequest,
  response: NextApiResponse
) {
  // Get the current user's info from your database
  const user = {
    id: "charlielayne@example.com",
    info: {
      name: "Charlie Layne",
      color: "#D583F0",
      picture: "https://liveblocks.io/avatars/avatar-1.png",
    },
  };

  // Create a session for the current user
  // userInfo is made available in Liveblocks presence hooks, e.g. useOthers
  const session = liveblocks.prepareSession(user.id, {
    userInfo: user.info,
  });

  // Give the user access to the room
  const { room } = request.body;
  session.allow(room, session.FULL_ACCESS);

  // Authorize the user and return the result
  const { status, body } = await session.authorize();
  response.status(status).send(body);
}

----------------------------------------

TITLE: Configuring Store with Liveblocks Presence Mapping in Redux
DESCRIPTION: Shows how to set up a Redux store with Liveblocks enhancer that includes presence mapping for cursor position. This configuration allows sharing real-time cursor state with other connected users.

LANGUAGE: jsx
CODE:
/* ... imports and client setup ... */

const initialState = {
  cursor: { x: 0, y: 0 },
};

const slice = createSlice({
  name: "state",
  initialState,
  reducers: {
    setCursor: (state, action) => {
      state.cursor = action.payload;
    },
  },
});

export const { setCursor } = slice.actions;

function makeStore() {
  return configureStore({
    reducer: slice.reducer,
    enhancers: [
      enhancer({
        client,
        presenceMapping: { cursor: true },
      }),
    ],
  });
}

const store = makeStore();

export default store;